"use strict";
/**
 * acapy
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.7.3
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialOffer = exports.CredentialDefinitionsCreatedResult = exports.CredentialDefinitionSendResult = exports.CredentialDefinitionSendRequest = exports.CredentialDefinitionGetResult = exports.CredentialDefinition = exports.Credential = exports.CredRevokedResult = exports.CredRevRecordResult = exports.CredInfoList = exports.CredDefValueRevocation = exports.CredDefValuePrimary = exports.CredDefValue = exports.CredAttrSpec = exports.CreateWalletTokenResponse = exports.CreateWalletTokenRequest = exports.CreateWalletResponse = exports.CreateWalletRequest = exports.CreateInvitationRequest = exports.Constraints = exports.ConnectionStaticResult = exports.ConnectionStaticRequest = exports.ConnectionModuleResponse = exports.ConnectionMetadataSetRequest = exports.ConnectionMetadata = exports.ConnectionList = exports.ConnectionInvitation = exports.ConnRecord = exports.ClearPendingRevocationsRequest = exports.ClaimFormat = exports.BasicMessageModuleResponse = exports.AttributeMimeTypesResult = exports.AttachmentDef = exports.AttachDecoratorDataJWSHeader = exports.AttachDecoratorDataJWS = exports.AttachDecoratorData1JWS = exports.AttachDecoratorData = exports.AttachDecorator = exports.AdminStatusReadiness = exports.AdminStatusLiveliness = exports.AdminStatus = exports.AdminShutdown = exports.AdminReset = exports.AdminModules = exports.AdminMediationDeny = exports.AdminConfig = exports.AdminAPIMessageTracing = exports.ActionMenuModulesResult = exports.ActionMenuFetchResult = exports.AMLRecord = void 0;
exports.IndyProofProofProofsProof = exports.IndyProofProofAggregatedProof = exports.IndyProofProof = exports.IndyProofIdentifier = exports.IndyProof = exports.IndyPrimaryProof = exports.IndyPresSpec = exports.IndyPresPreview = exports.IndyPresPredSpec = exports.IndyPresAttrSpec = exports.IndyNonRevocationInterval = exports.IndyNonRevocProof = exports.IndyKeyCorrectnessProof = exports.IndyGEProofPred = exports.IndyGEProof = exports.IndyEQProof = exports.IndyCredential = exports.IndyCredRequest = exports.IndyCredPrecis = exports.IndyCredInfo = exports.IndyCredAbstract = exports.IndyAttrValue = exports.HolderModuleResponse = exports.GetNymRoleResponse = exports.GetDIDVerkeyResponse = exports.GetDIDEndpointResponse = exports.Generated = exports.Filter = exports.EndpointsResult = exports.EndorserInfo = exports.Doc = exports.Disclosures = exports.Disclose = exports.DIFProofRequest = exports.DIFProofProposal = exports.DIFPresSpec = exports.DIFOptions = exports.DIFHolder = exports.DIFField = exports.DIDXRequest = exports.DIDResult = exports.DIDList = exports.DIDEndpointWithType = exports.DIDEndpoint = exports.DIDCreateOptions = exports.DIDCreate = exports.DID = exports.CredentialStatusOptions = exports.CredentialProposal = exports.CredentialPreview = void 0;
exports.MenuOption = exports.MenuJson = exports.MenuFormParam = exports.MenuForm = exports.Menu = exports.MediationRecord = exports.MediationList = exports.MediationGrant = exports.MediationDeny = exports.MediationCreateRequest = exports.LinkedDataProof = exports.LedgerModulesResult = exports.LedgerConfigList = exports.LedgerConfigInstance = exports.LDProofVCDetailOptions = exports.LDProofVCDetail = exports.KeylistUpdateRule = exports.KeylistUpdateRequest = exports.KeylistUpdate = exports.KeylistQueryPaginate = exports.KeylistQueryFilterRequest = exports.KeylistQuery = exports.Keylist = exports.IssuerRevRegRecord = exports.IssuerCredRevRecord = exports.IssueCredentialModuleResponse = exports.InvitationResult = exports.InvitationRecord = exports.InvitationMessage = exports.InvitationCreateRequest = exports.IntroModuleResponse = exports.InputDescriptors = exports.IndyRevRegEntryValue = exports.IndyRevRegEntry = exports.IndyRevRegDefValuePublicKeysAccumKey = exports.IndyRevRegDefValuePublicKeys = exports.IndyRevRegDefValue = exports.IndyRevRegDef = exports.IndyRequestedCredsRequestedPred = exports.IndyRequestedCredsRequestedAttr = exports.IndyProofRequestedProofRevealedAttrGroup = exports.IndyProofRequestedProofRevealedAttr = exports.IndyProofRequestedProofPredicate = exports.IndyProofRequestedProof = exports.IndyProofRequestNonRevoked = exports.IndyProofRequest = exports.IndyProofReqPredSpecNonRevoked = exports.IndyProofReqPredSpec = exports.IndyProofReqAttrSpecNonRevoked = exports.IndyProofReqAttrSpec = void 0;
exports.TransactionRecord = exports.TransactionList = exports.TransactionJobs = exports.TAAResult = exports.TAARecord = exports.TAAInfo = exports.TAAAcceptance = exports.TAAAccept = exports.SubmissionRequirements = exports.SignedDoc = exports.SignatureOptions = exports.SignResponse = exports.SignRequest = exports.SendMessage = exports.SendMenu = exports.SchemasInputDescriptorFilter = exports.SchemasCreatedResult = exports.SchemaSendResult = exports.SchemaSendRequest = exports.SchemaInputDescriptor = exports.SchemaGetResult = exports.Schema = exports.RouteRecord = exports.RevokeRequest = exports.RevocationModuleResponse = exports.RevRegsCreated = exports.RevRegUpdateTailsFileUri = exports.RevRegResult = exports.RevRegIssuedResult = exports.RevRegCreateRequest = exports.ResolutionResult = exports.RemoveWalletRequest = exports.RegisterLedgerNymResponse = exports.ReceiveInvitationRequest = exports.RawEncoded = exports.QuestionRequestResponse = exports.QuestionRequest = exports.QueryItem = exports.Query = exports.Queries = exports.PublishRevocations = exports.ProtocolDescriptor = exports.PresentationRequest = exports.PresentationProposal = exports.PresentationDefinition = exports.PingRequestResponse = exports.PingRequest = exports.PerformRequest = exports.MultitenantModuleResponse = exports.ModelDate = void 0;
exports.V20CredRequestRequest = exports.V20CredRequestFree = exports.V20CredRequest = exports.V20CredProposal = exports.V20CredPreview = exports.V20CredOfferRequest = exports.V20CredOfferConnFreeRequest = exports.V20CredOffer = exports.V20CredIssueRequest = exports.V20CredIssueProblemReportRequest = exports.V20CredIssue = exports.V20CredFormat = exports.V20CredFilterLDProof = exports.V20CredFilterIndy = exports.V20CredFilter = exports.V20CredExRecordListResult = exports.V20CredExRecordLDProof = exports.V20CredExRecordIndy = exports.V20CredExRecordDetail = exports.V20CredExRecordByFormat = exports.V20CredExRecord = exports.V20CredExFree = exports.V20CredBoundOfferRequest = exports.V20CredAttrSpec = exports.V10PresentationSendRequestRequest = exports.V10PresentationProposalRequest = exports.V10PresentationProblemReportRequest = exports.V10PresentationExchangeList = exports.V10PresentationExchange = exports.V10PresentationCreateRequestRequest = exports.V10PresentProofModuleResponse = exports.V10DiscoveryRecord = exports.V10DiscoveryExchangeResult = exports.V10DiscoveryExchangeListResult = exports.V10CredentialStoreRequest = exports.V10CredentialProposalRequestOpt = exports.V10CredentialProposalRequestMand = exports.V10CredentialProblemReportRequest = exports.V10CredentialIssueRequest = exports.V10CredentialFreeOfferRequest = exports.V10CredentialExchangeListResult = exports.V10CredentialExchange = exports.V10CredentialCreate = exports.V10CredentialConnFreeOfferRequest = exports.V10CredentialBoundOfferRequest = exports.UpdateWalletRequest = exports.TxnOrSchemaSendResult = exports.TxnOrRevRegResult = exports.TxnOrPublishRevocationsResult = exports.TxnOrCredentialDefinitionSendResult = void 0;
exports.DiscoverFeaturesV20Api = exports.DiscoverFeaturesV20ApiApiKeys = exports.DiscoverFeaturesApi = exports.DiscoverFeaturesApiApiKeys = exports.DidExchangeApi = exports.DidExchangeApiApiKeys = exports.CredentialsApi = exports.CredentialsApiApiKeys = exports.CredentialDefinitionApi = exports.CredentialDefinitionApiApiKeys = exports.ConnectionApi = exports.ConnectionApiApiKeys = exports.BasicmessageApi = exports.BasicmessageApiApiKeys = exports.ActionMenuApi = exports.ActionMenuApiApiKeys = exports.VoidAuth = exports.OAuth = exports.ApiKeyAuth = exports.HttpBasicAuth = exports.WriteLedgerRequest = exports.WalletRecord = exports.WalletModuleResponse = exports.WalletList = exports.W3CCredentialsListRequest = exports.VerifyResponse = exports.VerifyRequest = exports.VCRecordList = exports.VCRecord = exports.V20PresentProofModuleResponse = exports.V20PresSpecByFormatRequest = exports.V20PresSendRequestRequest = exports.V20PresRequestByFormat = exports.V20PresRequest = exports.V20PresProposalRequest = exports.V20PresProposalByFormat = exports.V20PresProposal = exports.V20PresProblemReportRequest = exports.V20PresFormat = exports.V20PresExRecordList = exports.V20PresExRecordByFormat = exports.V20PresExRecord = exports.V20PresCreateRequestRequest = exports.V20Pres = exports.V20IssueCredentialModuleResponse = exports.V20IssueCredSchemaCore = exports.V20DiscoveryRecord = exports.V20DiscoveryExchangeResult = exports.V20DiscoveryExchangeListResult = exports.V20CredStoreRequest = void 0;
exports.WalletApi = exports.WalletApiApiKeys = exports.TrustpingApi = exports.TrustpingApiApiKeys = exports.ServerApi = exports.ServerApiApiKeys = exports.SchemaApi = exports.SchemaApiApiKeys = exports.RevocationApi = exports.RevocationApiApiKeys = exports.ResolverApi = exports.ResolverApiApiKeys = exports.QAProtocolApi = exports.QAProtocolApiApiKeys = exports.PresentProofV20Api = exports.PresentProofV20ApiApiKeys = exports.PresentProofV10Api = exports.PresentProofV10ApiApiKeys = exports.OutOfBandApi = exports.OutOfBandApiApiKeys = exports.MultitenancyApi = exports.MultitenancyApiApiKeys = exports.MediationApi = exports.MediationApiApiKeys = exports.LedgerApi = exports.LedgerApiApiKeys = exports.JsonldApi = exports.JsonldApiApiKeys = exports.IssueCredentialV20Api = exports.IssueCredentialV20ApiApiKeys = exports.IssueCredentialV10Api = exports.IssueCredentialV10ApiApiKeys = exports.IntroductionApi = exports.IntroductionApiApiKeys = exports.EndorseTransactionApi = exports.EndorseTransactionApiApiKeys = void 0;
const localVarRequest = require("request");
let defaultBasePath = 'https://localhost';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
class ObjectSerializer {
    static findCorrectType(data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }
    static serialize(data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }
    static deserialize(data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}
class AMLRecord {
    static getAttributeTypeMap() {
        return AMLRecord.attributeTypeMap;
    }
}
exports.AMLRecord = AMLRecord;
AMLRecord.discriminator = undefined;
AMLRecord.attributeTypeMap = [
    {
        "name": "aml",
        "baseName": "aml",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "amlContext",
        "baseName": "amlContext",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];
class ActionMenuFetchResult {
    static getAttributeTypeMap() {
        return ActionMenuFetchResult.attributeTypeMap;
    }
}
exports.ActionMenuFetchResult = ActionMenuFetchResult;
ActionMenuFetchResult.discriminator = undefined;
ActionMenuFetchResult.attributeTypeMap = [
    {
        "name": "result",
        "baseName": "result",
        "type": "any"
    }
];
class ActionMenuModulesResult {
    static getAttributeTypeMap() {
        return ActionMenuModulesResult.attributeTypeMap;
    }
}
exports.ActionMenuModulesResult = ActionMenuModulesResult;
ActionMenuModulesResult.discriminator = undefined;
ActionMenuModulesResult.attributeTypeMap = [];
class AdminAPIMessageTracing {
    static getAttributeTypeMap() {
        return AdminAPIMessageTracing.attributeTypeMap;
    }
}
exports.AdminAPIMessageTracing = AdminAPIMessageTracing;
AdminAPIMessageTracing.discriminator = undefined;
AdminAPIMessageTracing.attributeTypeMap = [
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class AdminConfig {
    static getAttributeTypeMap() {
        return AdminConfig.attributeTypeMap;
    }
}
exports.AdminConfig = AdminConfig;
AdminConfig.discriminator = undefined;
AdminConfig.attributeTypeMap = [
    {
        "name": "config",
        "baseName": "config",
        "type": "any"
    }
];
class AdminMediationDeny {
    static getAttributeTypeMap() {
        return AdminMediationDeny.attributeTypeMap;
    }
}
exports.AdminMediationDeny = AdminMediationDeny;
AdminMediationDeny.discriminator = undefined;
AdminMediationDeny.attributeTypeMap = [
    {
        "name": "mediator_terms",
        "baseName": "mediator_terms",
        "type": "Array<string>"
    },
    {
        "name": "recipient_terms",
        "baseName": "recipient_terms",
        "type": "Array<string>"
    }
];
class AdminModules {
    static getAttributeTypeMap() {
        return AdminModules.attributeTypeMap;
    }
}
exports.AdminModules = AdminModules;
AdminModules.discriminator = undefined;
AdminModules.attributeTypeMap = [
    {
        "name": "result",
        "baseName": "result",
        "type": "Array<string>"
    }
];
class AdminReset {
    static getAttributeTypeMap() {
        return AdminReset.attributeTypeMap;
    }
}
exports.AdminReset = AdminReset;
AdminReset.discriminator = undefined;
AdminReset.attributeTypeMap = [];
class AdminShutdown {
    static getAttributeTypeMap() {
        return AdminShutdown.attributeTypeMap;
    }
}
exports.AdminShutdown = AdminShutdown;
AdminShutdown.discriminator = undefined;
AdminShutdown.attributeTypeMap = [];
class AdminStatus {
    static getAttributeTypeMap() {
        return AdminStatus.attributeTypeMap;
    }
}
exports.AdminStatus = AdminStatus;
AdminStatus.discriminator = undefined;
AdminStatus.attributeTypeMap = [
    {
        "name": "conductor",
        "baseName": "conductor",
        "type": "any"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "timing",
        "baseName": "timing",
        "type": "any"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];
class AdminStatusLiveliness {
    static getAttributeTypeMap() {
        return AdminStatusLiveliness.attributeTypeMap;
    }
}
exports.AdminStatusLiveliness = AdminStatusLiveliness;
AdminStatusLiveliness.discriminator = undefined;
AdminStatusLiveliness.attributeTypeMap = [
    {
        "name": "alive",
        "baseName": "alive",
        "type": "boolean"
    }
];
class AdminStatusReadiness {
    static getAttributeTypeMap() {
        return AdminStatusReadiness.attributeTypeMap;
    }
}
exports.AdminStatusReadiness = AdminStatusReadiness;
AdminStatusReadiness.discriminator = undefined;
AdminStatusReadiness.attributeTypeMap = [
    {
        "name": "ready",
        "baseName": "ready",
        "type": "boolean"
    }
];
class AttachDecorator {
    static getAttributeTypeMap() {
        return AttachDecorator.attributeTypeMap;
    }
}
exports.AttachDecorator = AttachDecorator;
AttachDecorator.discriminator = undefined;
AttachDecorator.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "byte_count",
        "baseName": "byte_count",
        "type": "number"
    },
    {
        "name": "data",
        "baseName": "data",
        "type": "AttachDecoratorData"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "filename",
        "baseName": "filename",
        "type": "string"
    },
    {
        "name": "lastmod_time",
        "baseName": "lastmod_time",
        "type": "string"
    },
    {
        "name": "mime_type",
        "baseName": "mime-type",
        "type": "string"
    }
];
class AttachDecoratorData {
    static getAttributeTypeMap() {
        return AttachDecoratorData.attributeTypeMap;
    }
}
exports.AttachDecoratorData = AttachDecoratorData;
AttachDecoratorData.discriminator = undefined;
AttachDecoratorData.attributeTypeMap = [
    {
        "name": "base64",
        "baseName": "base64",
        "type": "string"
    },
    {
        "name": "json",
        "baseName": "json",
        "type": "any"
    },
    {
        "name": "jws",
        "baseName": "jws",
        "type": "any"
    },
    {
        "name": "links",
        "baseName": "links",
        "type": "Array<string>"
    },
    {
        "name": "sha256",
        "baseName": "sha256",
        "type": "string"
    }
];
class AttachDecoratorData1JWS {
    static getAttributeTypeMap() {
        return AttachDecoratorData1JWS.attributeTypeMap;
    }
}
exports.AttachDecoratorData1JWS = AttachDecoratorData1JWS;
AttachDecoratorData1JWS.discriminator = undefined;
AttachDecoratorData1JWS.attributeTypeMap = [
    {
        "name": "header",
        "baseName": "header",
        "type": "AttachDecoratorDataJWSHeader"
    },
    {
        "name": "_protected",
        "baseName": "protected",
        "type": "string"
    },
    {
        "name": "signature",
        "baseName": "signature",
        "type": "string"
    }
];
class AttachDecoratorDataJWS {
    static getAttributeTypeMap() {
        return AttachDecoratorDataJWS.attributeTypeMap;
    }
}
exports.AttachDecoratorDataJWS = AttachDecoratorDataJWS;
AttachDecoratorDataJWS.discriminator = undefined;
AttachDecoratorDataJWS.attributeTypeMap = [
    {
        "name": "header",
        "baseName": "header",
        "type": "AttachDecoratorDataJWSHeader"
    },
    {
        "name": "_protected",
        "baseName": "protected",
        "type": "string"
    },
    {
        "name": "signature",
        "baseName": "signature",
        "type": "string"
    },
    {
        "name": "signatures",
        "baseName": "signatures",
        "type": "Array<AttachDecoratorData1JWS>"
    }
];
class AttachDecoratorDataJWSHeader {
    static getAttributeTypeMap() {
        return AttachDecoratorDataJWSHeader.attributeTypeMap;
    }
}
exports.AttachDecoratorDataJWSHeader = AttachDecoratorDataJWSHeader;
AttachDecoratorDataJWSHeader.discriminator = undefined;
AttachDecoratorDataJWSHeader.attributeTypeMap = [
    {
        "name": "kid",
        "baseName": "kid",
        "type": "string"
    }
];
class AttachmentDef {
    static getAttributeTypeMap() {
        return AttachmentDef.attributeTypeMap;
    }
}
exports.AttachmentDef = AttachmentDef;
AttachmentDef.discriminator = undefined;
AttachmentDef.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "AttachmentDef.TypeEnum"
    }
];
(function (AttachmentDef) {
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["CredentialOffer"] = 'credential-offer'] = "CredentialOffer";
        TypeEnum[TypeEnum["PresentProof"] = 'present-proof'] = "PresentProof";
    })(TypeEnum = AttachmentDef.TypeEnum || (AttachmentDef.TypeEnum = {}));
})(AttachmentDef = exports.AttachmentDef || (exports.AttachmentDef = {}));
class AttributeMimeTypesResult {
    static getAttributeTypeMap() {
        return AttributeMimeTypesResult.attributeTypeMap;
    }
}
exports.AttributeMimeTypesResult = AttributeMimeTypesResult;
AttributeMimeTypesResult.discriminator = undefined;
AttributeMimeTypesResult.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "{ [key: string]: string; }"
    }
];
class BasicMessageModuleResponse {
    static getAttributeTypeMap() {
        return BasicMessageModuleResponse.attributeTypeMap;
    }
}
exports.BasicMessageModuleResponse = BasicMessageModuleResponse;
BasicMessageModuleResponse.discriminator = undefined;
BasicMessageModuleResponse.attributeTypeMap = [];
class ClaimFormat {
    static getAttributeTypeMap() {
        return ClaimFormat.attributeTypeMap;
    }
}
exports.ClaimFormat = ClaimFormat;
ClaimFormat.discriminator = undefined;
ClaimFormat.attributeTypeMap = [
    {
        "name": "jwt",
        "baseName": "jwt",
        "type": "any"
    },
    {
        "name": "jwt_vc",
        "baseName": "jwt_vc",
        "type": "any"
    },
    {
        "name": "jwt_vp",
        "baseName": "jwt_vp",
        "type": "any"
    },
    {
        "name": "ldp",
        "baseName": "ldp",
        "type": "any"
    },
    {
        "name": "ldp_vc",
        "baseName": "ldp_vc",
        "type": "any"
    },
    {
        "name": "ldp_vp",
        "baseName": "ldp_vp",
        "type": "any"
    }
];
class ClearPendingRevocationsRequest {
    static getAttributeTypeMap() {
        return ClearPendingRevocationsRequest.attributeTypeMap;
    }
}
exports.ClearPendingRevocationsRequest = ClearPendingRevocationsRequest;
ClearPendingRevocationsRequest.discriminator = undefined;
ClearPendingRevocationsRequest.attributeTypeMap = [
    {
        "name": "purge",
        "baseName": "purge",
        "type": "{ [key: string]: Array<string>; }"
    }
];
class ConnRecord {
    static getAttributeTypeMap() {
        return ConnRecord.attributeTypeMap;
    }
}
exports.ConnRecord = ConnRecord;
ConnRecord.discriminator = undefined;
ConnRecord.attributeTypeMap = [
    {
        "name": "accept",
        "baseName": "accept",
        "type": "ConnRecord.AcceptEnum"
    },
    {
        "name": "alias",
        "baseName": "alias",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "connection_protocol",
        "baseName": "connection_protocol",
        "type": "ConnRecord.ConnectionProtocolEnum"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "error_msg",
        "baseName": "error_msg",
        "type": "string"
    },
    {
        "name": "inbound_connection_id",
        "baseName": "inbound_connection_id",
        "type": "string"
    },
    {
        "name": "invitation_key",
        "baseName": "invitation_key",
        "type": "string"
    },
    {
        "name": "invitation_mode",
        "baseName": "invitation_mode",
        "type": "ConnRecord.InvitationModeEnum"
    },
    {
        "name": "invitation_msg_id",
        "baseName": "invitation_msg_id",
        "type": "string"
    },
    {
        "name": "my_did",
        "baseName": "my_did",
        "type": "string"
    },
    {
        "name": "request_id",
        "baseName": "request_id",
        "type": "string"
    },
    {
        "name": "rfc23_state",
        "baseName": "rfc23_state",
        "type": "string"
    },
    {
        "name": "routing_state",
        "baseName": "routing_state",
        "type": "ConnRecord.RoutingStateEnum"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "their_did",
        "baseName": "their_did",
        "type": "string"
    },
    {
        "name": "their_label",
        "baseName": "their_label",
        "type": "string"
    },
    {
        "name": "their_public_did",
        "baseName": "their_public_did",
        "type": "string"
    },
    {
        "name": "their_role",
        "baseName": "their_role",
        "type": "ConnRecord.TheirRoleEnum"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
(function (ConnRecord) {
    let AcceptEnum;
    (function (AcceptEnum) {
        AcceptEnum[AcceptEnum["Manual"] = 'manual'] = "Manual";
        AcceptEnum[AcceptEnum["Auto"] = 'auto'] = "Auto";
    })(AcceptEnum = ConnRecord.AcceptEnum || (ConnRecord.AcceptEnum = {}));
    let ConnectionProtocolEnum;
    (function (ConnectionProtocolEnum) {
        ConnectionProtocolEnum[ConnectionProtocolEnum["Connections10"] = 'connections/1.0'] = "Connections10";
        ConnectionProtocolEnum[ConnectionProtocolEnum["Didexchange10"] = 'didexchange/1.0'] = "Didexchange10";
    })(ConnectionProtocolEnum = ConnRecord.ConnectionProtocolEnum || (ConnRecord.ConnectionProtocolEnum = {}));
    let InvitationModeEnum;
    (function (InvitationModeEnum) {
        InvitationModeEnum[InvitationModeEnum["Once"] = 'once'] = "Once";
        InvitationModeEnum[InvitationModeEnum["Multi"] = 'multi'] = "Multi";
        InvitationModeEnum[InvitationModeEnum["Static"] = 'static'] = "Static";
    })(InvitationModeEnum = ConnRecord.InvitationModeEnum || (ConnRecord.InvitationModeEnum = {}));
    let RoutingStateEnum;
    (function (RoutingStateEnum) {
        RoutingStateEnum[RoutingStateEnum["None"] = 'none'] = "None";
        RoutingStateEnum[RoutingStateEnum["Request"] = 'request'] = "Request";
        RoutingStateEnum[RoutingStateEnum["Active"] = 'active'] = "Active";
        RoutingStateEnum[RoutingStateEnum["Error"] = 'error'] = "Error";
    })(RoutingStateEnum = ConnRecord.RoutingStateEnum || (ConnRecord.RoutingStateEnum = {}));
    let TheirRoleEnum;
    (function (TheirRoleEnum) {
        TheirRoleEnum[TheirRoleEnum["Invitee"] = 'invitee'] = "Invitee";
        TheirRoleEnum[TheirRoleEnum["Requester"] = 'requester'] = "Requester";
        TheirRoleEnum[TheirRoleEnum["Inviter"] = 'inviter'] = "Inviter";
        TheirRoleEnum[TheirRoleEnum["Responder"] = 'responder'] = "Responder";
    })(TheirRoleEnum = ConnRecord.TheirRoleEnum || (ConnRecord.TheirRoleEnum = {}));
})(ConnRecord = exports.ConnRecord || (exports.ConnRecord = {}));
class ConnectionInvitation {
    static getAttributeTypeMap() {
        return ConnectionInvitation.attributeTypeMap;
    }
}
exports.ConnectionInvitation = ConnectionInvitation;
ConnectionInvitation.discriminator = undefined;
ConnectionInvitation.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "did",
        "baseName": "did",
        "type": "string"
    },
    {
        "name": "imageUrl",
        "baseName": "imageUrl",
        "type": "string"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "recipientKeys",
        "baseName": "recipientKeys",
        "type": "Array<string>"
    },
    {
        "name": "routingKeys",
        "baseName": "routingKeys",
        "type": "Array<string>"
    },
    {
        "name": "serviceEndpoint",
        "baseName": "serviceEndpoint",
        "type": "string"
    }
];
class ConnectionList {
    static getAttributeTypeMap() {
        return ConnectionList.attributeTypeMap;
    }
}
exports.ConnectionList = ConnectionList;
ConnectionList.discriminator = undefined;
ConnectionList.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<ConnRecord>"
    }
];
class ConnectionMetadata {
    static getAttributeTypeMap() {
        return ConnectionMetadata.attributeTypeMap;
    }
}
exports.ConnectionMetadata = ConnectionMetadata;
ConnectionMetadata.discriminator = undefined;
ConnectionMetadata.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "any"
    }
];
class ConnectionMetadataSetRequest {
    static getAttributeTypeMap() {
        return ConnectionMetadataSetRequest.attributeTypeMap;
    }
}
exports.ConnectionMetadataSetRequest = ConnectionMetadataSetRequest;
ConnectionMetadataSetRequest.discriminator = undefined;
ConnectionMetadataSetRequest.attributeTypeMap = [
    {
        "name": "metadata",
        "baseName": "metadata",
        "type": "any"
    }
];
class ConnectionModuleResponse {
    static getAttributeTypeMap() {
        return ConnectionModuleResponse.attributeTypeMap;
    }
}
exports.ConnectionModuleResponse = ConnectionModuleResponse;
ConnectionModuleResponse.discriminator = undefined;
ConnectionModuleResponse.attributeTypeMap = [];
class ConnectionStaticRequest {
    static getAttributeTypeMap() {
        return ConnectionStaticRequest.attributeTypeMap;
    }
}
exports.ConnectionStaticRequest = ConnectionStaticRequest;
ConnectionStaticRequest.discriminator = undefined;
ConnectionStaticRequest.attributeTypeMap = [
    {
        "name": "alias",
        "baseName": "alias",
        "type": "string"
    },
    {
        "name": "my_did",
        "baseName": "my_did",
        "type": "string"
    },
    {
        "name": "my_seed",
        "baseName": "my_seed",
        "type": "string"
    },
    {
        "name": "their_did",
        "baseName": "their_did",
        "type": "string"
    },
    {
        "name": "their_endpoint",
        "baseName": "their_endpoint",
        "type": "string"
    },
    {
        "name": "their_label",
        "baseName": "their_label",
        "type": "string"
    },
    {
        "name": "their_seed",
        "baseName": "their_seed",
        "type": "string"
    },
    {
        "name": "their_verkey",
        "baseName": "their_verkey",
        "type": "string"
    }
];
class ConnectionStaticResult {
    static getAttributeTypeMap() {
        return ConnectionStaticResult.attributeTypeMap;
    }
}
exports.ConnectionStaticResult = ConnectionStaticResult;
ConnectionStaticResult.discriminator = undefined;
ConnectionStaticResult.attributeTypeMap = [
    {
        "name": "my_did",
        "baseName": "my_did",
        "type": "string"
    },
    {
        "name": "my_endpoint",
        "baseName": "my_endpoint",
        "type": "string"
    },
    {
        "name": "my_verkey",
        "baseName": "my_verkey",
        "type": "string"
    },
    {
        "name": "record",
        "baseName": "record",
        "type": "ConnRecord"
    },
    {
        "name": "their_did",
        "baseName": "their_did",
        "type": "string"
    },
    {
        "name": "their_verkey",
        "baseName": "their_verkey",
        "type": "string"
    }
];
class Constraints {
    static getAttributeTypeMap() {
        return Constraints.attributeTypeMap;
    }
}
exports.Constraints = Constraints;
Constraints.discriminator = undefined;
Constraints.attributeTypeMap = [
    {
        "name": "fields",
        "baseName": "fields",
        "type": "Array<DIFField>"
    },
    {
        "name": "is_holder",
        "baseName": "is_holder",
        "type": "Array<DIFHolder>"
    },
    {
        "name": "limit_disclosure",
        "baseName": "limit_disclosure",
        "type": "string"
    },
    {
        "name": "status_active",
        "baseName": "status_active",
        "type": "Constraints.StatusActiveEnum"
    },
    {
        "name": "status_revoked",
        "baseName": "status_revoked",
        "type": "Constraints.StatusRevokedEnum"
    },
    {
        "name": "status_suspended",
        "baseName": "status_suspended",
        "type": "Constraints.StatusSuspendedEnum"
    },
    {
        "name": "subject_is_issuer",
        "baseName": "subject_is_issuer",
        "type": "Constraints.SubjectIsIssuerEnum"
    }
];
(function (Constraints) {
    let StatusActiveEnum;
    (function (StatusActiveEnum) {
        StatusActiveEnum[StatusActiveEnum["Required"] = 'required'] = "Required";
        StatusActiveEnum[StatusActiveEnum["Allowed"] = 'allowed'] = "Allowed";
        StatusActiveEnum[StatusActiveEnum["Disallowed"] = 'disallowed'] = "Disallowed";
    })(StatusActiveEnum = Constraints.StatusActiveEnum || (Constraints.StatusActiveEnum = {}));
    let StatusRevokedEnum;
    (function (StatusRevokedEnum) {
        StatusRevokedEnum[StatusRevokedEnum["Required"] = 'required'] = "Required";
        StatusRevokedEnum[StatusRevokedEnum["Allowed"] = 'allowed'] = "Allowed";
        StatusRevokedEnum[StatusRevokedEnum["Disallowed"] = 'disallowed'] = "Disallowed";
    })(StatusRevokedEnum = Constraints.StatusRevokedEnum || (Constraints.StatusRevokedEnum = {}));
    let StatusSuspendedEnum;
    (function (StatusSuspendedEnum) {
        StatusSuspendedEnum[StatusSuspendedEnum["Required"] = 'required'] = "Required";
        StatusSuspendedEnum[StatusSuspendedEnum["Allowed"] = 'allowed'] = "Allowed";
        StatusSuspendedEnum[StatusSuspendedEnum["Disallowed"] = 'disallowed'] = "Disallowed";
    })(StatusSuspendedEnum = Constraints.StatusSuspendedEnum || (Constraints.StatusSuspendedEnum = {}));
    let SubjectIsIssuerEnum;
    (function (SubjectIsIssuerEnum) {
        SubjectIsIssuerEnum[SubjectIsIssuerEnum["Required"] = 'required'] = "Required";
        SubjectIsIssuerEnum[SubjectIsIssuerEnum["Preferred"] = 'preferred'] = "Preferred";
    })(SubjectIsIssuerEnum = Constraints.SubjectIsIssuerEnum || (Constraints.SubjectIsIssuerEnum = {}));
})(Constraints = exports.Constraints || (exports.Constraints = {}));
class CreateInvitationRequest {
    static getAttributeTypeMap() {
        return CreateInvitationRequest.attributeTypeMap;
    }
}
exports.CreateInvitationRequest = CreateInvitationRequest;
CreateInvitationRequest.discriminator = undefined;
CreateInvitationRequest.attributeTypeMap = [
    {
        "name": "mediation_id",
        "baseName": "mediation_id",
        "type": "string"
    },
    {
        "name": "metadata",
        "baseName": "metadata",
        "type": "any"
    },
    {
        "name": "my_label",
        "baseName": "my_label",
        "type": "string"
    },
    {
        "name": "recipient_keys",
        "baseName": "recipient_keys",
        "type": "Array<string>"
    },
    {
        "name": "routing_keys",
        "baseName": "routing_keys",
        "type": "Array<string>"
    },
    {
        "name": "service_endpoint",
        "baseName": "service_endpoint",
        "type": "string"
    }
];
class CreateWalletRequest {
    static getAttributeTypeMap() {
        return CreateWalletRequest.attributeTypeMap;
    }
}
exports.CreateWalletRequest = CreateWalletRequest;
CreateWalletRequest.discriminator = undefined;
CreateWalletRequest.attributeTypeMap = [
    {
        "name": "image_url",
        "baseName": "image_url",
        "type": "string"
    },
    {
        "name": "key_management_mode",
        "baseName": "key_management_mode",
        "type": "CreateWalletRequest.KeyManagementModeEnum"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "wallet_dispatch_type",
        "baseName": "wallet_dispatch_type",
        "type": "CreateWalletRequest.WalletDispatchTypeEnum"
    },
    {
        "name": "wallet_key",
        "baseName": "wallet_key",
        "type": "string"
    },
    {
        "name": "wallet_name",
        "baseName": "wallet_name",
        "type": "string"
    },
    {
        "name": "wallet_type",
        "baseName": "wallet_type",
        "type": "CreateWalletRequest.WalletTypeEnum"
    },
    {
        "name": "wallet_webhook_urls",
        "baseName": "wallet_webhook_urls",
        "type": "Array<string>"
    }
];
(function (CreateWalletRequest) {
    let KeyManagementModeEnum;
    (function (KeyManagementModeEnum) {
        KeyManagementModeEnum[KeyManagementModeEnum["Managed"] = 'managed'] = "Managed";
    })(KeyManagementModeEnum = CreateWalletRequest.KeyManagementModeEnum || (CreateWalletRequest.KeyManagementModeEnum = {}));
    let WalletDispatchTypeEnum;
    (function (WalletDispatchTypeEnum) {
        WalletDispatchTypeEnum[WalletDispatchTypeEnum["Default"] = 'default'] = "Default";
        WalletDispatchTypeEnum[WalletDispatchTypeEnum["Both"] = 'both'] = "Both";
        WalletDispatchTypeEnum[WalletDispatchTypeEnum["Base"] = 'base'] = "Base";
    })(WalletDispatchTypeEnum = CreateWalletRequest.WalletDispatchTypeEnum || (CreateWalletRequest.WalletDispatchTypeEnum = {}));
    let WalletTypeEnum;
    (function (WalletTypeEnum) {
        WalletTypeEnum[WalletTypeEnum["Askar"] = 'askar'] = "Askar";
        WalletTypeEnum[WalletTypeEnum["InMemory"] = 'in_memory'] = "InMemory";
        WalletTypeEnum[WalletTypeEnum["Indy"] = 'indy'] = "Indy";
    })(WalletTypeEnum = CreateWalletRequest.WalletTypeEnum || (CreateWalletRequest.WalletTypeEnum = {}));
})(CreateWalletRequest = exports.CreateWalletRequest || (exports.CreateWalletRequest = {}));
class CreateWalletResponse {
    static getAttributeTypeMap() {
        return CreateWalletResponse.attributeTypeMap;
    }
}
exports.CreateWalletResponse = CreateWalletResponse;
CreateWalletResponse.discriminator = undefined;
CreateWalletResponse.attributeTypeMap = [
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "key_management_mode",
        "baseName": "key_management_mode",
        "type": "CreateWalletResponse.KeyManagementModeEnum"
    },
    {
        "name": "settings",
        "baseName": "settings",
        "type": "any"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "token",
        "baseName": "token",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    },
    {
        "name": "wallet_id",
        "baseName": "wallet_id",
        "type": "string"
    }
];
(function (CreateWalletResponse) {
    let KeyManagementModeEnum;
    (function (KeyManagementModeEnum) {
        KeyManagementModeEnum[KeyManagementModeEnum["Managed"] = 'managed'] = "Managed";
        KeyManagementModeEnum[KeyManagementModeEnum["Unmanaged"] = 'unmanaged'] = "Unmanaged";
    })(KeyManagementModeEnum = CreateWalletResponse.KeyManagementModeEnum || (CreateWalletResponse.KeyManagementModeEnum = {}));
})(CreateWalletResponse = exports.CreateWalletResponse || (exports.CreateWalletResponse = {}));
class CreateWalletTokenRequest {
    static getAttributeTypeMap() {
        return CreateWalletTokenRequest.attributeTypeMap;
    }
}
exports.CreateWalletTokenRequest = CreateWalletTokenRequest;
CreateWalletTokenRequest.discriminator = undefined;
CreateWalletTokenRequest.attributeTypeMap = [
    {
        "name": "wallet_key",
        "baseName": "wallet_key",
        "type": "string"
    }
];
class CreateWalletTokenResponse {
    static getAttributeTypeMap() {
        return CreateWalletTokenResponse.attributeTypeMap;
    }
}
exports.CreateWalletTokenResponse = CreateWalletTokenResponse;
CreateWalletTokenResponse.discriminator = undefined;
CreateWalletTokenResponse.attributeTypeMap = [
    {
        "name": "token",
        "baseName": "token",
        "type": "string"
    }
];
class CredAttrSpec {
    static getAttributeTypeMap() {
        return CredAttrSpec.attributeTypeMap;
    }
}
exports.CredAttrSpec = CredAttrSpec;
CredAttrSpec.discriminator = undefined;
CredAttrSpec.attributeTypeMap = [
    {
        "name": "mime_type",
        "baseName": "mime-type",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    }
];
class CredDefValue {
    static getAttributeTypeMap() {
        return CredDefValue.attributeTypeMap;
    }
}
exports.CredDefValue = CredDefValue;
CredDefValue.discriminator = undefined;
CredDefValue.attributeTypeMap = [
    {
        "name": "primary",
        "baseName": "primary",
        "type": "any"
    },
    {
        "name": "revocation",
        "baseName": "revocation",
        "type": "any"
    }
];
class CredDefValuePrimary {
    static getAttributeTypeMap() {
        return CredDefValuePrimary.attributeTypeMap;
    }
}
exports.CredDefValuePrimary = CredDefValuePrimary;
CredDefValuePrimary.discriminator = undefined;
CredDefValuePrimary.attributeTypeMap = [
    {
        "name": "n",
        "baseName": "n",
        "type": "string"
    },
    {
        "name": "r",
        "baseName": "r",
        "type": "Generated"
    },
    {
        "name": "rctxt",
        "baseName": "rctxt",
        "type": "string"
    },
    {
        "name": "s",
        "baseName": "s",
        "type": "string"
    },
    {
        "name": "z",
        "baseName": "z",
        "type": "string"
    }
];
class CredDefValueRevocation {
    static getAttributeTypeMap() {
        return CredDefValueRevocation.attributeTypeMap;
    }
}
exports.CredDefValueRevocation = CredDefValueRevocation;
CredDefValueRevocation.discriminator = undefined;
CredDefValueRevocation.attributeTypeMap = [
    {
        "name": "g",
        "baseName": "g",
        "type": "string"
    },
    {
        "name": "g_dash",
        "baseName": "g_dash",
        "type": "string"
    },
    {
        "name": "h",
        "baseName": "h",
        "type": "string"
    },
    {
        "name": "h0",
        "baseName": "h0",
        "type": "string"
    },
    {
        "name": "h1",
        "baseName": "h1",
        "type": "string"
    },
    {
        "name": "h2",
        "baseName": "h2",
        "type": "string"
    },
    {
        "name": "h_cap",
        "baseName": "h_cap",
        "type": "string"
    },
    {
        "name": "htilde",
        "baseName": "htilde",
        "type": "string"
    },
    {
        "name": "pk",
        "baseName": "pk",
        "type": "string"
    },
    {
        "name": "u",
        "baseName": "u",
        "type": "string"
    },
    {
        "name": "y",
        "baseName": "y",
        "type": "string"
    }
];
class CredInfoList {
    static getAttributeTypeMap() {
        return CredInfoList.attributeTypeMap;
    }
}
exports.CredInfoList = CredInfoList;
CredInfoList.discriminator = undefined;
CredInfoList.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<IndyCredInfo>"
    }
];
class CredRevRecordResult {
    static getAttributeTypeMap() {
        return CredRevRecordResult.attributeTypeMap;
    }
}
exports.CredRevRecordResult = CredRevRecordResult;
CredRevRecordResult.discriminator = undefined;
CredRevRecordResult.attributeTypeMap = [
    {
        "name": "result",
        "baseName": "result",
        "type": "IssuerCredRevRecord"
    }
];
class CredRevokedResult {
    static getAttributeTypeMap() {
        return CredRevokedResult.attributeTypeMap;
    }
}
exports.CredRevokedResult = CredRevokedResult;
CredRevokedResult.discriminator = undefined;
CredRevokedResult.attributeTypeMap = [
    {
        "name": "revoked",
        "baseName": "revoked",
        "type": "boolean"
    }
];
class Credential {
    static getAttributeTypeMap() {
        return Credential.attributeTypeMap;
    }
}
exports.Credential = Credential;
Credential.discriminator = undefined;
Credential.attributeTypeMap = [
    {
        "name": "context",
        "baseName": "@context",
        "type": "Array<any>"
    },
    {
        "name": "credentialSubject",
        "baseName": "credentialSubject",
        "type": "any"
    },
    {
        "name": "expirationDate",
        "baseName": "expirationDate",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "issuanceDate",
        "baseName": "issuanceDate",
        "type": "string"
    },
    {
        "name": "issuer",
        "baseName": "issuer",
        "type": "any"
    },
    {
        "name": "proof",
        "baseName": "proof",
        "type": "any"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "Array<string>"
    }
];
class CredentialDefinition {
    static getAttributeTypeMap() {
        return CredentialDefinition.attributeTypeMap;
    }
}
exports.CredentialDefinition = CredentialDefinition;
CredentialDefinition.discriminator = undefined;
CredentialDefinition.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "schemaId",
        "baseName": "schemaId",
        "type": "string"
    },
    {
        "name": "tag",
        "baseName": "tag",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "any"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "any"
    },
    {
        "name": "ver",
        "baseName": "ver",
        "type": "string"
    }
];
class CredentialDefinitionGetResult {
    static getAttributeTypeMap() {
        return CredentialDefinitionGetResult.attributeTypeMap;
    }
}
exports.CredentialDefinitionGetResult = CredentialDefinitionGetResult;
CredentialDefinitionGetResult.discriminator = undefined;
CredentialDefinitionGetResult.attributeTypeMap = [
    {
        "name": "credential_definition",
        "baseName": "credential_definition",
        "type": "CredentialDefinition"
    }
];
class CredentialDefinitionSendRequest {
    static getAttributeTypeMap() {
        return CredentialDefinitionSendRequest.attributeTypeMap;
    }
}
exports.CredentialDefinitionSendRequest = CredentialDefinitionSendRequest;
CredentialDefinitionSendRequest.discriminator = undefined;
CredentialDefinitionSendRequest.attributeTypeMap = [
    {
        "name": "revocation_registry_size",
        "baseName": "revocation_registry_size",
        "type": "number"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    },
    {
        "name": "support_revocation",
        "baseName": "support_revocation",
        "type": "boolean"
    },
    {
        "name": "tag",
        "baseName": "tag",
        "type": "string"
    }
];
class CredentialDefinitionSendResult {
    static getAttributeTypeMap() {
        return CredentialDefinitionSendResult.attributeTypeMap;
    }
}
exports.CredentialDefinitionSendResult = CredentialDefinitionSendResult;
CredentialDefinitionSendResult.discriminator = undefined;
CredentialDefinitionSendResult.attributeTypeMap = [
    {
        "name": "credential_definition_id",
        "baseName": "credential_definition_id",
        "type": "string"
    }
];
class CredentialDefinitionsCreatedResult {
    static getAttributeTypeMap() {
        return CredentialDefinitionsCreatedResult.attributeTypeMap;
    }
}
exports.CredentialDefinitionsCreatedResult = CredentialDefinitionsCreatedResult;
CredentialDefinitionsCreatedResult.discriminator = undefined;
CredentialDefinitionsCreatedResult.attributeTypeMap = [
    {
        "name": "credential_definition_ids",
        "baseName": "credential_definition_ids",
        "type": "Array<string>"
    }
];
class CredentialOffer {
    static getAttributeTypeMap() {
        return CredentialOffer.attributeTypeMap;
    }
}
exports.CredentialOffer = CredentialOffer;
CredentialOffer.discriminator = undefined;
CredentialOffer.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "credential_preview",
        "baseName": "credential_preview",
        "type": "CredentialPreview"
    },
    {
        "name": "offersattach",
        "baseName": "offers~attach",
        "type": "Array<AttachDecorator>"
    }
];
class CredentialPreview {
    static getAttributeTypeMap() {
        return CredentialPreview.attributeTypeMap;
    }
}
exports.CredentialPreview = CredentialPreview;
CredentialPreview.discriminator = undefined;
CredentialPreview.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "attributes",
        "baseName": "attributes",
        "type": "Array<CredAttrSpec>"
    }
];
class CredentialProposal {
    static getAttributeTypeMap() {
        return CredentialProposal.attributeTypeMap;
    }
}
exports.CredentialProposal = CredentialProposal;
CredentialProposal.discriminator = undefined;
CredentialProposal.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "credential_proposal",
        "baseName": "credential_proposal",
        "type": "CredentialPreview"
    },
    {
        "name": "issuer_did",
        "baseName": "issuer_did",
        "type": "string"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    },
    {
        "name": "schema_issuer_did",
        "baseName": "schema_issuer_did",
        "type": "string"
    },
    {
        "name": "schema_name",
        "baseName": "schema_name",
        "type": "string"
    },
    {
        "name": "schema_version",
        "baseName": "schema_version",
        "type": "string"
    }
];
class CredentialStatusOptions {
    static getAttributeTypeMap() {
        return CredentialStatusOptions.attributeTypeMap;
    }
}
exports.CredentialStatusOptions = CredentialStatusOptions;
CredentialStatusOptions.discriminator = undefined;
CredentialStatusOptions.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    }
];
class DID {
    static getAttributeTypeMap() {
        return DID.attributeTypeMap;
    }
}
exports.DID = DID;
DID.discriminator = undefined;
DID.attributeTypeMap = [
    {
        "name": "did",
        "baseName": "did",
        "type": "string"
    },
    {
        "name": "key_type",
        "baseName": "key_type",
        "type": "DID.KeyTypeEnum"
    },
    {
        "name": "method",
        "baseName": "method",
        "type": "DID.MethodEnum"
    },
    {
        "name": "posture",
        "baseName": "posture",
        "type": "DID.PostureEnum"
    },
    {
        "name": "verkey",
        "baseName": "verkey",
        "type": "string"
    }
];
(function (DID) {
    let KeyTypeEnum;
    (function (KeyTypeEnum) {
        KeyTypeEnum[KeyTypeEnum["Ed25519"] = 'ed25519'] = "Ed25519";
        KeyTypeEnum[KeyTypeEnum["Bls12381g2"] = 'bls12381g2'] = "Bls12381g2";
    })(KeyTypeEnum = DID.KeyTypeEnum || (DID.KeyTypeEnum = {}));
    let MethodEnum;
    (function (MethodEnum) {
        MethodEnum[MethodEnum["Sov"] = 'sov'] = "Sov";
        MethodEnum[MethodEnum["Key"] = 'key'] = "Key";
    })(MethodEnum = DID.MethodEnum || (DID.MethodEnum = {}));
    let PostureEnum;
    (function (PostureEnum) {
        PostureEnum[PostureEnum["Public"] = 'public'] = "Public";
        PostureEnum[PostureEnum["Posted"] = 'posted'] = "Posted";
        PostureEnum[PostureEnum["WalletOnly"] = 'wallet_only'] = "WalletOnly";
    })(PostureEnum = DID.PostureEnum || (DID.PostureEnum = {}));
})(DID = exports.DID || (exports.DID = {}));
class DIDCreate {
    static getAttributeTypeMap() {
        return DIDCreate.attributeTypeMap;
    }
}
exports.DIDCreate = DIDCreate;
DIDCreate.discriminator = undefined;
DIDCreate.attributeTypeMap = [
    {
        "name": "method",
        "baseName": "method",
        "type": "DIDCreate.MethodEnum"
    },
    {
        "name": "options",
        "baseName": "options",
        "type": "any"
    }
];
(function (DIDCreate) {
    let MethodEnum;
    (function (MethodEnum) {
        MethodEnum[MethodEnum["Key"] = 'key'] = "Key";
        MethodEnum[MethodEnum["Sov"] = 'sov'] = "Sov";
    })(MethodEnum = DIDCreate.MethodEnum || (DIDCreate.MethodEnum = {}));
})(DIDCreate = exports.DIDCreate || (exports.DIDCreate = {}));
class DIDCreateOptions {
    static getAttributeTypeMap() {
        return DIDCreateOptions.attributeTypeMap;
    }
}
exports.DIDCreateOptions = DIDCreateOptions;
DIDCreateOptions.discriminator = undefined;
DIDCreateOptions.attributeTypeMap = [
    {
        "name": "key_type",
        "baseName": "key_type",
        "type": "DIDCreateOptions.KeyTypeEnum"
    }
];
(function (DIDCreateOptions) {
    let KeyTypeEnum;
    (function (KeyTypeEnum) {
        KeyTypeEnum[KeyTypeEnum["Ed25519"] = 'ed25519'] = "Ed25519";
        KeyTypeEnum[KeyTypeEnum["Bls12381g2"] = 'bls12381g2'] = "Bls12381g2";
    })(KeyTypeEnum = DIDCreateOptions.KeyTypeEnum || (DIDCreateOptions.KeyTypeEnum = {}));
})(DIDCreateOptions = exports.DIDCreateOptions || (exports.DIDCreateOptions = {}));
class DIDEndpoint {
    static getAttributeTypeMap() {
        return DIDEndpoint.attributeTypeMap;
    }
}
exports.DIDEndpoint = DIDEndpoint;
DIDEndpoint.discriminator = undefined;
DIDEndpoint.attributeTypeMap = [
    {
        "name": "did",
        "baseName": "did",
        "type": "string"
    },
    {
        "name": "endpoint",
        "baseName": "endpoint",
        "type": "string"
    }
];
class DIDEndpointWithType {
    static getAttributeTypeMap() {
        return DIDEndpointWithType.attributeTypeMap;
    }
}
exports.DIDEndpointWithType = DIDEndpointWithType;
DIDEndpointWithType.discriminator = undefined;
DIDEndpointWithType.attributeTypeMap = [
    {
        "name": "did",
        "baseName": "did",
        "type": "string"
    },
    {
        "name": "endpoint",
        "baseName": "endpoint",
        "type": "string"
    },
    {
        "name": "endpoint_type",
        "baseName": "endpoint_type",
        "type": "DIDEndpointWithType.EndpointTypeEnum"
    }
];
(function (DIDEndpointWithType) {
    let EndpointTypeEnum;
    (function (EndpointTypeEnum) {
        EndpointTypeEnum[EndpointTypeEnum["Endpoint"] = 'Endpoint'] = "Endpoint";
        EndpointTypeEnum[EndpointTypeEnum["Profile"] = 'Profile'] = "Profile";
        EndpointTypeEnum[EndpointTypeEnum["LinkedDomains"] = 'LinkedDomains'] = "LinkedDomains";
    })(EndpointTypeEnum = DIDEndpointWithType.EndpointTypeEnum || (DIDEndpointWithType.EndpointTypeEnum = {}));
})(DIDEndpointWithType = exports.DIDEndpointWithType || (exports.DIDEndpointWithType = {}));
class DIDList {
    static getAttributeTypeMap() {
        return DIDList.attributeTypeMap;
    }
}
exports.DIDList = DIDList;
DIDList.discriminator = undefined;
DIDList.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<DID>"
    }
];
class DIDResult {
    static getAttributeTypeMap() {
        return DIDResult.attributeTypeMap;
    }
}
exports.DIDResult = DIDResult;
DIDResult.discriminator = undefined;
DIDResult.attributeTypeMap = [
    {
        "name": "result",
        "baseName": "result",
        "type": "DID"
    }
];
class DIDXRequest {
    static getAttributeTypeMap() {
        return DIDXRequest.attributeTypeMap;
    }
}
exports.DIDXRequest = DIDXRequest;
DIDXRequest.discriminator = undefined;
DIDXRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "did",
        "baseName": "did",
        "type": "string"
    },
    {
        "name": "did_docattach",
        "baseName": "did_doc~attach",
        "type": "any"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    }
];
class DIFField {
    static getAttributeTypeMap() {
        return DIFField.attributeTypeMap;
    }
}
exports.DIFField = DIFField;
DIFField.discriminator = undefined;
DIFField.attributeTypeMap = [
    {
        "name": "filter",
        "baseName": "filter",
        "type": "Filter"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "path",
        "baseName": "path",
        "type": "Array<string>"
    },
    {
        "name": "predicate",
        "baseName": "predicate",
        "type": "DIFField.PredicateEnum"
    },
    {
        "name": "purpose",
        "baseName": "purpose",
        "type": "string"
    }
];
(function (DIFField) {
    let PredicateEnum;
    (function (PredicateEnum) {
        PredicateEnum[PredicateEnum["Required"] = 'required'] = "Required";
        PredicateEnum[PredicateEnum["Preferred"] = 'preferred'] = "Preferred";
    })(PredicateEnum = DIFField.PredicateEnum || (DIFField.PredicateEnum = {}));
})(DIFField = exports.DIFField || (exports.DIFField = {}));
class DIFHolder {
    static getAttributeTypeMap() {
        return DIFHolder.attributeTypeMap;
    }
}
exports.DIFHolder = DIFHolder;
DIFHolder.discriminator = undefined;
DIFHolder.attributeTypeMap = [
    {
        "name": "directive",
        "baseName": "directive",
        "type": "DIFHolder.DirectiveEnum"
    },
    {
        "name": "field_id",
        "baseName": "field_id",
        "type": "Array<string>"
    }
];
(function (DIFHolder) {
    let DirectiveEnum;
    (function (DirectiveEnum) {
        DirectiveEnum[DirectiveEnum["Required"] = 'required'] = "Required";
        DirectiveEnum[DirectiveEnum["Preferred"] = 'preferred'] = "Preferred";
    })(DirectiveEnum = DIFHolder.DirectiveEnum || (DIFHolder.DirectiveEnum = {}));
})(DIFHolder = exports.DIFHolder || (exports.DIFHolder = {}));
class DIFOptions {
    static getAttributeTypeMap() {
        return DIFOptions.attributeTypeMap;
    }
}
exports.DIFOptions = DIFOptions;
DIFOptions.discriminator = undefined;
DIFOptions.attributeTypeMap = [
    {
        "name": "challenge",
        "baseName": "challenge",
        "type": "string"
    },
    {
        "name": "domain",
        "baseName": "domain",
        "type": "string"
    }
];
class DIFPresSpec {
    static getAttributeTypeMap() {
        return DIFPresSpec.attributeTypeMap;
    }
}
exports.DIFPresSpec = DIFPresSpec;
DIFPresSpec.discriminator = undefined;
DIFPresSpec.attributeTypeMap = [
    {
        "name": "issuer_id",
        "baseName": "issuer_id",
        "type": "string"
    },
    {
        "name": "presentation_definition",
        "baseName": "presentation_definition",
        "type": "PresentationDefinition"
    },
    {
        "name": "record_ids",
        "baseName": "record_ids",
        "type": "any"
    },
    {
        "name": "reveal_doc",
        "baseName": "reveal_doc",
        "type": "any"
    }
];
class DIFProofProposal {
    static getAttributeTypeMap() {
        return DIFProofProposal.attributeTypeMap;
    }
}
exports.DIFProofProposal = DIFProofProposal;
DIFProofProposal.discriminator = undefined;
DIFProofProposal.attributeTypeMap = [
    {
        "name": "input_descriptors",
        "baseName": "input_descriptors",
        "type": "Array<InputDescriptors>"
    }
];
class DIFProofRequest {
    static getAttributeTypeMap() {
        return DIFProofRequest.attributeTypeMap;
    }
}
exports.DIFProofRequest = DIFProofRequest;
DIFProofRequest.discriminator = undefined;
DIFProofRequest.attributeTypeMap = [
    {
        "name": "options",
        "baseName": "options",
        "type": "DIFOptions"
    },
    {
        "name": "presentation_definition",
        "baseName": "presentation_definition",
        "type": "PresentationDefinition"
    }
];
class Disclose {
    static getAttributeTypeMap() {
        return Disclose.attributeTypeMap;
    }
}
exports.Disclose = Disclose;
Disclose.discriminator = undefined;
Disclose.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "protocols",
        "baseName": "protocols",
        "type": "Array<ProtocolDescriptor>"
    }
];
class Disclosures {
    static getAttributeTypeMap() {
        return Disclosures.attributeTypeMap;
    }
}
exports.Disclosures = Disclosures;
Disclosures.discriminator = undefined;
Disclosures.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "disclosures",
        "baseName": "disclosures",
        "type": "Array<any>"
    }
];
class Doc {
    static getAttributeTypeMap() {
        return Doc.attributeTypeMap;
    }
}
exports.Doc = Doc;
Doc.discriminator = undefined;
Doc.attributeTypeMap = [
    {
        "name": "credential",
        "baseName": "credential",
        "type": "any"
    },
    {
        "name": "options",
        "baseName": "options",
        "type": "any"
    }
];
class EndorserInfo {
    static getAttributeTypeMap() {
        return EndorserInfo.attributeTypeMap;
    }
}
exports.EndorserInfo = EndorserInfo;
EndorserInfo.discriminator = undefined;
EndorserInfo.attributeTypeMap = [
    {
        "name": "endorser_did",
        "baseName": "endorser_did",
        "type": "string"
    },
    {
        "name": "endorser_name",
        "baseName": "endorser_name",
        "type": "string"
    }
];
class EndpointsResult {
    static getAttributeTypeMap() {
        return EndpointsResult.attributeTypeMap;
    }
}
exports.EndpointsResult = EndpointsResult;
EndpointsResult.discriminator = undefined;
EndpointsResult.attributeTypeMap = [
    {
        "name": "my_endpoint",
        "baseName": "my_endpoint",
        "type": "string"
    },
    {
        "name": "their_endpoint",
        "baseName": "their_endpoint",
        "type": "string"
    }
];
class Filter {
    static getAttributeTypeMap() {
        return Filter.attributeTypeMap;
    }
}
exports.Filter = Filter;
Filter.discriminator = undefined;
Filter.attributeTypeMap = [
    {
        "name": "_const",
        "baseName": "const",
        "type": "any"
    },
    {
        "name": "_enum",
        "baseName": "enum",
        "type": "Array<any>"
    },
    {
        "name": "exclusiveMaximum",
        "baseName": "exclusiveMaximum",
        "type": "any"
    },
    {
        "name": "exclusiveMinimum",
        "baseName": "exclusiveMinimum",
        "type": "any"
    },
    {
        "name": "format",
        "baseName": "format",
        "type": "string"
    },
    {
        "name": "maxLength",
        "baseName": "maxLength",
        "type": "number"
    },
    {
        "name": "maximum",
        "baseName": "maximum",
        "type": "any"
    },
    {
        "name": "minLength",
        "baseName": "minLength",
        "type": "number"
    },
    {
        "name": "minimum",
        "baseName": "minimum",
        "type": "any"
    },
    {
        "name": "not",
        "baseName": "not",
        "type": "boolean"
    },
    {
        "name": "pattern",
        "baseName": "pattern",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    }
];
class Generated {
    static getAttributeTypeMap() {
        return Generated.attributeTypeMap;
    }
}
exports.Generated = Generated;
Generated.discriminator = undefined;
Generated.attributeTypeMap = [
    {
        "name": "master_secret",
        "baseName": "master_secret",
        "type": "string"
    },
    {
        "name": "number",
        "baseName": "number",
        "type": "string"
    },
    {
        "name": "remainder",
        "baseName": "remainder",
        "type": "string"
    }
];
class GetDIDEndpointResponse {
    static getAttributeTypeMap() {
        return GetDIDEndpointResponse.attributeTypeMap;
    }
}
exports.GetDIDEndpointResponse = GetDIDEndpointResponse;
GetDIDEndpointResponse.discriminator = undefined;
GetDIDEndpointResponse.attributeTypeMap = [
    {
        "name": "endpoint",
        "baseName": "endpoint",
        "type": "string"
    }
];
class GetDIDVerkeyResponse {
    static getAttributeTypeMap() {
        return GetDIDVerkeyResponse.attributeTypeMap;
    }
}
exports.GetDIDVerkeyResponse = GetDIDVerkeyResponse;
GetDIDVerkeyResponse.discriminator = undefined;
GetDIDVerkeyResponse.attributeTypeMap = [
    {
        "name": "verkey",
        "baseName": "verkey",
        "type": "string"
    }
];
class GetNymRoleResponse {
    static getAttributeTypeMap() {
        return GetNymRoleResponse.attributeTypeMap;
    }
}
exports.GetNymRoleResponse = GetNymRoleResponse;
GetNymRoleResponse.discriminator = undefined;
GetNymRoleResponse.attributeTypeMap = [
    {
        "name": "role",
        "baseName": "role",
        "type": "GetNymRoleResponse.RoleEnum"
    }
];
(function (GetNymRoleResponse) {
    let RoleEnum;
    (function (RoleEnum) {
        RoleEnum[RoleEnum["STEWARD"] = 'STEWARD'] = "STEWARD";
        RoleEnum[RoleEnum["TRUSTEE"] = 'TRUSTEE'] = "TRUSTEE";
        RoleEnum[RoleEnum["ENDORSER"] = 'ENDORSER'] = "ENDORSER";
        RoleEnum[RoleEnum["NETWORKMONITOR"] = 'NETWORK_MONITOR'] = "NETWORKMONITOR";
        RoleEnum[RoleEnum["USER"] = 'USER'] = "USER";
        RoleEnum[RoleEnum["ROLEREMOVE"] = 'ROLE_REMOVE'] = "ROLEREMOVE";
    })(RoleEnum = GetNymRoleResponse.RoleEnum || (GetNymRoleResponse.RoleEnum = {}));
})(GetNymRoleResponse = exports.GetNymRoleResponse || (exports.GetNymRoleResponse = {}));
class HolderModuleResponse {
    static getAttributeTypeMap() {
        return HolderModuleResponse.attributeTypeMap;
    }
}
exports.HolderModuleResponse = HolderModuleResponse;
HolderModuleResponse.discriminator = undefined;
HolderModuleResponse.attributeTypeMap = [];
class IndyAttrValue {
    static getAttributeTypeMap() {
        return IndyAttrValue.attributeTypeMap;
    }
}
exports.IndyAttrValue = IndyAttrValue;
IndyAttrValue.discriminator = undefined;
IndyAttrValue.attributeTypeMap = [
    {
        "name": "encoded",
        "baseName": "encoded",
        "type": "string"
    },
    {
        "name": "raw",
        "baseName": "raw",
        "type": "string"
    }
];
class IndyCredAbstract {
    static getAttributeTypeMap() {
        return IndyCredAbstract.attributeTypeMap;
    }
}
exports.IndyCredAbstract = IndyCredAbstract;
IndyCredAbstract.discriminator = undefined;
IndyCredAbstract.attributeTypeMap = [
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "key_correctness_proof",
        "baseName": "key_correctness_proof",
        "type": "any"
    },
    {
        "name": "nonce",
        "baseName": "nonce",
        "type": "string"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    }
];
class IndyCredInfo {
    static getAttributeTypeMap() {
        return IndyCredInfo.attributeTypeMap;
    }
}
exports.IndyCredInfo = IndyCredInfo;
IndyCredInfo.discriminator = undefined;
IndyCredInfo.attributeTypeMap = [
    {
        "name": "attrs",
        "baseName": "attrs",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "cred_rev_id",
        "baseName": "cred_rev_id",
        "type": "string"
    },
    {
        "name": "referent",
        "baseName": "referent",
        "type": "string"
    },
    {
        "name": "rev_reg_id",
        "baseName": "rev_reg_id",
        "type": "string"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    }
];
class IndyCredPrecis {
    static getAttributeTypeMap() {
        return IndyCredPrecis.attributeTypeMap;
    }
}
exports.IndyCredPrecis = IndyCredPrecis;
IndyCredPrecis.discriminator = undefined;
IndyCredPrecis.attributeTypeMap = [
    {
        "name": "cred_info",
        "baseName": "cred_info",
        "type": "any"
    },
    {
        "name": "interval",
        "baseName": "interval",
        "type": "any"
    },
    {
        "name": "presentation_referents",
        "baseName": "presentation_referents",
        "type": "Array<string>"
    }
];
class IndyCredRequest {
    static getAttributeTypeMap() {
        return IndyCredRequest.attributeTypeMap;
    }
}
exports.IndyCredRequest = IndyCredRequest;
IndyCredRequest.discriminator = undefined;
IndyCredRequest.attributeTypeMap = [
    {
        "name": "blinded_ms",
        "baseName": "blinded_ms",
        "type": "any"
    },
    {
        "name": "blinded_ms_correctness_proof",
        "baseName": "blinded_ms_correctness_proof",
        "type": "any"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "nonce",
        "baseName": "nonce",
        "type": "string"
    },
    {
        "name": "prover_did",
        "baseName": "prover_did",
        "type": "string"
    }
];
class IndyCredential {
    static getAttributeTypeMap() {
        return IndyCredential.attributeTypeMap;
    }
}
exports.IndyCredential = IndyCredential;
IndyCredential.discriminator = undefined;
IndyCredential.attributeTypeMap = [
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "rev_reg",
        "baseName": "rev_reg",
        "type": "any"
    },
    {
        "name": "rev_reg_id",
        "baseName": "rev_reg_id",
        "type": "string"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    },
    {
        "name": "signature",
        "baseName": "signature",
        "type": "any"
    },
    {
        "name": "signature_correctness_proof",
        "baseName": "signature_correctness_proof",
        "type": "any"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "{ [key: string]: any; }"
    },
    {
        "name": "witness",
        "baseName": "witness",
        "type": "any"
    }
];
class IndyEQProof {
    static getAttributeTypeMap() {
        return IndyEQProof.attributeTypeMap;
    }
}
exports.IndyEQProof = IndyEQProof;
IndyEQProof.discriminator = undefined;
IndyEQProof.attributeTypeMap = [
    {
        "name": "a_prime",
        "baseName": "a_prime",
        "type": "string"
    },
    {
        "name": "e",
        "baseName": "e",
        "type": "string"
    },
    {
        "name": "m",
        "baseName": "m",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "m2",
        "baseName": "m2",
        "type": "string"
    },
    {
        "name": "revealed_attrs",
        "baseName": "revealed_attrs",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "v",
        "baseName": "v",
        "type": "string"
    }
];
class IndyGEProof {
    static getAttributeTypeMap() {
        return IndyGEProof.attributeTypeMap;
    }
}
exports.IndyGEProof = IndyGEProof;
IndyGEProof.discriminator = undefined;
IndyGEProof.attributeTypeMap = [
    {
        "name": "alpha",
        "baseName": "alpha",
        "type": "string"
    },
    {
        "name": "mj",
        "baseName": "mj",
        "type": "string"
    },
    {
        "name": "predicate",
        "baseName": "predicate",
        "type": "IndyGEProofPred"
    },
    {
        "name": "r",
        "baseName": "r",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "t",
        "baseName": "t",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "u",
        "baseName": "u",
        "type": "{ [key: string]: string; }"
    }
];
class IndyGEProofPred {
    static getAttributeTypeMap() {
        return IndyGEProofPred.attributeTypeMap;
    }
}
exports.IndyGEProofPred = IndyGEProofPred;
IndyGEProofPred.discriminator = undefined;
IndyGEProofPred.attributeTypeMap = [
    {
        "name": "attr_name",
        "baseName": "attr_name",
        "type": "string"
    },
    {
        "name": "p_type",
        "baseName": "p_type",
        "type": "IndyGEProofPred.PTypeEnum"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "number"
    }
];
(function (IndyGEProofPred) {
    let PTypeEnum;
    (function (PTypeEnum) {
        PTypeEnum[PTypeEnum["LT"] = 'LT'] = "LT";
        PTypeEnum[PTypeEnum["LE"] = 'LE'] = "LE";
        PTypeEnum[PTypeEnum["GE"] = 'GE'] = "GE";
        PTypeEnum[PTypeEnum["GT"] = 'GT'] = "GT";
    })(PTypeEnum = IndyGEProofPred.PTypeEnum || (IndyGEProofPred.PTypeEnum = {}));
})(IndyGEProofPred = exports.IndyGEProofPred || (exports.IndyGEProofPred = {}));
class IndyKeyCorrectnessProof {
    static getAttributeTypeMap() {
        return IndyKeyCorrectnessProof.attributeTypeMap;
    }
}
exports.IndyKeyCorrectnessProof = IndyKeyCorrectnessProof;
IndyKeyCorrectnessProof.discriminator = undefined;
IndyKeyCorrectnessProof.attributeTypeMap = [
    {
        "name": "c",
        "baseName": "c",
        "type": "string"
    },
    {
        "name": "xr_cap",
        "baseName": "xr_cap",
        "type": "Array<Array<string>>"
    },
    {
        "name": "xz_cap",
        "baseName": "xz_cap",
        "type": "string"
    }
];
class IndyNonRevocProof {
    static getAttributeTypeMap() {
        return IndyNonRevocProof.attributeTypeMap;
    }
}
exports.IndyNonRevocProof = IndyNonRevocProof;
IndyNonRevocProof.discriminator = undefined;
IndyNonRevocProof.attributeTypeMap = [
    {
        "name": "c_list",
        "baseName": "c_list",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "x_list",
        "baseName": "x_list",
        "type": "{ [key: string]: string; }"
    }
];
class IndyNonRevocationInterval {
    static getAttributeTypeMap() {
        return IndyNonRevocationInterval.attributeTypeMap;
    }
}
exports.IndyNonRevocationInterval = IndyNonRevocationInterval;
IndyNonRevocationInterval.discriminator = undefined;
IndyNonRevocationInterval.attributeTypeMap = [
    {
        "name": "from",
        "baseName": "from",
        "type": "number"
    },
    {
        "name": "to",
        "baseName": "to",
        "type": "number"
    }
];
class IndyPresAttrSpec {
    static getAttributeTypeMap() {
        return IndyPresAttrSpec.attributeTypeMap;
    }
}
exports.IndyPresAttrSpec = IndyPresAttrSpec;
IndyPresAttrSpec.discriminator = undefined;
IndyPresAttrSpec.attributeTypeMap = [
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "mime_type",
        "baseName": "mime-type",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "referent",
        "baseName": "referent",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    }
];
class IndyPresPredSpec {
    static getAttributeTypeMap() {
        return IndyPresPredSpec.attributeTypeMap;
    }
}
exports.IndyPresPredSpec = IndyPresPredSpec;
IndyPresPredSpec.discriminator = undefined;
IndyPresPredSpec.attributeTypeMap = [
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "predicate",
        "baseName": "predicate",
        "type": "IndyPresPredSpec.PredicateEnum"
    },
    {
        "name": "threshold",
        "baseName": "threshold",
        "type": "number"
    }
];
(function (IndyPresPredSpec) {
    let PredicateEnum;
    (function (PredicateEnum) {
        PredicateEnum[PredicateEnum["LessThan"] = '<'] = "LessThan";
        PredicateEnum[PredicateEnum["LessThanOrEqualTo"] = '<='] = "LessThanOrEqualTo";
        PredicateEnum[PredicateEnum["GreaterThanOrEqualTo"] = '>='] = "GreaterThanOrEqualTo";
        PredicateEnum[PredicateEnum["GreaterThan"] = '>'] = "GreaterThan";
    })(PredicateEnum = IndyPresPredSpec.PredicateEnum || (IndyPresPredSpec.PredicateEnum = {}));
})(IndyPresPredSpec = exports.IndyPresPredSpec || (exports.IndyPresPredSpec = {}));
class IndyPresPreview {
    static getAttributeTypeMap() {
        return IndyPresPreview.attributeTypeMap;
    }
}
exports.IndyPresPreview = IndyPresPreview;
IndyPresPreview.discriminator = undefined;
IndyPresPreview.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "attributes",
        "baseName": "attributes",
        "type": "Array<IndyPresAttrSpec>"
    },
    {
        "name": "predicates",
        "baseName": "predicates",
        "type": "Array<IndyPresPredSpec>"
    }
];
class IndyPresSpec {
    static getAttributeTypeMap() {
        return IndyPresSpec.attributeTypeMap;
    }
}
exports.IndyPresSpec = IndyPresSpec;
IndyPresSpec.discriminator = undefined;
IndyPresSpec.attributeTypeMap = [
    {
        "name": "requested_attributes",
        "baseName": "requested_attributes",
        "type": "{ [key: string]: IndyRequestedCredsRequestedAttr; }"
    },
    {
        "name": "requested_predicates",
        "baseName": "requested_predicates",
        "type": "{ [key: string]: IndyRequestedCredsRequestedPred; }"
    },
    {
        "name": "self_attested_attributes",
        "baseName": "self_attested_attributes",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class IndyPrimaryProof {
    static getAttributeTypeMap() {
        return IndyPrimaryProof.attributeTypeMap;
    }
}
exports.IndyPrimaryProof = IndyPrimaryProof;
IndyPrimaryProof.discriminator = undefined;
IndyPrimaryProof.attributeTypeMap = [
    {
        "name": "eq_proof",
        "baseName": "eq_proof",
        "type": "any"
    },
    {
        "name": "ge_proofs",
        "baseName": "ge_proofs",
        "type": "Array<IndyGEProof>"
    }
];
class IndyProof {
    static getAttributeTypeMap() {
        return IndyProof.attributeTypeMap;
    }
}
exports.IndyProof = IndyProof;
IndyProof.discriminator = undefined;
IndyProof.attributeTypeMap = [
    {
        "name": "identifiers",
        "baseName": "identifiers",
        "type": "Array<IndyProofIdentifier>"
    },
    {
        "name": "proof",
        "baseName": "proof",
        "type": "any"
    },
    {
        "name": "requested_proof",
        "baseName": "requested_proof",
        "type": "any"
    }
];
class IndyProofIdentifier {
    static getAttributeTypeMap() {
        return IndyProofIdentifier.attributeTypeMap;
    }
}
exports.IndyProofIdentifier = IndyProofIdentifier;
IndyProofIdentifier.discriminator = undefined;
IndyProofIdentifier.attributeTypeMap = [
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "rev_reg_id",
        "baseName": "rev_reg_id",
        "type": "string"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    },
    {
        "name": "timestamp",
        "baseName": "timestamp",
        "type": "number"
    }
];
class IndyProofProof {
    static getAttributeTypeMap() {
        return IndyProofProof.attributeTypeMap;
    }
}
exports.IndyProofProof = IndyProofProof;
IndyProofProof.discriminator = undefined;
IndyProofProof.attributeTypeMap = [
    {
        "name": "aggregated_proof",
        "baseName": "aggregated_proof",
        "type": "any"
    },
    {
        "name": "proofs",
        "baseName": "proofs",
        "type": "Array<IndyProofProofProofsProof>"
    }
];
class IndyProofProofAggregatedProof {
    static getAttributeTypeMap() {
        return IndyProofProofAggregatedProof.attributeTypeMap;
    }
}
exports.IndyProofProofAggregatedProof = IndyProofProofAggregatedProof;
IndyProofProofAggregatedProof.discriminator = undefined;
IndyProofProofAggregatedProof.attributeTypeMap = [
    {
        "name": "c_hash",
        "baseName": "c_hash",
        "type": "string"
    },
    {
        "name": "c_list",
        "baseName": "c_list",
        "type": "Array<Array<number>>"
    }
];
class IndyProofProofProofsProof {
    static getAttributeTypeMap() {
        return IndyProofProofProofsProof.attributeTypeMap;
    }
}
exports.IndyProofProofProofsProof = IndyProofProofProofsProof;
IndyProofProofProofsProof.discriminator = undefined;
IndyProofProofProofsProof.attributeTypeMap = [
    {
        "name": "non_revoc_proof",
        "baseName": "non_revoc_proof",
        "type": "any"
    },
    {
        "name": "primary_proof",
        "baseName": "primary_proof",
        "type": "any"
    }
];
class IndyProofReqAttrSpec {
    static getAttributeTypeMap() {
        return IndyProofReqAttrSpec.attributeTypeMap;
    }
}
exports.IndyProofReqAttrSpec = IndyProofReqAttrSpec;
IndyProofReqAttrSpec.discriminator = undefined;
IndyProofReqAttrSpec.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "names",
        "baseName": "names",
        "type": "Array<string>"
    },
    {
        "name": "non_revoked",
        "baseName": "non_revoked",
        "type": "any"
    },
    {
        "name": "restrictions",
        "baseName": "restrictions",
        "type": "Array<{ [key: string]: string; }>"
    }
];
class IndyProofReqAttrSpecNonRevoked {
    static getAttributeTypeMap() {
        return IndyProofReqAttrSpecNonRevoked.attributeTypeMap;
    }
}
exports.IndyProofReqAttrSpecNonRevoked = IndyProofReqAttrSpecNonRevoked;
IndyProofReqAttrSpecNonRevoked.discriminator = undefined;
IndyProofReqAttrSpecNonRevoked.attributeTypeMap = [
    {
        "name": "from",
        "baseName": "from",
        "type": "number"
    },
    {
        "name": "to",
        "baseName": "to",
        "type": "number"
    }
];
class IndyProofReqPredSpec {
    static getAttributeTypeMap() {
        return IndyProofReqPredSpec.attributeTypeMap;
    }
}
exports.IndyProofReqPredSpec = IndyProofReqPredSpec;
IndyProofReqPredSpec.discriminator = undefined;
IndyProofReqPredSpec.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "non_revoked",
        "baseName": "non_revoked",
        "type": "any"
    },
    {
        "name": "p_type",
        "baseName": "p_type",
        "type": "IndyProofReqPredSpec.PTypeEnum"
    },
    {
        "name": "p_value",
        "baseName": "p_value",
        "type": "number"
    },
    {
        "name": "restrictions",
        "baseName": "restrictions",
        "type": "Array<{ [key: string]: string; }>"
    }
];
(function (IndyProofReqPredSpec) {
    let PTypeEnum;
    (function (PTypeEnum) {
        PTypeEnum[PTypeEnum["LessThan"] = '<'] = "LessThan";
        PTypeEnum[PTypeEnum["LessThanOrEqualTo"] = '<='] = "LessThanOrEqualTo";
        PTypeEnum[PTypeEnum["GreaterThanOrEqualTo"] = '>='] = "GreaterThanOrEqualTo";
        PTypeEnum[PTypeEnum["GreaterThan"] = '>'] = "GreaterThan";
    })(PTypeEnum = IndyProofReqPredSpec.PTypeEnum || (IndyProofReqPredSpec.PTypeEnum = {}));
})(IndyProofReqPredSpec = exports.IndyProofReqPredSpec || (exports.IndyProofReqPredSpec = {}));
class IndyProofReqPredSpecNonRevoked {
    static getAttributeTypeMap() {
        return IndyProofReqPredSpecNonRevoked.attributeTypeMap;
    }
}
exports.IndyProofReqPredSpecNonRevoked = IndyProofReqPredSpecNonRevoked;
IndyProofReqPredSpecNonRevoked.discriminator = undefined;
IndyProofReqPredSpecNonRevoked.attributeTypeMap = [
    {
        "name": "from",
        "baseName": "from",
        "type": "number"
    },
    {
        "name": "to",
        "baseName": "to",
        "type": "number"
    }
];
class IndyProofRequest {
    static getAttributeTypeMap() {
        return IndyProofRequest.attributeTypeMap;
    }
}
exports.IndyProofRequest = IndyProofRequest;
IndyProofRequest.discriminator = undefined;
IndyProofRequest.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "non_revoked",
        "baseName": "non_revoked",
        "type": "any"
    },
    {
        "name": "nonce",
        "baseName": "nonce",
        "type": "string"
    },
    {
        "name": "requested_attributes",
        "baseName": "requested_attributes",
        "type": "{ [key: string]: IndyProofReqAttrSpec; }"
    },
    {
        "name": "requested_predicates",
        "baseName": "requested_predicates",
        "type": "{ [key: string]: IndyProofReqPredSpec; }"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];
class IndyProofRequestNonRevoked {
    static getAttributeTypeMap() {
        return IndyProofRequestNonRevoked.attributeTypeMap;
    }
}
exports.IndyProofRequestNonRevoked = IndyProofRequestNonRevoked;
IndyProofRequestNonRevoked.discriminator = undefined;
IndyProofRequestNonRevoked.attributeTypeMap = [
    {
        "name": "from",
        "baseName": "from",
        "type": "number"
    },
    {
        "name": "to",
        "baseName": "to",
        "type": "number"
    }
];
class IndyProofRequestedProof {
    static getAttributeTypeMap() {
        return IndyProofRequestedProof.attributeTypeMap;
    }
}
exports.IndyProofRequestedProof = IndyProofRequestedProof;
IndyProofRequestedProof.discriminator = undefined;
IndyProofRequestedProof.attributeTypeMap = [
    {
        "name": "predicates",
        "baseName": "predicates",
        "type": "{ [key: string]: IndyProofRequestedProofPredicate; }"
    },
    {
        "name": "revealed_attr_groups",
        "baseName": "revealed_attr_groups",
        "type": "{ [key: string]: IndyProofRequestedProofRevealedAttrGroup; }"
    },
    {
        "name": "revealed_attrs",
        "baseName": "revealed_attrs",
        "type": "{ [key: string]: IndyProofRequestedProofRevealedAttr; }"
    },
    {
        "name": "self_attested_attrs",
        "baseName": "self_attested_attrs",
        "type": "any"
    },
    {
        "name": "unrevealed_attrs",
        "baseName": "unrevealed_attrs",
        "type": "any"
    }
];
class IndyProofRequestedProofPredicate {
    static getAttributeTypeMap() {
        return IndyProofRequestedProofPredicate.attributeTypeMap;
    }
}
exports.IndyProofRequestedProofPredicate = IndyProofRequestedProofPredicate;
IndyProofRequestedProofPredicate.discriminator = undefined;
IndyProofRequestedProofPredicate.attributeTypeMap = [
    {
        "name": "sub_proof_index",
        "baseName": "sub_proof_index",
        "type": "number"
    }
];
class IndyProofRequestedProofRevealedAttr {
    static getAttributeTypeMap() {
        return IndyProofRequestedProofRevealedAttr.attributeTypeMap;
    }
}
exports.IndyProofRequestedProofRevealedAttr = IndyProofRequestedProofRevealedAttr;
IndyProofRequestedProofRevealedAttr.discriminator = undefined;
IndyProofRequestedProofRevealedAttr.attributeTypeMap = [
    {
        "name": "encoded",
        "baseName": "encoded",
        "type": "string"
    },
    {
        "name": "raw",
        "baseName": "raw",
        "type": "string"
    },
    {
        "name": "sub_proof_index",
        "baseName": "sub_proof_index",
        "type": "number"
    }
];
class IndyProofRequestedProofRevealedAttrGroup {
    static getAttributeTypeMap() {
        return IndyProofRequestedProofRevealedAttrGroup.attributeTypeMap;
    }
}
exports.IndyProofRequestedProofRevealedAttrGroup = IndyProofRequestedProofRevealedAttrGroup;
IndyProofRequestedProofRevealedAttrGroup.discriminator = undefined;
IndyProofRequestedProofRevealedAttrGroup.attributeTypeMap = [
    {
        "name": "sub_proof_index",
        "baseName": "sub_proof_index",
        "type": "number"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "{ [key: string]: RawEncoded; }"
    }
];
class IndyRequestedCredsRequestedAttr {
    static getAttributeTypeMap() {
        return IndyRequestedCredsRequestedAttr.attributeTypeMap;
    }
}
exports.IndyRequestedCredsRequestedAttr = IndyRequestedCredsRequestedAttr;
IndyRequestedCredsRequestedAttr.discriminator = undefined;
IndyRequestedCredsRequestedAttr.attributeTypeMap = [
    {
        "name": "cred_id",
        "baseName": "cred_id",
        "type": "string"
    },
    {
        "name": "revealed",
        "baseName": "revealed",
        "type": "boolean"
    }
];
class IndyRequestedCredsRequestedPred {
    static getAttributeTypeMap() {
        return IndyRequestedCredsRequestedPred.attributeTypeMap;
    }
}
exports.IndyRequestedCredsRequestedPred = IndyRequestedCredsRequestedPred;
IndyRequestedCredsRequestedPred.discriminator = undefined;
IndyRequestedCredsRequestedPred.attributeTypeMap = [
    {
        "name": "cred_id",
        "baseName": "cred_id",
        "type": "string"
    },
    {
        "name": "timestamp",
        "baseName": "timestamp",
        "type": "number"
    }
];
class IndyRevRegDef {
    static getAttributeTypeMap() {
        return IndyRevRegDef.attributeTypeMap;
    }
}
exports.IndyRevRegDef = IndyRevRegDef;
IndyRevRegDef.discriminator = undefined;
IndyRevRegDef.attributeTypeMap = [
    {
        "name": "credDefId",
        "baseName": "credDefId",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "revocDefType",
        "baseName": "revocDefType",
        "type": "IndyRevRegDef.RevocDefTypeEnum"
    },
    {
        "name": "tag",
        "baseName": "tag",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "any"
    },
    {
        "name": "ver",
        "baseName": "ver",
        "type": "string"
    }
];
(function (IndyRevRegDef) {
    let RevocDefTypeEnum;
    (function (RevocDefTypeEnum) {
        RevocDefTypeEnum[RevocDefTypeEnum["CLACCUM"] = 'CL_ACCUM'] = "CLACCUM";
    })(RevocDefTypeEnum = IndyRevRegDef.RevocDefTypeEnum || (IndyRevRegDef.RevocDefTypeEnum = {}));
})(IndyRevRegDef = exports.IndyRevRegDef || (exports.IndyRevRegDef = {}));
class IndyRevRegDefValue {
    static getAttributeTypeMap() {
        return IndyRevRegDefValue.attributeTypeMap;
    }
}
exports.IndyRevRegDefValue = IndyRevRegDefValue;
IndyRevRegDefValue.discriminator = undefined;
IndyRevRegDefValue.attributeTypeMap = [
    {
        "name": "issuanceType",
        "baseName": "issuanceType",
        "type": "IndyRevRegDefValue.IssuanceTypeEnum"
    },
    {
        "name": "maxCredNum",
        "baseName": "maxCredNum",
        "type": "number"
    },
    {
        "name": "publicKeys",
        "baseName": "publicKeys",
        "type": "any"
    },
    {
        "name": "tailsHash",
        "baseName": "tailsHash",
        "type": "string"
    },
    {
        "name": "tailsLocation",
        "baseName": "tailsLocation",
        "type": "string"
    }
];
(function (IndyRevRegDefValue) {
    let IssuanceTypeEnum;
    (function (IssuanceTypeEnum) {
        IssuanceTypeEnum[IssuanceTypeEnum["ONDEMAND"] = 'ISSUANCE_ON_DEMAND'] = "ONDEMAND";
        IssuanceTypeEnum[IssuanceTypeEnum["BYDEFAULT"] = 'ISSUANCE_BY_DEFAULT'] = "BYDEFAULT";
    })(IssuanceTypeEnum = IndyRevRegDefValue.IssuanceTypeEnum || (IndyRevRegDefValue.IssuanceTypeEnum = {}));
})(IndyRevRegDefValue = exports.IndyRevRegDefValue || (exports.IndyRevRegDefValue = {}));
class IndyRevRegDefValuePublicKeys {
    static getAttributeTypeMap() {
        return IndyRevRegDefValuePublicKeys.attributeTypeMap;
    }
}
exports.IndyRevRegDefValuePublicKeys = IndyRevRegDefValuePublicKeys;
IndyRevRegDefValuePublicKeys.discriminator = undefined;
IndyRevRegDefValuePublicKeys.attributeTypeMap = [
    {
        "name": "accumKey",
        "baseName": "accumKey",
        "type": "IndyRevRegDefValuePublicKeysAccumKey"
    }
];
class IndyRevRegDefValuePublicKeysAccumKey {
    static getAttributeTypeMap() {
        return IndyRevRegDefValuePublicKeysAccumKey.attributeTypeMap;
    }
}
exports.IndyRevRegDefValuePublicKeysAccumKey = IndyRevRegDefValuePublicKeysAccumKey;
IndyRevRegDefValuePublicKeysAccumKey.discriminator = undefined;
IndyRevRegDefValuePublicKeysAccumKey.attributeTypeMap = [
    {
        "name": "z",
        "baseName": "z",
        "type": "string"
    }
];
class IndyRevRegEntry {
    static getAttributeTypeMap() {
        return IndyRevRegEntry.attributeTypeMap;
    }
}
exports.IndyRevRegEntry = IndyRevRegEntry;
IndyRevRegEntry.discriminator = undefined;
IndyRevRegEntry.attributeTypeMap = [
    {
        "name": "value",
        "baseName": "value",
        "type": "any"
    },
    {
        "name": "ver",
        "baseName": "ver",
        "type": "string"
    }
];
class IndyRevRegEntryValue {
    static getAttributeTypeMap() {
        return IndyRevRegEntryValue.attributeTypeMap;
    }
}
exports.IndyRevRegEntryValue = IndyRevRegEntryValue;
IndyRevRegEntryValue.discriminator = undefined;
IndyRevRegEntryValue.attributeTypeMap = [
    {
        "name": "accum",
        "baseName": "accum",
        "type": "string"
    },
    {
        "name": "prevAccum",
        "baseName": "prevAccum",
        "type": "string"
    },
    {
        "name": "revoked",
        "baseName": "revoked",
        "type": "Array<number>"
    }
];
class InputDescriptors {
    static getAttributeTypeMap() {
        return InputDescriptors.attributeTypeMap;
    }
}
exports.InputDescriptors = InputDescriptors;
InputDescriptors.discriminator = undefined;
InputDescriptors.attributeTypeMap = [
    {
        "name": "constraints",
        "baseName": "constraints",
        "type": "Constraints"
    },
    {
        "name": "group",
        "baseName": "group",
        "type": "Array<string>"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "metadata",
        "baseName": "metadata",
        "type": "any"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "purpose",
        "baseName": "purpose",
        "type": "string"
    },
    {
        "name": "schema",
        "baseName": "schema",
        "type": "any"
    }
];
class IntroModuleResponse {
    static getAttributeTypeMap() {
        return IntroModuleResponse.attributeTypeMap;
    }
}
exports.IntroModuleResponse = IntroModuleResponse;
IntroModuleResponse.discriminator = undefined;
IntroModuleResponse.attributeTypeMap = [];
class InvitationCreateRequest {
    static getAttributeTypeMap() {
        return InvitationCreateRequest.attributeTypeMap;
    }
}
exports.InvitationCreateRequest = InvitationCreateRequest;
InvitationCreateRequest.discriminator = undefined;
InvitationCreateRequest.attributeTypeMap = [
    {
        "name": "alias",
        "baseName": "alias",
        "type": "string"
    },
    {
        "name": "attachments",
        "baseName": "attachments",
        "type": "Array<AttachmentDef>"
    },
    {
        "name": "handshake_protocols",
        "baseName": "handshake_protocols",
        "type": "Array<string>"
    },
    {
        "name": "mediation_id",
        "baseName": "mediation_id",
        "type": "string"
    },
    {
        "name": "metadata",
        "baseName": "metadata",
        "type": "any"
    },
    {
        "name": "my_label",
        "baseName": "my_label",
        "type": "string"
    },
    {
        "name": "use_public_did",
        "baseName": "use_public_did",
        "type": "boolean"
    }
];
class InvitationMessage {
    static getAttributeTypeMap() {
        return InvitationMessage.attributeTypeMap;
    }
}
exports.InvitationMessage = InvitationMessage;
InvitationMessage.discriminator = undefined;
InvitationMessage.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "handshake_protocols",
        "baseName": "handshake_protocols",
        "type": "Array<string>"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "requestsattach",
        "baseName": "requests~attach",
        "type": "Array<AttachDecorator>"
    },
    {
        "name": "services",
        "baseName": "services",
        "type": "Array<any>"
    }
];
class InvitationRecord {
    static getAttributeTypeMap() {
        return InvitationRecord.attributeTypeMap;
    }
}
exports.InvitationRecord = InvitationRecord;
InvitationRecord.discriminator = undefined;
InvitationRecord.attributeTypeMap = [
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "invi_msg_id",
        "baseName": "invi_msg_id",
        "type": "string"
    },
    {
        "name": "invitation",
        "baseName": "invitation",
        "type": "any"
    },
    {
        "name": "invitation_id",
        "baseName": "invitation_id",
        "type": "string"
    },
    {
        "name": "invitation_url",
        "baseName": "invitation_url",
        "type": "string"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
class InvitationResult {
    static getAttributeTypeMap() {
        return InvitationResult.attributeTypeMap;
    }
}
exports.InvitationResult = InvitationResult;
InvitationResult.discriminator = undefined;
InvitationResult.attributeTypeMap = [
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "invitation",
        "baseName": "invitation",
        "type": "ConnectionInvitation"
    },
    {
        "name": "invitation_url",
        "baseName": "invitation_url",
        "type": "string"
    }
];
class IssueCredentialModuleResponse {
    static getAttributeTypeMap() {
        return IssueCredentialModuleResponse.attributeTypeMap;
    }
}
exports.IssueCredentialModuleResponse = IssueCredentialModuleResponse;
IssueCredentialModuleResponse.discriminator = undefined;
IssueCredentialModuleResponse.attributeTypeMap = [];
class IssuerCredRevRecord {
    static getAttributeTypeMap() {
        return IssuerCredRevRecord.attributeTypeMap;
    }
}
exports.IssuerCredRevRecord = IssuerCredRevRecord;
IssuerCredRevRecord.discriminator = undefined;
IssuerCredRevRecord.attributeTypeMap = [
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "cred_ex_id",
        "baseName": "cred_ex_id",
        "type": "string"
    },
    {
        "name": "cred_rev_id",
        "baseName": "cred_rev_id",
        "type": "string"
    },
    {
        "name": "record_id",
        "baseName": "record_id",
        "type": "string"
    },
    {
        "name": "rev_reg_id",
        "baseName": "rev_reg_id",
        "type": "string"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
class IssuerRevRegRecord {
    static getAttributeTypeMap() {
        return IssuerRevRegRecord.attributeTypeMap;
    }
}
exports.IssuerRevRegRecord = IssuerRevRegRecord;
IssuerRevRegRecord.discriminator = undefined;
IssuerRevRegRecord.attributeTypeMap = [
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "error_msg",
        "baseName": "error_msg",
        "type": "string"
    },
    {
        "name": "issuer_did",
        "baseName": "issuer_did",
        "type": "string"
    },
    {
        "name": "max_cred_num",
        "baseName": "max_cred_num",
        "type": "number"
    },
    {
        "name": "pending_pub",
        "baseName": "pending_pub",
        "type": "Array<string>"
    },
    {
        "name": "record_id",
        "baseName": "record_id",
        "type": "string"
    },
    {
        "name": "revoc_def_type",
        "baseName": "revoc_def_type",
        "type": "IssuerRevRegRecord.RevocDefTypeEnum"
    },
    {
        "name": "revoc_reg_def",
        "baseName": "revoc_reg_def",
        "type": "any"
    },
    {
        "name": "revoc_reg_entry",
        "baseName": "revoc_reg_entry",
        "type": "any"
    },
    {
        "name": "revoc_reg_id",
        "baseName": "revoc_reg_id",
        "type": "string"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "tag",
        "baseName": "tag",
        "type": "string"
    },
    {
        "name": "tails_hash",
        "baseName": "tails_hash",
        "type": "string"
    },
    {
        "name": "tails_local_path",
        "baseName": "tails_local_path",
        "type": "string"
    },
    {
        "name": "tails_public_uri",
        "baseName": "tails_public_uri",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
(function (IssuerRevRegRecord) {
    let RevocDefTypeEnum;
    (function (RevocDefTypeEnum) {
        RevocDefTypeEnum[RevocDefTypeEnum["CLACCUM"] = 'CL_ACCUM'] = "CLACCUM";
    })(RevocDefTypeEnum = IssuerRevRegRecord.RevocDefTypeEnum || (IssuerRevRegRecord.RevocDefTypeEnum = {}));
})(IssuerRevRegRecord = exports.IssuerRevRegRecord || (exports.IssuerRevRegRecord = {}));
class Keylist {
    static getAttributeTypeMap() {
        return Keylist.attributeTypeMap;
    }
}
exports.Keylist = Keylist;
Keylist.discriminator = undefined;
Keylist.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<RouteRecord>"
    }
];
class KeylistQuery {
    static getAttributeTypeMap() {
        return KeylistQuery.attributeTypeMap;
    }
}
exports.KeylistQuery = KeylistQuery;
KeylistQuery.discriminator = undefined;
KeylistQuery.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "filter",
        "baseName": "filter",
        "type": "any"
    },
    {
        "name": "paginate",
        "baseName": "paginate",
        "type": "any"
    }
];
class KeylistQueryFilterRequest {
    static getAttributeTypeMap() {
        return KeylistQueryFilterRequest.attributeTypeMap;
    }
}
exports.KeylistQueryFilterRequest = KeylistQueryFilterRequest;
KeylistQueryFilterRequest.discriminator = undefined;
KeylistQueryFilterRequest.attributeTypeMap = [
    {
        "name": "filter",
        "baseName": "filter",
        "type": "any"
    }
];
class KeylistQueryPaginate {
    static getAttributeTypeMap() {
        return KeylistQueryPaginate.attributeTypeMap;
    }
}
exports.KeylistQueryPaginate = KeylistQueryPaginate;
KeylistQueryPaginate.discriminator = undefined;
KeylistQueryPaginate.attributeTypeMap = [
    {
        "name": "limit",
        "baseName": "limit",
        "type": "number"
    },
    {
        "name": "offset",
        "baseName": "offset",
        "type": "number"
    }
];
class KeylistUpdate {
    static getAttributeTypeMap() {
        return KeylistUpdate.attributeTypeMap;
    }
}
exports.KeylistUpdate = KeylistUpdate;
KeylistUpdate.discriminator = undefined;
KeylistUpdate.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "updates",
        "baseName": "updates",
        "type": "Array<KeylistUpdateRule>"
    }
];
class KeylistUpdateRequest {
    static getAttributeTypeMap() {
        return KeylistUpdateRequest.attributeTypeMap;
    }
}
exports.KeylistUpdateRequest = KeylistUpdateRequest;
KeylistUpdateRequest.discriminator = undefined;
KeylistUpdateRequest.attributeTypeMap = [
    {
        "name": "updates",
        "baseName": "updates",
        "type": "Array<KeylistUpdateRule>"
    }
];
class KeylistUpdateRule {
    static getAttributeTypeMap() {
        return KeylistUpdateRule.attributeTypeMap;
    }
}
exports.KeylistUpdateRule = KeylistUpdateRule;
KeylistUpdateRule.discriminator = undefined;
KeylistUpdateRule.attributeTypeMap = [
    {
        "name": "action",
        "baseName": "action",
        "type": "KeylistUpdateRule.ActionEnum"
    },
    {
        "name": "recipient_key",
        "baseName": "recipient_key",
        "type": "string"
    }
];
(function (KeylistUpdateRule) {
    let ActionEnum;
    (function (ActionEnum) {
        ActionEnum[ActionEnum["Add"] = 'add'] = "Add";
        ActionEnum[ActionEnum["Remove"] = 'remove'] = "Remove";
    })(ActionEnum = KeylistUpdateRule.ActionEnum || (KeylistUpdateRule.ActionEnum = {}));
})(KeylistUpdateRule = exports.KeylistUpdateRule || (exports.KeylistUpdateRule = {}));
class LDProofVCDetail {
    static getAttributeTypeMap() {
        return LDProofVCDetail.attributeTypeMap;
    }
}
exports.LDProofVCDetail = LDProofVCDetail;
LDProofVCDetail.discriminator = undefined;
LDProofVCDetail.attributeTypeMap = [
    {
        "name": "credential",
        "baseName": "credential",
        "type": "any"
    },
    {
        "name": "options",
        "baseName": "options",
        "type": "any"
    }
];
class LDProofVCDetailOptions {
    static getAttributeTypeMap() {
        return LDProofVCDetailOptions.attributeTypeMap;
    }
}
exports.LDProofVCDetailOptions = LDProofVCDetailOptions;
LDProofVCDetailOptions.discriminator = undefined;
LDProofVCDetailOptions.attributeTypeMap = [
    {
        "name": "challenge",
        "baseName": "challenge",
        "type": "string"
    },
    {
        "name": "created",
        "baseName": "created",
        "type": "string"
    },
    {
        "name": "credentialStatus",
        "baseName": "credentialStatus",
        "type": "any"
    },
    {
        "name": "domain",
        "baseName": "domain",
        "type": "string"
    },
    {
        "name": "proofPurpose",
        "baseName": "proofPurpose",
        "type": "string"
    },
    {
        "name": "proofType",
        "baseName": "proofType",
        "type": "string"
    }
];
class LedgerConfigInstance {
    static getAttributeTypeMap() {
        return LedgerConfigInstance.attributeTypeMap;
    }
}
exports.LedgerConfigInstance = LedgerConfigInstance;
LedgerConfigInstance.discriminator = undefined;
LedgerConfigInstance.attributeTypeMap = [
    {
        "name": "genesis_file",
        "baseName": "genesis_file",
        "type": "string"
    },
    {
        "name": "genesis_transactions",
        "baseName": "genesis_transactions",
        "type": "string"
    },
    {
        "name": "genesis_url",
        "baseName": "genesis_url",
        "type": "string"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "is_production",
        "baseName": "is_production",
        "type": "boolean"
    }
];
class LedgerConfigList {
    static getAttributeTypeMap() {
        return LedgerConfigList.attributeTypeMap;
    }
}
exports.LedgerConfigList = LedgerConfigList;
LedgerConfigList.discriminator = undefined;
LedgerConfigList.attributeTypeMap = [
    {
        "name": "ledger_config_list",
        "baseName": "ledger_config_list",
        "type": "Array<LedgerConfigInstance>"
    }
];
class LedgerModulesResult {
    static getAttributeTypeMap() {
        return LedgerModulesResult.attributeTypeMap;
    }
}
exports.LedgerModulesResult = LedgerModulesResult;
LedgerModulesResult.discriminator = undefined;
LedgerModulesResult.attributeTypeMap = [];
class LinkedDataProof {
    static getAttributeTypeMap() {
        return LinkedDataProof.attributeTypeMap;
    }
}
exports.LinkedDataProof = LinkedDataProof;
LinkedDataProof.discriminator = undefined;
LinkedDataProof.attributeTypeMap = [
    {
        "name": "challenge",
        "baseName": "challenge",
        "type": "string"
    },
    {
        "name": "created",
        "baseName": "created",
        "type": "string"
    },
    {
        "name": "domain",
        "baseName": "domain",
        "type": "string"
    },
    {
        "name": "jws",
        "baseName": "jws",
        "type": "string"
    },
    {
        "name": "nonce",
        "baseName": "nonce",
        "type": "string"
    },
    {
        "name": "proofPurpose",
        "baseName": "proofPurpose",
        "type": "string"
    },
    {
        "name": "proofValue",
        "baseName": "proofValue",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    },
    {
        "name": "verificationMethod",
        "baseName": "verificationMethod",
        "type": "string"
    }
];
class MediationCreateRequest {
    static getAttributeTypeMap() {
        return MediationCreateRequest.attributeTypeMap;
    }
}
exports.MediationCreateRequest = MediationCreateRequest;
MediationCreateRequest.discriminator = undefined;
MediationCreateRequest.attributeTypeMap = [
    {
        "name": "mediator_terms",
        "baseName": "mediator_terms",
        "type": "Array<string>"
    },
    {
        "name": "recipient_terms",
        "baseName": "recipient_terms",
        "type": "Array<string>"
    }
];
class MediationDeny {
    static getAttributeTypeMap() {
        return MediationDeny.attributeTypeMap;
    }
}
exports.MediationDeny = MediationDeny;
MediationDeny.discriminator = undefined;
MediationDeny.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "mediator_terms",
        "baseName": "mediator_terms",
        "type": "Array<string>"
    },
    {
        "name": "recipient_terms",
        "baseName": "recipient_terms",
        "type": "Array<string>"
    }
];
class MediationGrant {
    static getAttributeTypeMap() {
        return MediationGrant.attributeTypeMap;
    }
}
exports.MediationGrant = MediationGrant;
MediationGrant.discriminator = undefined;
MediationGrant.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "endpoint",
        "baseName": "endpoint",
        "type": "string"
    },
    {
        "name": "routing_keys",
        "baseName": "routing_keys",
        "type": "Array<string>"
    }
];
class MediationList {
    static getAttributeTypeMap() {
        return MediationList.attributeTypeMap;
    }
}
exports.MediationList = MediationList;
MediationList.discriminator = undefined;
MediationList.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<MediationRecord>"
    }
];
class MediationRecord {
    static getAttributeTypeMap() {
        return MediationRecord.attributeTypeMap;
    }
}
exports.MediationRecord = MediationRecord;
MediationRecord.discriminator = undefined;
MediationRecord.attributeTypeMap = [
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "endpoint",
        "baseName": "endpoint",
        "type": "string"
    },
    {
        "name": "mediation_id",
        "baseName": "mediation_id",
        "type": "string"
    },
    {
        "name": "mediator_terms",
        "baseName": "mediator_terms",
        "type": "Array<string>"
    },
    {
        "name": "recipient_terms",
        "baseName": "recipient_terms",
        "type": "Array<string>"
    },
    {
        "name": "role",
        "baseName": "role",
        "type": "string"
    },
    {
        "name": "routing_keys",
        "baseName": "routing_keys",
        "type": "Array<string>"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
class Menu {
    static getAttributeTypeMap() {
        return Menu.attributeTypeMap;
    }
}
exports.Menu = Menu;
Menu.discriminator = undefined;
Menu.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "errormsg",
        "baseName": "errormsg",
        "type": "string"
    },
    {
        "name": "options",
        "baseName": "options",
        "type": "Array<MenuOption>"
    },
    {
        "name": "title",
        "baseName": "title",
        "type": "string"
    }
];
class MenuForm {
    static getAttributeTypeMap() {
        return MenuForm.attributeTypeMap;
    }
}
exports.MenuForm = MenuForm;
MenuForm.discriminator = undefined;
MenuForm.attributeTypeMap = [
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "params",
        "baseName": "params",
        "type": "Array<MenuFormParam>"
    },
    {
        "name": "submit_label",
        "baseName": "submit-label",
        "type": "string"
    },
    {
        "name": "title",
        "baseName": "title",
        "type": "string"
    }
];
class MenuFormParam {
    static getAttributeTypeMap() {
        return MenuFormParam.attributeTypeMap;
    }
}
exports.MenuFormParam = MenuFormParam;
MenuFormParam.discriminator = undefined;
MenuFormParam.attributeTypeMap = [
    {
        "name": "_default",
        "baseName": "default",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "required",
        "baseName": "required",
        "type": "boolean"
    },
    {
        "name": "title",
        "baseName": "title",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    }
];
class MenuJson {
    static getAttributeTypeMap() {
        return MenuJson.attributeTypeMap;
    }
}
exports.MenuJson = MenuJson;
MenuJson.discriminator = undefined;
MenuJson.attributeTypeMap = [
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "errormsg",
        "baseName": "errormsg",
        "type": "string"
    },
    {
        "name": "options",
        "baseName": "options",
        "type": "Array<MenuOption>"
    },
    {
        "name": "title",
        "baseName": "title",
        "type": "string"
    }
];
class MenuOption {
    static getAttributeTypeMap() {
        return MenuOption.attributeTypeMap;
    }
}
exports.MenuOption = MenuOption;
MenuOption.discriminator = undefined;
MenuOption.attributeTypeMap = [
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "disabled",
        "baseName": "disabled",
        "type": "boolean"
    },
    {
        "name": "form",
        "baseName": "form",
        "type": "MenuForm"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "title",
        "baseName": "title",
        "type": "string"
    }
];
class ModelDate {
    static getAttributeTypeMap() {
        return ModelDate.attributeTypeMap;
    }
}
exports.ModelDate = ModelDate;
ModelDate.discriminator = undefined;
ModelDate.attributeTypeMap = [
    {
        "name": "expires_time",
        "baseName": "expires_time",
        "type": "Date"
    }
];
class MultitenantModuleResponse {
    static getAttributeTypeMap() {
        return MultitenantModuleResponse.attributeTypeMap;
    }
}
exports.MultitenantModuleResponse = MultitenantModuleResponse;
MultitenantModuleResponse.discriminator = undefined;
MultitenantModuleResponse.attributeTypeMap = [];
class PerformRequest {
    static getAttributeTypeMap() {
        return PerformRequest.attributeTypeMap;
    }
}
exports.PerformRequest = PerformRequest;
PerformRequest.discriminator = undefined;
PerformRequest.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "params",
        "baseName": "params",
        "type": "{ [key: string]: string; }"
    }
];
class PingRequest {
    static getAttributeTypeMap() {
        return PingRequest.attributeTypeMap;
    }
}
exports.PingRequest = PingRequest;
PingRequest.discriminator = undefined;
PingRequest.attributeTypeMap = [
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    }
];
class PingRequestResponse {
    static getAttributeTypeMap() {
        return PingRequestResponse.attributeTypeMap;
    }
}
exports.PingRequestResponse = PingRequestResponse;
PingRequestResponse.discriminator = undefined;
PingRequestResponse.attributeTypeMap = [
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    }
];
class PresentationDefinition {
    static getAttributeTypeMap() {
        return PresentationDefinition.attributeTypeMap;
    }
}
exports.PresentationDefinition = PresentationDefinition;
PresentationDefinition.discriminator = undefined;
PresentationDefinition.attributeTypeMap = [
    {
        "name": "format",
        "baseName": "format",
        "type": "ClaimFormat"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "input_descriptors",
        "baseName": "input_descriptors",
        "type": "Array<InputDescriptors>"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "purpose",
        "baseName": "purpose",
        "type": "string"
    },
    {
        "name": "submission_requirements",
        "baseName": "submission_requirements",
        "type": "Array<SubmissionRequirements>"
    }
];
class PresentationProposal {
    static getAttributeTypeMap() {
        return PresentationProposal.attributeTypeMap;
    }
}
exports.PresentationProposal = PresentationProposal;
PresentationProposal.discriminator = undefined;
PresentationProposal.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "presentation_proposal",
        "baseName": "presentation_proposal",
        "type": "IndyPresPreview"
    }
];
class PresentationRequest {
    static getAttributeTypeMap() {
        return PresentationRequest.attributeTypeMap;
    }
}
exports.PresentationRequest = PresentationRequest;
PresentationRequest.discriminator = undefined;
PresentationRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "request_presentationsattach",
        "baseName": "request_presentations~attach",
        "type": "Array<AttachDecorator>"
    }
];
class ProtocolDescriptor {
    static getAttributeTypeMap() {
        return ProtocolDescriptor.attributeTypeMap;
    }
}
exports.ProtocolDescriptor = ProtocolDescriptor;
ProtocolDescriptor.discriminator = undefined;
ProtocolDescriptor.attributeTypeMap = [
    {
        "name": "pid",
        "baseName": "pid",
        "type": "string"
    },
    {
        "name": "roles",
        "baseName": "roles",
        "type": "Array<string>"
    }
];
class PublishRevocations {
    static getAttributeTypeMap() {
        return PublishRevocations.attributeTypeMap;
    }
}
exports.PublishRevocations = PublishRevocations;
PublishRevocations.discriminator = undefined;
PublishRevocations.attributeTypeMap = [
    {
        "name": "rrid2crid",
        "baseName": "rrid2crid",
        "type": "{ [key: string]: Array<string>; }"
    }
];
class Queries {
    static getAttributeTypeMap() {
        return Queries.attributeTypeMap;
    }
}
exports.Queries = Queries;
Queries.discriminator = undefined;
Queries.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "queries",
        "baseName": "queries",
        "type": "Array<QueryItem>"
    }
];
class Query {
    static getAttributeTypeMap() {
        return Query.attributeTypeMap;
    }
}
exports.Query = Query;
Query.discriminator = undefined;
Query.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "query",
        "baseName": "query",
        "type": "string"
    }
];
class QueryItem {
    static getAttributeTypeMap() {
        return QueryItem.attributeTypeMap;
    }
}
exports.QueryItem = QueryItem;
QueryItem.discriminator = undefined;
QueryItem.attributeTypeMap = [
    {
        "name": "feature_type",
        "baseName": "feature-type",
        "type": "QueryItem.FeatureTypeEnum"
    },
    {
        "name": "match",
        "baseName": "match",
        "type": "string"
    }
];
(function (QueryItem) {
    let FeatureTypeEnum;
    (function (FeatureTypeEnum) {
        FeatureTypeEnum[FeatureTypeEnum["Protocol"] = 'protocol'] = "Protocol";
        FeatureTypeEnum[FeatureTypeEnum["GoalCode"] = 'goal-code'] = "GoalCode";
    })(FeatureTypeEnum = QueryItem.FeatureTypeEnum || (QueryItem.FeatureTypeEnum = {}));
})(QueryItem = exports.QueryItem || (exports.QueryItem = {}));
class QuestionRequest {
    static getAttributeTypeMap() {
        return QuestionRequest.attributeTypeMap;
    }
}
exports.QuestionRequest = QuestionRequest;
QuestionRequest.discriminator = undefined;
QuestionRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "question_detail",
        "baseName": "question_detail",
        "type": "string"
    },
    {
        "name": "question_text",
        "baseName": "question_text",
        "type": "string"
    },
    {
        "name": "valid_responses",
        "baseName": "valid_responses",
        "type": "Array<any>"
    }
];
class QuestionRequestResponse {
    static getAttributeTypeMap() {
        return QuestionRequestResponse.attributeTypeMap;
    }
}
exports.QuestionRequestResponse = QuestionRequestResponse;
QuestionRequestResponse.discriminator = undefined;
QuestionRequestResponse.attributeTypeMap = [
    {
        "name": "_id",
        "baseName": "_id",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "question_detail",
        "baseName": "question_detail",
        "type": "string"
    },
    {
        "name": "question_text",
        "baseName": "question_text",
        "type": "string"
    },
    {
        "name": "response",
        "baseName": "response",
        "type": "string"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    },
    {
        "name": "valid_responses",
        "baseName": "valid_responses",
        "type": "Array<any>"
    }
];
class RawEncoded {
    static getAttributeTypeMap() {
        return RawEncoded.attributeTypeMap;
    }
}
exports.RawEncoded = RawEncoded;
RawEncoded.discriminator = undefined;
RawEncoded.attributeTypeMap = [
    {
        "name": "encoded",
        "baseName": "encoded",
        "type": "string"
    },
    {
        "name": "raw",
        "baseName": "raw",
        "type": "string"
    }
];
class ReceiveInvitationRequest {
    static getAttributeTypeMap() {
        return ReceiveInvitationRequest.attributeTypeMap;
    }
}
exports.ReceiveInvitationRequest = ReceiveInvitationRequest;
ReceiveInvitationRequest.discriminator = undefined;
ReceiveInvitationRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "did",
        "baseName": "did",
        "type": "string"
    },
    {
        "name": "imageUrl",
        "baseName": "imageUrl",
        "type": "string"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "recipientKeys",
        "baseName": "recipientKeys",
        "type": "Array<string>"
    },
    {
        "name": "routingKeys",
        "baseName": "routingKeys",
        "type": "Array<string>"
    },
    {
        "name": "serviceEndpoint",
        "baseName": "serviceEndpoint",
        "type": "string"
    }
];
class RegisterLedgerNymResponse {
    static getAttributeTypeMap() {
        return RegisterLedgerNymResponse.attributeTypeMap;
    }
}
exports.RegisterLedgerNymResponse = RegisterLedgerNymResponse;
RegisterLedgerNymResponse.discriminator = undefined;
RegisterLedgerNymResponse.attributeTypeMap = [
    {
        "name": "success",
        "baseName": "success",
        "type": "boolean"
    }
];
class RemoveWalletRequest {
    static getAttributeTypeMap() {
        return RemoveWalletRequest.attributeTypeMap;
    }
}
exports.RemoveWalletRequest = RemoveWalletRequest;
RemoveWalletRequest.discriminator = undefined;
RemoveWalletRequest.attributeTypeMap = [
    {
        "name": "wallet_key",
        "baseName": "wallet_key",
        "type": "string"
    }
];
class ResolutionResult {
    static getAttributeTypeMap() {
        return ResolutionResult.attributeTypeMap;
    }
}
exports.ResolutionResult = ResolutionResult;
ResolutionResult.discriminator = undefined;
ResolutionResult.attributeTypeMap = [
    {
        "name": "did_doc",
        "baseName": "did_doc",
        "type": "any"
    },
    {
        "name": "metadata",
        "baseName": "metadata",
        "type": "any"
    }
];
class RevRegCreateRequest {
    static getAttributeTypeMap() {
        return RevRegCreateRequest.attributeTypeMap;
    }
}
exports.RevRegCreateRequest = RevRegCreateRequest;
RevRegCreateRequest.discriminator = undefined;
RevRegCreateRequest.attributeTypeMap = [
    {
        "name": "credential_definition_id",
        "baseName": "credential_definition_id",
        "type": "string"
    },
    {
        "name": "max_cred_num",
        "baseName": "max_cred_num",
        "type": "number"
    }
];
class RevRegIssuedResult {
    static getAttributeTypeMap() {
        return RevRegIssuedResult.attributeTypeMap;
    }
}
exports.RevRegIssuedResult = RevRegIssuedResult;
RevRegIssuedResult.discriminator = undefined;
RevRegIssuedResult.attributeTypeMap = [
    {
        "name": "result",
        "baseName": "result",
        "type": "number"
    }
];
class RevRegResult {
    static getAttributeTypeMap() {
        return RevRegResult.attributeTypeMap;
    }
}
exports.RevRegResult = RevRegResult;
RevRegResult.discriminator = undefined;
RevRegResult.attributeTypeMap = [
    {
        "name": "result",
        "baseName": "result",
        "type": "IssuerRevRegRecord"
    }
];
class RevRegUpdateTailsFileUri {
    static getAttributeTypeMap() {
        return RevRegUpdateTailsFileUri.attributeTypeMap;
    }
}
exports.RevRegUpdateTailsFileUri = RevRegUpdateTailsFileUri;
RevRegUpdateTailsFileUri.discriminator = undefined;
RevRegUpdateTailsFileUri.attributeTypeMap = [
    {
        "name": "tails_public_uri",
        "baseName": "tails_public_uri",
        "type": "string"
    }
];
class RevRegsCreated {
    static getAttributeTypeMap() {
        return RevRegsCreated.attributeTypeMap;
    }
}
exports.RevRegsCreated = RevRegsCreated;
RevRegsCreated.discriminator = undefined;
RevRegsCreated.attributeTypeMap = [
    {
        "name": "rev_reg_ids",
        "baseName": "rev_reg_ids",
        "type": "Array<string>"
    }
];
class RevocationModuleResponse {
    static getAttributeTypeMap() {
        return RevocationModuleResponse.attributeTypeMap;
    }
}
exports.RevocationModuleResponse = RevocationModuleResponse;
RevocationModuleResponse.discriminator = undefined;
RevocationModuleResponse.attributeTypeMap = [];
class RevokeRequest {
    static getAttributeTypeMap() {
        return RevokeRequest.attributeTypeMap;
    }
}
exports.RevokeRequest = RevokeRequest;
RevokeRequest.discriminator = undefined;
RevokeRequest.attributeTypeMap = [
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "cred_ex_id",
        "baseName": "cred_ex_id",
        "type": "string"
    },
    {
        "name": "cred_rev_id",
        "baseName": "cred_rev_id",
        "type": "string"
    },
    {
        "name": "notify",
        "baseName": "notify",
        "type": "boolean"
    },
    {
        "name": "publish",
        "baseName": "publish",
        "type": "boolean"
    },
    {
        "name": "rev_reg_id",
        "baseName": "rev_reg_id",
        "type": "string"
    },
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    }
];
class RouteRecord {
    static getAttributeTypeMap() {
        return RouteRecord.attributeTypeMap;
    }
}
exports.RouteRecord = RouteRecord;
RouteRecord.discriminator = undefined;
RouteRecord.attributeTypeMap = [
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "recipient_key",
        "baseName": "recipient_key",
        "type": "string"
    },
    {
        "name": "record_id",
        "baseName": "record_id",
        "type": "string"
    },
    {
        "name": "role",
        "baseName": "role",
        "type": "string"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    },
    {
        "name": "wallet_id",
        "baseName": "wallet_id",
        "type": "string"
    }
];
class Schema {
    static getAttributeTypeMap() {
        return Schema.attributeTypeMap;
    }
}
exports.Schema = Schema;
Schema.discriminator = undefined;
Schema.attributeTypeMap = [
    {
        "name": "attrNames",
        "baseName": "attrNames",
        "type": "Array<string>"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "seqNo",
        "baseName": "seqNo",
        "type": "number"
    },
    {
        "name": "ver",
        "baseName": "ver",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];
class SchemaGetResult {
    static getAttributeTypeMap() {
        return SchemaGetResult.attributeTypeMap;
    }
}
exports.SchemaGetResult = SchemaGetResult;
SchemaGetResult.discriminator = undefined;
SchemaGetResult.attributeTypeMap = [
    {
        "name": "schema",
        "baseName": "schema",
        "type": "Schema"
    }
];
class SchemaInputDescriptor {
    static getAttributeTypeMap() {
        return SchemaInputDescriptor.attributeTypeMap;
    }
}
exports.SchemaInputDescriptor = SchemaInputDescriptor;
SchemaInputDescriptor.discriminator = undefined;
SchemaInputDescriptor.attributeTypeMap = [
    {
        "name": "required",
        "baseName": "required",
        "type": "boolean"
    },
    {
        "name": "uri",
        "baseName": "uri",
        "type": "string"
    }
];
class SchemaSendRequest {
    static getAttributeTypeMap() {
        return SchemaSendRequest.attributeTypeMap;
    }
}
exports.SchemaSendRequest = SchemaSendRequest;
SchemaSendRequest.discriminator = undefined;
SchemaSendRequest.attributeTypeMap = [
    {
        "name": "attributes",
        "baseName": "attributes",
        "type": "Array<string>"
    },
    {
        "name": "schema_name",
        "baseName": "schema_name",
        "type": "string"
    },
    {
        "name": "schema_version",
        "baseName": "schema_version",
        "type": "string"
    }
];
class SchemaSendResult {
    static getAttributeTypeMap() {
        return SchemaSendResult.attributeTypeMap;
    }
}
exports.SchemaSendResult = SchemaSendResult;
SchemaSendResult.discriminator = undefined;
SchemaSendResult.attributeTypeMap = [
    {
        "name": "schema",
        "baseName": "schema",
        "type": "any"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    }
];
class SchemasCreatedResult {
    static getAttributeTypeMap() {
        return SchemasCreatedResult.attributeTypeMap;
    }
}
exports.SchemasCreatedResult = SchemasCreatedResult;
SchemasCreatedResult.discriminator = undefined;
SchemasCreatedResult.attributeTypeMap = [
    {
        "name": "schema_ids",
        "baseName": "schema_ids",
        "type": "Array<string>"
    }
];
class SchemasInputDescriptorFilter {
    static getAttributeTypeMap() {
        return SchemasInputDescriptorFilter.attributeTypeMap;
    }
}
exports.SchemasInputDescriptorFilter = SchemasInputDescriptorFilter;
SchemasInputDescriptorFilter.discriminator = undefined;
SchemasInputDescriptorFilter.attributeTypeMap = [
    {
        "name": "oneof_filter",
        "baseName": "oneof_filter",
        "type": "boolean"
    },
    {
        "name": "uri_groups",
        "baseName": "uri_groups",
        "type": "Array<Array<SchemaInputDescriptor>>"
    }
];
class SendMenu {
    static getAttributeTypeMap() {
        return SendMenu.attributeTypeMap;
    }
}
exports.SendMenu = SendMenu;
SendMenu.discriminator = undefined;
SendMenu.attributeTypeMap = [
    {
        "name": "menu",
        "baseName": "menu",
        "type": "any"
    }
];
class SendMessage {
    static getAttributeTypeMap() {
        return SendMessage.attributeTypeMap;
    }
}
exports.SendMessage = SendMessage;
SendMessage.discriminator = undefined;
SendMessage.attributeTypeMap = [
    {
        "name": "content",
        "baseName": "content",
        "type": "string"
    }
];
class SignRequest {
    static getAttributeTypeMap() {
        return SignRequest.attributeTypeMap;
    }
}
exports.SignRequest = SignRequest;
SignRequest.discriminator = undefined;
SignRequest.attributeTypeMap = [
    {
        "name": "doc",
        "baseName": "doc",
        "type": "Doc"
    },
    {
        "name": "verkey",
        "baseName": "verkey",
        "type": "string"
    }
];
class SignResponse {
    static getAttributeTypeMap() {
        return SignResponse.attributeTypeMap;
    }
}
exports.SignResponse = SignResponse;
SignResponse.discriminator = undefined;
SignResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    },
    {
        "name": "signed_doc",
        "baseName": "signed_doc",
        "type": "any"
    }
];
class SignatureOptions {
    static getAttributeTypeMap() {
        return SignatureOptions.attributeTypeMap;
    }
}
exports.SignatureOptions = SignatureOptions;
SignatureOptions.discriminator = undefined;
SignatureOptions.attributeTypeMap = [
    {
        "name": "challenge",
        "baseName": "challenge",
        "type": "string"
    },
    {
        "name": "domain",
        "baseName": "domain",
        "type": "string"
    },
    {
        "name": "proofPurpose",
        "baseName": "proofPurpose",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    },
    {
        "name": "verificationMethod",
        "baseName": "verificationMethod",
        "type": "string"
    }
];
class SignedDoc {
    static getAttributeTypeMap() {
        return SignedDoc.attributeTypeMap;
    }
}
exports.SignedDoc = SignedDoc;
SignedDoc.discriminator = undefined;
SignedDoc.attributeTypeMap = [
    {
        "name": "proof",
        "baseName": "proof",
        "type": "any"
    }
];
class SubmissionRequirements {
    static getAttributeTypeMap() {
        return SubmissionRequirements.attributeTypeMap;
    }
}
exports.SubmissionRequirements = SubmissionRequirements;
SubmissionRequirements.discriminator = undefined;
SubmissionRequirements.attributeTypeMap = [
    {
        "name": "count",
        "baseName": "count",
        "type": "number"
    },
    {
        "name": "from",
        "baseName": "from",
        "type": "string"
    },
    {
        "name": "from_nested",
        "baseName": "from_nested",
        "type": "Array<SubmissionRequirements>"
    },
    {
        "name": "max",
        "baseName": "max",
        "type": "number"
    },
    {
        "name": "min",
        "baseName": "min",
        "type": "number"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "purpose",
        "baseName": "purpose",
        "type": "string"
    },
    {
        "name": "rule",
        "baseName": "rule",
        "type": "SubmissionRequirements.RuleEnum"
    }
];
(function (SubmissionRequirements) {
    let RuleEnum;
    (function (RuleEnum) {
        RuleEnum[RuleEnum["All"] = 'all'] = "All";
        RuleEnum[RuleEnum["Pick"] = 'pick'] = "Pick";
    })(RuleEnum = SubmissionRequirements.RuleEnum || (SubmissionRequirements.RuleEnum = {}));
})(SubmissionRequirements = exports.SubmissionRequirements || (exports.SubmissionRequirements = {}));
class TAAAccept {
    static getAttributeTypeMap() {
        return TAAAccept.attributeTypeMap;
    }
}
exports.TAAAccept = TAAAccept;
TAAAccept.discriminator = undefined;
TAAAccept.attributeTypeMap = [
    {
        "name": "mechanism",
        "baseName": "mechanism",
        "type": "string"
    },
    {
        "name": "text",
        "baseName": "text",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];
class TAAAcceptance {
    static getAttributeTypeMap() {
        return TAAAcceptance.attributeTypeMap;
    }
}
exports.TAAAcceptance = TAAAcceptance;
TAAAcceptance.discriminator = undefined;
TAAAcceptance.attributeTypeMap = [
    {
        "name": "mechanism",
        "baseName": "mechanism",
        "type": "string"
    },
    {
        "name": "time",
        "baseName": "time",
        "type": "number"
    }
];
class TAAInfo {
    static getAttributeTypeMap() {
        return TAAInfo.attributeTypeMap;
    }
}
exports.TAAInfo = TAAInfo;
TAAInfo.discriminator = undefined;
TAAInfo.attributeTypeMap = [
    {
        "name": "aml_record",
        "baseName": "aml_record",
        "type": "AMLRecord"
    },
    {
        "name": "taa_accepted",
        "baseName": "taa_accepted",
        "type": "TAAAcceptance"
    },
    {
        "name": "taa_record",
        "baseName": "taa_record",
        "type": "TAARecord"
    },
    {
        "name": "taa_required",
        "baseName": "taa_required",
        "type": "boolean"
    }
];
class TAARecord {
    static getAttributeTypeMap() {
        return TAARecord.attributeTypeMap;
    }
}
exports.TAARecord = TAARecord;
TAARecord.discriminator = undefined;
TAARecord.attributeTypeMap = [
    {
        "name": "digest",
        "baseName": "digest",
        "type": "string"
    },
    {
        "name": "text",
        "baseName": "text",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    }
];
class TAAResult {
    static getAttributeTypeMap() {
        return TAAResult.attributeTypeMap;
    }
}
exports.TAAResult = TAAResult;
TAAResult.discriminator = undefined;
TAAResult.attributeTypeMap = [
    {
        "name": "result",
        "baseName": "result",
        "type": "TAAInfo"
    }
];
class TransactionJobs {
    static getAttributeTypeMap() {
        return TransactionJobs.attributeTypeMap;
    }
}
exports.TransactionJobs = TransactionJobs;
TransactionJobs.discriminator = undefined;
TransactionJobs.attributeTypeMap = [
    {
        "name": "transaction_my_job",
        "baseName": "transaction_my_job",
        "type": "TransactionJobs.TransactionMyJobEnum"
    },
    {
        "name": "transaction_their_job",
        "baseName": "transaction_their_job",
        "type": "TransactionJobs.TransactionTheirJobEnum"
    }
];
(function (TransactionJobs) {
    let TransactionMyJobEnum;
    (function (TransactionMyJobEnum) {
        TransactionMyJobEnum[TransactionMyJobEnum["TRANSACTIONAUTHOR"] = 'TRANSACTION_AUTHOR'] = "TRANSACTIONAUTHOR";
        TransactionMyJobEnum[TransactionMyJobEnum["TRANSACTIONENDORSER"] = 'TRANSACTION_ENDORSER'] = "TRANSACTIONENDORSER";
        TransactionMyJobEnum[TransactionMyJobEnum["Reset"] = 'reset'] = "Reset";
    })(TransactionMyJobEnum = TransactionJobs.TransactionMyJobEnum || (TransactionJobs.TransactionMyJobEnum = {}));
    let TransactionTheirJobEnum;
    (function (TransactionTheirJobEnum) {
        TransactionTheirJobEnum[TransactionTheirJobEnum["TRANSACTIONAUTHOR"] = 'TRANSACTION_AUTHOR'] = "TRANSACTIONAUTHOR";
        TransactionTheirJobEnum[TransactionTheirJobEnum["TRANSACTIONENDORSER"] = 'TRANSACTION_ENDORSER'] = "TRANSACTIONENDORSER";
        TransactionTheirJobEnum[TransactionTheirJobEnum["Reset"] = 'reset'] = "Reset";
    })(TransactionTheirJobEnum = TransactionJobs.TransactionTheirJobEnum || (TransactionJobs.TransactionTheirJobEnum = {}));
})(TransactionJobs = exports.TransactionJobs || (exports.TransactionJobs = {}));
class TransactionList {
    static getAttributeTypeMap() {
        return TransactionList.attributeTypeMap;
    }
}
exports.TransactionList = TransactionList;
TransactionList.discriminator = undefined;
TransactionList.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<TransactionRecord>"
    }
];
class TransactionRecord {
    static getAttributeTypeMap() {
        return TransactionRecord.attributeTypeMap;
    }
}
exports.TransactionRecord = TransactionRecord;
TransactionRecord.discriminator = undefined;
TransactionRecord.attributeTypeMap = [
    {
        "name": "_type",
        "baseName": "_type",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "endorser_write_txn",
        "baseName": "endorser_write_txn",
        "type": "boolean"
    },
    {
        "name": "formats",
        "baseName": "formats",
        "type": "Array<{ [key: string]: string; }>"
    },
    {
        "name": "messages_attach",
        "baseName": "messages_attach",
        "type": "Array<any>"
    },
    {
        "name": "meta_data",
        "baseName": "meta_data",
        "type": "any"
    },
    {
        "name": "signature_request",
        "baseName": "signature_request",
        "type": "Array<any>"
    },
    {
        "name": "signature_response",
        "baseName": "signature_response",
        "type": "Array<any>"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    },
    {
        "name": "timing",
        "baseName": "timing",
        "type": "any"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    },
    {
        "name": "transaction_id",
        "baseName": "transaction_id",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
class TxnOrCredentialDefinitionSendResult {
    static getAttributeTypeMap() {
        return TxnOrCredentialDefinitionSendResult.attributeTypeMap;
    }
}
exports.TxnOrCredentialDefinitionSendResult = TxnOrCredentialDefinitionSendResult;
TxnOrCredentialDefinitionSendResult.discriminator = undefined;
TxnOrCredentialDefinitionSendResult.attributeTypeMap = [
    {
        "name": "sent",
        "baseName": "sent",
        "type": "CredentialDefinitionSendResult"
    },
    {
        "name": "txn",
        "baseName": "txn",
        "type": "any"
    }
];
class TxnOrPublishRevocationsResult {
    static getAttributeTypeMap() {
        return TxnOrPublishRevocationsResult.attributeTypeMap;
    }
}
exports.TxnOrPublishRevocationsResult = TxnOrPublishRevocationsResult;
TxnOrPublishRevocationsResult.discriminator = undefined;
TxnOrPublishRevocationsResult.attributeTypeMap = [
    {
        "name": "sent",
        "baseName": "sent",
        "type": "PublishRevocations"
    },
    {
        "name": "txn",
        "baseName": "txn",
        "type": "any"
    }
];
class TxnOrRevRegResult {
    static getAttributeTypeMap() {
        return TxnOrRevRegResult.attributeTypeMap;
    }
}
exports.TxnOrRevRegResult = TxnOrRevRegResult;
TxnOrRevRegResult.discriminator = undefined;
TxnOrRevRegResult.attributeTypeMap = [
    {
        "name": "sent",
        "baseName": "sent",
        "type": "RevRegResult"
    },
    {
        "name": "txn",
        "baseName": "txn",
        "type": "any"
    }
];
class TxnOrSchemaSendResult {
    static getAttributeTypeMap() {
        return TxnOrSchemaSendResult.attributeTypeMap;
    }
}
exports.TxnOrSchemaSendResult = TxnOrSchemaSendResult;
TxnOrSchemaSendResult.discriminator = undefined;
TxnOrSchemaSendResult.attributeTypeMap = [
    {
        "name": "sent",
        "baseName": "sent",
        "type": "any"
    },
    {
        "name": "txn",
        "baseName": "txn",
        "type": "any"
    }
];
class UpdateWalletRequest {
    static getAttributeTypeMap() {
        return UpdateWalletRequest.attributeTypeMap;
    }
}
exports.UpdateWalletRequest = UpdateWalletRequest;
UpdateWalletRequest.discriminator = undefined;
UpdateWalletRequest.attributeTypeMap = [
    {
        "name": "image_url",
        "baseName": "image_url",
        "type": "string"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "wallet_dispatch_type",
        "baseName": "wallet_dispatch_type",
        "type": "UpdateWalletRequest.WalletDispatchTypeEnum"
    },
    {
        "name": "wallet_webhook_urls",
        "baseName": "wallet_webhook_urls",
        "type": "Array<string>"
    }
];
(function (UpdateWalletRequest) {
    let WalletDispatchTypeEnum;
    (function (WalletDispatchTypeEnum) {
        WalletDispatchTypeEnum[WalletDispatchTypeEnum["Default"] = 'default'] = "Default";
        WalletDispatchTypeEnum[WalletDispatchTypeEnum["Both"] = 'both'] = "Both";
        WalletDispatchTypeEnum[WalletDispatchTypeEnum["Base"] = 'base'] = "Base";
    })(WalletDispatchTypeEnum = UpdateWalletRequest.WalletDispatchTypeEnum || (UpdateWalletRequest.WalletDispatchTypeEnum = {}));
})(UpdateWalletRequest = exports.UpdateWalletRequest || (exports.UpdateWalletRequest = {}));
class V10CredentialBoundOfferRequest {
    static getAttributeTypeMap() {
        return V10CredentialBoundOfferRequest.attributeTypeMap;
    }
}
exports.V10CredentialBoundOfferRequest = V10CredentialBoundOfferRequest;
V10CredentialBoundOfferRequest.discriminator = undefined;
V10CredentialBoundOfferRequest.attributeTypeMap = [
    {
        "name": "counter_proposal",
        "baseName": "counter_proposal",
        "type": "any"
    }
];
class V10CredentialConnFreeOfferRequest {
    static getAttributeTypeMap() {
        return V10CredentialConnFreeOfferRequest.attributeTypeMap;
    }
}
exports.V10CredentialConnFreeOfferRequest = V10CredentialConnFreeOfferRequest;
V10CredentialConnFreeOfferRequest.discriminator = undefined;
V10CredentialConnFreeOfferRequest.attributeTypeMap = [
    {
        "name": "auto_issue",
        "baseName": "auto_issue",
        "type": "boolean"
    },
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "credential_preview",
        "baseName": "credential_preview",
        "type": "CredentialPreview"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V10CredentialCreate {
    static getAttributeTypeMap() {
        return V10CredentialCreate.attributeTypeMap;
    }
}
exports.V10CredentialCreate = V10CredentialCreate;
V10CredentialCreate.discriminator = undefined;
V10CredentialCreate.attributeTypeMap = [
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "credential_proposal",
        "baseName": "credential_proposal",
        "type": "CredentialPreview"
    },
    {
        "name": "issuer_did",
        "baseName": "issuer_did",
        "type": "string"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    },
    {
        "name": "schema_issuer_did",
        "baseName": "schema_issuer_did",
        "type": "string"
    },
    {
        "name": "schema_name",
        "baseName": "schema_name",
        "type": "string"
    },
    {
        "name": "schema_version",
        "baseName": "schema_version",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V10CredentialExchange {
    static getAttributeTypeMap() {
        return V10CredentialExchange.attributeTypeMap;
    }
}
exports.V10CredentialExchange = V10CredentialExchange;
V10CredentialExchange.discriminator = undefined;
V10CredentialExchange.attributeTypeMap = [
    {
        "name": "auto_issue",
        "baseName": "auto_issue",
        "type": "boolean"
    },
    {
        "name": "auto_offer",
        "baseName": "auto_offer",
        "type": "boolean"
    },
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "credential",
        "baseName": "credential",
        "type": "any"
    },
    {
        "name": "credential_definition_id",
        "baseName": "credential_definition_id",
        "type": "string"
    },
    {
        "name": "credential_exchange_id",
        "baseName": "credential_exchange_id",
        "type": "string"
    },
    {
        "name": "credential_id",
        "baseName": "credential_id",
        "type": "string"
    },
    {
        "name": "credential_offer",
        "baseName": "credential_offer",
        "type": "any"
    },
    {
        "name": "credential_offer_dict",
        "baseName": "credential_offer_dict",
        "type": "any"
    },
    {
        "name": "credential_proposal_dict",
        "baseName": "credential_proposal_dict",
        "type": "any"
    },
    {
        "name": "credential_request",
        "baseName": "credential_request",
        "type": "any"
    },
    {
        "name": "credential_request_metadata",
        "baseName": "credential_request_metadata",
        "type": "any"
    },
    {
        "name": "error_msg",
        "baseName": "error_msg",
        "type": "string"
    },
    {
        "name": "initiator",
        "baseName": "initiator",
        "type": "V10CredentialExchange.InitiatorEnum"
    },
    {
        "name": "parent_thread_id",
        "baseName": "parent_thread_id",
        "type": "string"
    },
    {
        "name": "raw_credential",
        "baseName": "raw_credential",
        "type": "any"
    },
    {
        "name": "revoc_reg_id",
        "baseName": "revoc_reg_id",
        "type": "string"
    },
    {
        "name": "revocation_id",
        "baseName": "revocation_id",
        "type": "string"
    },
    {
        "name": "role",
        "baseName": "role",
        "type": "V10CredentialExchange.RoleEnum"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
(function (V10CredentialExchange) {
    let InitiatorEnum;
    (function (InitiatorEnum) {
        InitiatorEnum[InitiatorEnum["Self"] = 'self'] = "Self";
        InitiatorEnum[InitiatorEnum["External"] = 'external'] = "External";
    })(InitiatorEnum = V10CredentialExchange.InitiatorEnum || (V10CredentialExchange.InitiatorEnum = {}));
    let RoleEnum;
    (function (RoleEnum) {
        RoleEnum[RoleEnum["Holder"] = 'holder'] = "Holder";
        RoleEnum[RoleEnum["Issuer"] = 'issuer'] = "Issuer";
    })(RoleEnum = V10CredentialExchange.RoleEnum || (V10CredentialExchange.RoleEnum = {}));
})(V10CredentialExchange = exports.V10CredentialExchange || (exports.V10CredentialExchange = {}));
class V10CredentialExchangeListResult {
    static getAttributeTypeMap() {
        return V10CredentialExchangeListResult.attributeTypeMap;
    }
}
exports.V10CredentialExchangeListResult = V10CredentialExchangeListResult;
V10CredentialExchangeListResult.discriminator = undefined;
V10CredentialExchangeListResult.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<V10CredentialExchange>"
    }
];
class V10CredentialFreeOfferRequest {
    static getAttributeTypeMap() {
        return V10CredentialFreeOfferRequest.attributeTypeMap;
    }
}
exports.V10CredentialFreeOfferRequest = V10CredentialFreeOfferRequest;
V10CredentialFreeOfferRequest.discriminator = undefined;
V10CredentialFreeOfferRequest.attributeTypeMap = [
    {
        "name": "auto_issue",
        "baseName": "auto_issue",
        "type": "boolean"
    },
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "credential_preview",
        "baseName": "credential_preview",
        "type": "CredentialPreview"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V10CredentialIssueRequest {
    static getAttributeTypeMap() {
        return V10CredentialIssueRequest.attributeTypeMap;
    }
}
exports.V10CredentialIssueRequest = V10CredentialIssueRequest;
V10CredentialIssueRequest.discriminator = undefined;
V10CredentialIssueRequest.attributeTypeMap = [
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    }
];
class V10CredentialProblemReportRequest {
    static getAttributeTypeMap() {
        return V10CredentialProblemReportRequest.attributeTypeMap;
    }
}
exports.V10CredentialProblemReportRequest = V10CredentialProblemReportRequest;
V10CredentialProblemReportRequest.discriminator = undefined;
V10CredentialProblemReportRequest.attributeTypeMap = [
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    }
];
class V10CredentialProposalRequestMand {
    static getAttributeTypeMap() {
        return V10CredentialProposalRequestMand.attributeTypeMap;
    }
}
exports.V10CredentialProposalRequestMand = V10CredentialProposalRequestMand;
V10CredentialProposalRequestMand.discriminator = undefined;
V10CredentialProposalRequestMand.attributeTypeMap = [
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "credential_proposal",
        "baseName": "credential_proposal",
        "type": "CredentialPreview"
    },
    {
        "name": "issuer_did",
        "baseName": "issuer_did",
        "type": "string"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    },
    {
        "name": "schema_issuer_did",
        "baseName": "schema_issuer_did",
        "type": "string"
    },
    {
        "name": "schema_name",
        "baseName": "schema_name",
        "type": "string"
    },
    {
        "name": "schema_version",
        "baseName": "schema_version",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V10CredentialProposalRequestOpt {
    static getAttributeTypeMap() {
        return V10CredentialProposalRequestOpt.attributeTypeMap;
    }
}
exports.V10CredentialProposalRequestOpt = V10CredentialProposalRequestOpt;
V10CredentialProposalRequestOpt.discriminator = undefined;
V10CredentialProposalRequestOpt.attributeTypeMap = [
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "credential_proposal",
        "baseName": "credential_proposal",
        "type": "CredentialPreview"
    },
    {
        "name": "issuer_did",
        "baseName": "issuer_did",
        "type": "string"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    },
    {
        "name": "schema_issuer_did",
        "baseName": "schema_issuer_did",
        "type": "string"
    },
    {
        "name": "schema_name",
        "baseName": "schema_name",
        "type": "string"
    },
    {
        "name": "schema_version",
        "baseName": "schema_version",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V10CredentialStoreRequest {
    static getAttributeTypeMap() {
        return V10CredentialStoreRequest.attributeTypeMap;
    }
}
exports.V10CredentialStoreRequest = V10CredentialStoreRequest;
V10CredentialStoreRequest.discriminator = undefined;
V10CredentialStoreRequest.attributeTypeMap = [
    {
        "name": "credential_id",
        "baseName": "credential_id",
        "type": "string"
    }
];
class V10DiscoveryExchangeListResult {
    static getAttributeTypeMap() {
        return V10DiscoveryExchangeListResult.attributeTypeMap;
    }
}
exports.V10DiscoveryExchangeListResult = V10DiscoveryExchangeListResult;
V10DiscoveryExchangeListResult.discriminator = undefined;
V10DiscoveryExchangeListResult.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<any>"
    }
];
class V10DiscoveryExchangeResult {
    static getAttributeTypeMap() {
        return V10DiscoveryExchangeResult.attributeTypeMap;
    }
}
exports.V10DiscoveryExchangeResult = V10DiscoveryExchangeResult;
V10DiscoveryExchangeResult.discriminator = undefined;
V10DiscoveryExchangeResult.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "any"
    }
];
class V10DiscoveryRecord {
    static getAttributeTypeMap() {
        return V10DiscoveryRecord.attributeTypeMap;
    }
}
exports.V10DiscoveryRecord = V10DiscoveryRecord;
V10DiscoveryRecord.discriminator = undefined;
V10DiscoveryRecord.attributeTypeMap = [
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "disclose",
        "baseName": "disclose",
        "type": "any"
    },
    {
        "name": "discovery_exchange_id",
        "baseName": "discovery_exchange_id",
        "type": "string"
    },
    {
        "name": "query_msg",
        "baseName": "query_msg",
        "type": "any"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
class V10PresentProofModuleResponse {
    static getAttributeTypeMap() {
        return V10PresentProofModuleResponse.attributeTypeMap;
    }
}
exports.V10PresentProofModuleResponse = V10PresentProofModuleResponse;
V10PresentProofModuleResponse.discriminator = undefined;
V10PresentProofModuleResponse.attributeTypeMap = [];
class V10PresentationCreateRequestRequest {
    static getAttributeTypeMap() {
        return V10PresentationCreateRequestRequest.attributeTypeMap;
    }
}
exports.V10PresentationCreateRequestRequest = V10PresentationCreateRequestRequest;
V10PresentationCreateRequestRequest.discriminator = undefined;
V10PresentationCreateRequestRequest.attributeTypeMap = [
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "proof_request",
        "baseName": "proof_request",
        "type": "IndyProofRequest"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V10PresentationExchange {
    static getAttributeTypeMap() {
        return V10PresentationExchange.attributeTypeMap;
    }
}
exports.V10PresentationExchange = V10PresentationExchange;
V10PresentationExchange.discriminator = undefined;
V10PresentationExchange.attributeTypeMap = [
    {
        "name": "auto_present",
        "baseName": "auto_present",
        "type": "boolean"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "error_msg",
        "baseName": "error_msg",
        "type": "string"
    },
    {
        "name": "initiator",
        "baseName": "initiator",
        "type": "V10PresentationExchange.InitiatorEnum"
    },
    {
        "name": "presentation",
        "baseName": "presentation",
        "type": "any"
    },
    {
        "name": "presentation_exchange_id",
        "baseName": "presentation_exchange_id",
        "type": "string"
    },
    {
        "name": "presentation_proposal_dict",
        "baseName": "presentation_proposal_dict",
        "type": "any"
    },
    {
        "name": "presentation_request",
        "baseName": "presentation_request",
        "type": "any"
    },
    {
        "name": "presentation_request_dict",
        "baseName": "presentation_request_dict",
        "type": "any"
    },
    {
        "name": "role",
        "baseName": "role",
        "type": "V10PresentationExchange.RoleEnum"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    },
    {
        "name": "verified",
        "baseName": "verified",
        "type": "V10PresentationExchange.VerifiedEnum"
    }
];
(function (V10PresentationExchange) {
    let InitiatorEnum;
    (function (InitiatorEnum) {
        InitiatorEnum[InitiatorEnum["Self"] = 'self'] = "Self";
        InitiatorEnum[InitiatorEnum["External"] = 'external'] = "External";
    })(InitiatorEnum = V10PresentationExchange.InitiatorEnum || (V10PresentationExchange.InitiatorEnum = {}));
    let RoleEnum;
    (function (RoleEnum) {
        RoleEnum[RoleEnum["Prover"] = 'prover'] = "Prover";
        RoleEnum[RoleEnum["Verifier"] = 'verifier'] = "Verifier";
    })(RoleEnum = V10PresentationExchange.RoleEnum || (V10PresentationExchange.RoleEnum = {}));
    let VerifiedEnum;
    (function (VerifiedEnum) {
        VerifiedEnum[VerifiedEnum["True"] = 'true'] = "True";
        VerifiedEnum[VerifiedEnum["False"] = 'false'] = "False";
    })(VerifiedEnum = V10PresentationExchange.VerifiedEnum || (V10PresentationExchange.VerifiedEnum = {}));
})(V10PresentationExchange = exports.V10PresentationExchange || (exports.V10PresentationExchange = {}));
class V10PresentationExchangeList {
    static getAttributeTypeMap() {
        return V10PresentationExchangeList.attributeTypeMap;
    }
}
exports.V10PresentationExchangeList = V10PresentationExchangeList;
V10PresentationExchangeList.discriminator = undefined;
V10PresentationExchangeList.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<V10PresentationExchange>"
    }
];
class V10PresentationProblemReportRequest {
    static getAttributeTypeMap() {
        return V10PresentationProblemReportRequest.attributeTypeMap;
    }
}
exports.V10PresentationProblemReportRequest = V10PresentationProblemReportRequest;
V10PresentationProblemReportRequest.discriminator = undefined;
V10PresentationProblemReportRequest.attributeTypeMap = [
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    }
];
class V10PresentationProposalRequest {
    static getAttributeTypeMap() {
        return V10PresentationProposalRequest.attributeTypeMap;
    }
}
exports.V10PresentationProposalRequest = V10PresentationProposalRequest;
V10PresentationProposalRequest.discriminator = undefined;
V10PresentationProposalRequest.attributeTypeMap = [
    {
        "name": "auto_present",
        "baseName": "auto_present",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "presentation_proposal",
        "baseName": "presentation_proposal",
        "type": "IndyPresPreview"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V10PresentationSendRequestRequest {
    static getAttributeTypeMap() {
        return V10PresentationSendRequestRequest.attributeTypeMap;
    }
}
exports.V10PresentationSendRequestRequest = V10PresentationSendRequestRequest;
V10PresentationSendRequestRequest.discriminator = undefined;
V10PresentationSendRequestRequest.attributeTypeMap = [
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "proof_request",
        "baseName": "proof_request",
        "type": "IndyProofRequest"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20CredAttrSpec {
    static getAttributeTypeMap() {
        return V20CredAttrSpec.attributeTypeMap;
    }
}
exports.V20CredAttrSpec = V20CredAttrSpec;
V20CredAttrSpec.discriminator = undefined;
V20CredAttrSpec.attributeTypeMap = [
    {
        "name": "mime_type",
        "baseName": "mime-type",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    }
];
class V20CredBoundOfferRequest {
    static getAttributeTypeMap() {
        return V20CredBoundOfferRequest.attributeTypeMap;
    }
}
exports.V20CredBoundOfferRequest = V20CredBoundOfferRequest;
V20CredBoundOfferRequest.discriminator = undefined;
V20CredBoundOfferRequest.attributeTypeMap = [
    {
        "name": "counter_preview",
        "baseName": "counter_preview",
        "type": "any"
    },
    {
        "name": "filter",
        "baseName": "filter",
        "type": "any"
    }
];
class V20CredExFree {
    static getAttributeTypeMap() {
        return V20CredExFree.attributeTypeMap;
    }
}
exports.V20CredExFree = V20CredExFree;
V20CredExFree.discriminator = undefined;
V20CredExFree.attributeTypeMap = [
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "credential_preview",
        "baseName": "credential_preview",
        "type": "V20CredPreview"
    },
    {
        "name": "filter",
        "baseName": "filter",
        "type": "any"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20CredExRecord {
    static getAttributeTypeMap() {
        return V20CredExRecord.attributeTypeMap;
    }
}
exports.V20CredExRecord = V20CredExRecord;
V20CredExRecord.discriminator = undefined;
V20CredExRecord.attributeTypeMap = [
    {
        "name": "auto_issue",
        "baseName": "auto_issue",
        "type": "boolean"
    },
    {
        "name": "auto_offer",
        "baseName": "auto_offer",
        "type": "boolean"
    },
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "by_format",
        "baseName": "by_format",
        "type": "any"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "cred_ex_id",
        "baseName": "cred_ex_id",
        "type": "string"
    },
    {
        "name": "cred_issue",
        "baseName": "cred_issue",
        "type": "any"
    },
    {
        "name": "cred_offer",
        "baseName": "cred_offer",
        "type": "any"
    },
    {
        "name": "cred_preview",
        "baseName": "cred_preview",
        "type": "any"
    },
    {
        "name": "cred_proposal",
        "baseName": "cred_proposal",
        "type": "any"
    },
    {
        "name": "cred_request",
        "baseName": "cred_request",
        "type": "any"
    },
    {
        "name": "error_msg",
        "baseName": "error_msg",
        "type": "string"
    },
    {
        "name": "initiator",
        "baseName": "initiator",
        "type": "V20CredExRecord.InitiatorEnum"
    },
    {
        "name": "parent_thread_id",
        "baseName": "parent_thread_id",
        "type": "string"
    },
    {
        "name": "role",
        "baseName": "role",
        "type": "V20CredExRecord.RoleEnum"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "V20CredExRecord.StateEnum"
    },
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
(function (V20CredExRecord) {
    let InitiatorEnum;
    (function (InitiatorEnum) {
        InitiatorEnum[InitiatorEnum["Self"] = 'self'] = "Self";
        InitiatorEnum[InitiatorEnum["External"] = 'external'] = "External";
    })(InitiatorEnum = V20CredExRecord.InitiatorEnum || (V20CredExRecord.InitiatorEnum = {}));
    let RoleEnum;
    (function (RoleEnum) {
        RoleEnum[RoleEnum["Issuer"] = 'issuer'] = "Issuer";
        RoleEnum[RoleEnum["Holder"] = 'holder'] = "Holder";
    })(RoleEnum = V20CredExRecord.RoleEnum || (V20CredExRecord.RoleEnum = {}));
    let StateEnum;
    (function (StateEnum) {
        StateEnum[StateEnum["ProposalSent"] = 'proposal-sent'] = "ProposalSent";
        StateEnum[StateEnum["ProposalReceived"] = 'proposal-received'] = "ProposalReceived";
        StateEnum[StateEnum["OfferSent"] = 'offer-sent'] = "OfferSent";
        StateEnum[StateEnum["OfferReceived"] = 'offer-received'] = "OfferReceived";
        StateEnum[StateEnum["RequestSent"] = 'request-sent'] = "RequestSent";
        StateEnum[StateEnum["RequestReceived"] = 'request-received'] = "RequestReceived";
        StateEnum[StateEnum["CredentialIssued"] = 'credential-issued'] = "CredentialIssued";
        StateEnum[StateEnum["CredentialReceived"] = 'credential-received'] = "CredentialReceived";
        StateEnum[StateEnum["Done"] = 'done'] = "Done";
        StateEnum[StateEnum["CredentialRevoked"] = 'credential-revoked'] = "CredentialRevoked";
    })(StateEnum = V20CredExRecord.StateEnum || (V20CredExRecord.StateEnum = {}));
})(V20CredExRecord = exports.V20CredExRecord || (exports.V20CredExRecord = {}));
class V20CredExRecordByFormat {
    static getAttributeTypeMap() {
        return V20CredExRecordByFormat.attributeTypeMap;
    }
}
exports.V20CredExRecordByFormat = V20CredExRecordByFormat;
V20CredExRecordByFormat.discriminator = undefined;
V20CredExRecordByFormat.attributeTypeMap = [
    {
        "name": "cred_issue",
        "baseName": "cred_issue",
        "type": "any"
    },
    {
        "name": "cred_offer",
        "baseName": "cred_offer",
        "type": "any"
    },
    {
        "name": "cred_proposal",
        "baseName": "cred_proposal",
        "type": "any"
    },
    {
        "name": "cred_request",
        "baseName": "cred_request",
        "type": "any"
    }
];
class V20CredExRecordDetail {
    static getAttributeTypeMap() {
        return V20CredExRecordDetail.attributeTypeMap;
    }
}
exports.V20CredExRecordDetail = V20CredExRecordDetail;
V20CredExRecordDetail.discriminator = undefined;
V20CredExRecordDetail.attributeTypeMap = [
    {
        "name": "cred_ex_record",
        "baseName": "cred_ex_record",
        "type": "any"
    },
    {
        "name": "indy",
        "baseName": "indy",
        "type": "V20CredExRecordIndy"
    },
    {
        "name": "ld_proof",
        "baseName": "ld_proof",
        "type": "V20CredExRecordLDProof"
    }
];
class V20CredExRecordIndy {
    static getAttributeTypeMap() {
        return V20CredExRecordIndy.attributeTypeMap;
    }
}
exports.V20CredExRecordIndy = V20CredExRecordIndy;
V20CredExRecordIndy.discriminator = undefined;
V20CredExRecordIndy.attributeTypeMap = [
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "cred_ex_id",
        "baseName": "cred_ex_id",
        "type": "string"
    },
    {
        "name": "cred_ex_indy_id",
        "baseName": "cred_ex_indy_id",
        "type": "string"
    },
    {
        "name": "cred_id_stored",
        "baseName": "cred_id_stored",
        "type": "string"
    },
    {
        "name": "cred_request_metadata",
        "baseName": "cred_request_metadata",
        "type": "any"
    },
    {
        "name": "cred_rev_id",
        "baseName": "cred_rev_id",
        "type": "string"
    },
    {
        "name": "rev_reg_id",
        "baseName": "rev_reg_id",
        "type": "string"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
class V20CredExRecordLDProof {
    static getAttributeTypeMap() {
        return V20CredExRecordLDProof.attributeTypeMap;
    }
}
exports.V20CredExRecordLDProof = V20CredExRecordLDProof;
V20CredExRecordLDProof.discriminator = undefined;
V20CredExRecordLDProof.attributeTypeMap = [
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "cred_ex_id",
        "baseName": "cred_ex_id",
        "type": "string"
    },
    {
        "name": "cred_ex_ld_proof_id",
        "baseName": "cred_ex_ld_proof_id",
        "type": "string"
    },
    {
        "name": "cred_id_stored",
        "baseName": "cred_id_stored",
        "type": "string"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
class V20CredExRecordListResult {
    static getAttributeTypeMap() {
        return V20CredExRecordListResult.attributeTypeMap;
    }
}
exports.V20CredExRecordListResult = V20CredExRecordListResult;
V20CredExRecordListResult.discriminator = undefined;
V20CredExRecordListResult.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<V20CredExRecordDetail>"
    }
];
class V20CredFilter {
    static getAttributeTypeMap() {
        return V20CredFilter.attributeTypeMap;
    }
}
exports.V20CredFilter = V20CredFilter;
V20CredFilter.discriminator = undefined;
V20CredFilter.attributeTypeMap = [
    {
        "name": "indy",
        "baseName": "indy",
        "type": "any"
    },
    {
        "name": "ld_proof",
        "baseName": "ld_proof",
        "type": "any"
    }
];
class V20CredFilterIndy {
    static getAttributeTypeMap() {
        return V20CredFilterIndy.attributeTypeMap;
    }
}
exports.V20CredFilterIndy = V20CredFilterIndy;
V20CredFilterIndy.discriminator = undefined;
V20CredFilterIndy.attributeTypeMap = [
    {
        "name": "cred_def_id",
        "baseName": "cred_def_id",
        "type": "string"
    },
    {
        "name": "issuer_did",
        "baseName": "issuer_did",
        "type": "string"
    },
    {
        "name": "schema_id",
        "baseName": "schema_id",
        "type": "string"
    },
    {
        "name": "schema_issuer_did",
        "baseName": "schema_issuer_did",
        "type": "string"
    },
    {
        "name": "schema_name",
        "baseName": "schema_name",
        "type": "string"
    },
    {
        "name": "schema_version",
        "baseName": "schema_version",
        "type": "string"
    }
];
class V20CredFilterLDProof {
    static getAttributeTypeMap() {
        return V20CredFilterLDProof.attributeTypeMap;
    }
}
exports.V20CredFilterLDProof = V20CredFilterLDProof;
V20CredFilterLDProof.discriminator = undefined;
V20CredFilterLDProof.attributeTypeMap = [
    {
        "name": "ld_proof",
        "baseName": "ld_proof",
        "type": "any"
    }
];
class V20CredFormat {
    static getAttributeTypeMap() {
        return V20CredFormat.attributeTypeMap;
    }
}
exports.V20CredFormat = V20CredFormat;
V20CredFormat.discriminator = undefined;
V20CredFormat.attributeTypeMap = [
    {
        "name": "attach_id",
        "baseName": "attach_id",
        "type": "string"
    },
    {
        "name": "format",
        "baseName": "format",
        "type": "string"
    }
];
class V20CredIssue {
    static getAttributeTypeMap() {
        return V20CredIssue.attributeTypeMap;
    }
}
exports.V20CredIssue = V20CredIssue;
V20CredIssue.discriminator = undefined;
V20CredIssue.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "credentialsattach",
        "baseName": "credentials~attach",
        "type": "Array<AttachDecorator>"
    },
    {
        "name": "formats",
        "baseName": "formats",
        "type": "Array<V20CredFormat>"
    },
    {
        "name": "replacement_id",
        "baseName": "replacement_id",
        "type": "string"
    }
];
class V20CredIssueProblemReportRequest {
    static getAttributeTypeMap() {
        return V20CredIssueProblemReportRequest.attributeTypeMap;
    }
}
exports.V20CredIssueProblemReportRequest = V20CredIssueProblemReportRequest;
V20CredIssueProblemReportRequest.discriminator = undefined;
V20CredIssueProblemReportRequest.attributeTypeMap = [
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    }
];
class V20CredIssueRequest {
    static getAttributeTypeMap() {
        return V20CredIssueRequest.attributeTypeMap;
    }
}
exports.V20CredIssueRequest = V20CredIssueRequest;
V20CredIssueRequest.discriminator = undefined;
V20CredIssueRequest.attributeTypeMap = [
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    }
];
class V20CredOffer {
    static getAttributeTypeMap() {
        return V20CredOffer.attributeTypeMap;
    }
}
exports.V20CredOffer = V20CredOffer;
V20CredOffer.discriminator = undefined;
V20CredOffer.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "credential_preview",
        "baseName": "credential_preview",
        "type": "V20CredPreview"
    },
    {
        "name": "formats",
        "baseName": "formats",
        "type": "Array<V20CredFormat>"
    },
    {
        "name": "offersattach",
        "baseName": "offers~attach",
        "type": "Array<AttachDecorator>"
    },
    {
        "name": "replacement_id",
        "baseName": "replacement_id",
        "type": "string"
    }
];
class V20CredOfferConnFreeRequest {
    static getAttributeTypeMap() {
        return V20CredOfferConnFreeRequest.attributeTypeMap;
    }
}
exports.V20CredOfferConnFreeRequest = V20CredOfferConnFreeRequest;
V20CredOfferConnFreeRequest.discriminator = undefined;
V20CredOfferConnFreeRequest.attributeTypeMap = [
    {
        "name": "auto_issue",
        "baseName": "auto_issue",
        "type": "boolean"
    },
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "credential_preview",
        "baseName": "credential_preview",
        "type": "V20CredPreview"
    },
    {
        "name": "filter",
        "baseName": "filter",
        "type": "any"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20CredOfferRequest {
    static getAttributeTypeMap() {
        return V20CredOfferRequest.attributeTypeMap;
    }
}
exports.V20CredOfferRequest = V20CredOfferRequest;
V20CredOfferRequest.discriminator = undefined;
V20CredOfferRequest.attributeTypeMap = [
    {
        "name": "auto_issue",
        "baseName": "auto_issue",
        "type": "boolean"
    },
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "credential_preview",
        "baseName": "credential_preview",
        "type": "V20CredPreview"
    },
    {
        "name": "filter",
        "baseName": "filter",
        "type": "any"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20CredPreview {
    static getAttributeTypeMap() {
        return V20CredPreview.attributeTypeMap;
    }
}
exports.V20CredPreview = V20CredPreview;
V20CredPreview.discriminator = undefined;
V20CredPreview.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "attributes",
        "baseName": "attributes",
        "type": "Array<V20CredAttrSpec>"
    }
];
class V20CredProposal {
    static getAttributeTypeMap() {
        return V20CredProposal.attributeTypeMap;
    }
}
exports.V20CredProposal = V20CredProposal;
V20CredProposal.discriminator = undefined;
V20CredProposal.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "credential_preview",
        "baseName": "credential_preview",
        "type": "any"
    },
    {
        "name": "filtersattach",
        "baseName": "filters~attach",
        "type": "Array<AttachDecorator>"
    },
    {
        "name": "formats",
        "baseName": "formats",
        "type": "Array<V20CredFormat>"
    }
];
class V20CredRequest {
    static getAttributeTypeMap() {
        return V20CredRequest.attributeTypeMap;
    }
}
exports.V20CredRequest = V20CredRequest;
V20CredRequest.discriminator = undefined;
V20CredRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "formats",
        "baseName": "formats",
        "type": "Array<V20CredFormat>"
    },
    {
        "name": "requestsattach",
        "baseName": "requests~attach",
        "type": "Array<AttachDecorator>"
    }
];
class V20CredRequestFree {
    static getAttributeTypeMap() {
        return V20CredRequestFree.attributeTypeMap;
    }
}
exports.V20CredRequestFree = V20CredRequestFree;
V20CredRequestFree.discriminator = undefined;
V20CredRequestFree.attributeTypeMap = [
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "filter",
        "baseName": "filter",
        "type": "any"
    },
    {
        "name": "holder_did",
        "baseName": "holder_did",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20CredRequestRequest {
    static getAttributeTypeMap() {
        return V20CredRequestRequest.attributeTypeMap;
    }
}
exports.V20CredRequestRequest = V20CredRequestRequest;
V20CredRequestRequest.discriminator = undefined;
V20CredRequestRequest.attributeTypeMap = [
    {
        "name": "holder_did",
        "baseName": "holder_did",
        "type": "string"
    }
];
class V20CredStoreRequest {
    static getAttributeTypeMap() {
        return V20CredStoreRequest.attributeTypeMap;
    }
}
exports.V20CredStoreRequest = V20CredStoreRequest;
V20CredStoreRequest.discriminator = undefined;
V20CredStoreRequest.attributeTypeMap = [
    {
        "name": "credential_id",
        "baseName": "credential_id",
        "type": "string"
    }
];
class V20DiscoveryExchangeListResult {
    static getAttributeTypeMap() {
        return V20DiscoveryExchangeListResult.attributeTypeMap;
    }
}
exports.V20DiscoveryExchangeListResult = V20DiscoveryExchangeListResult;
V20DiscoveryExchangeListResult.discriminator = undefined;
V20DiscoveryExchangeListResult.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<any>"
    }
];
class V20DiscoveryExchangeResult {
    static getAttributeTypeMap() {
        return V20DiscoveryExchangeResult.attributeTypeMap;
    }
}
exports.V20DiscoveryExchangeResult = V20DiscoveryExchangeResult;
V20DiscoveryExchangeResult.discriminator = undefined;
V20DiscoveryExchangeResult.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "any"
    }
];
class V20DiscoveryRecord {
    static getAttributeTypeMap() {
        return V20DiscoveryRecord.attributeTypeMap;
    }
}
exports.V20DiscoveryRecord = V20DiscoveryRecord;
V20DiscoveryRecord.discriminator = undefined;
V20DiscoveryRecord.attributeTypeMap = [
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "disclosures",
        "baseName": "disclosures",
        "type": "any"
    },
    {
        "name": "discovery_exchange_id",
        "baseName": "discovery_exchange_id",
        "type": "string"
    },
    {
        "name": "queries_msg",
        "baseName": "queries_msg",
        "type": "any"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    }
];
class V20IssueCredSchemaCore {
    static getAttributeTypeMap() {
        return V20IssueCredSchemaCore.attributeTypeMap;
    }
}
exports.V20IssueCredSchemaCore = V20IssueCredSchemaCore;
V20IssueCredSchemaCore.discriminator = undefined;
V20IssueCredSchemaCore.attributeTypeMap = [
    {
        "name": "auto_remove",
        "baseName": "auto_remove",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "credential_preview",
        "baseName": "credential_preview",
        "type": "V20CredPreview"
    },
    {
        "name": "filter",
        "baseName": "filter",
        "type": "any"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20IssueCredentialModuleResponse {
    static getAttributeTypeMap() {
        return V20IssueCredentialModuleResponse.attributeTypeMap;
    }
}
exports.V20IssueCredentialModuleResponse = V20IssueCredentialModuleResponse;
V20IssueCredentialModuleResponse.discriminator = undefined;
V20IssueCredentialModuleResponse.attributeTypeMap = [];
class V20Pres {
    static getAttributeTypeMap() {
        return V20Pres.attributeTypeMap;
    }
}
exports.V20Pres = V20Pres;
V20Pres.discriminator = undefined;
V20Pres.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "formats",
        "baseName": "formats",
        "type": "Array<V20PresFormat>"
    },
    {
        "name": "presentationsattach",
        "baseName": "presentations~attach",
        "type": "Array<AttachDecorator>"
    }
];
class V20PresCreateRequestRequest {
    static getAttributeTypeMap() {
        return V20PresCreateRequestRequest.attributeTypeMap;
    }
}
exports.V20PresCreateRequestRequest = V20PresCreateRequestRequest;
V20PresCreateRequestRequest.discriminator = undefined;
V20PresCreateRequestRequest.attributeTypeMap = [
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "presentation_request",
        "baseName": "presentation_request",
        "type": "V20PresRequestByFormat"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20PresExRecord {
    static getAttributeTypeMap() {
        return V20PresExRecord.attributeTypeMap;
    }
}
exports.V20PresExRecord = V20PresExRecord;
V20PresExRecord.discriminator = undefined;
V20PresExRecord.attributeTypeMap = [
    {
        "name": "auto_present",
        "baseName": "auto_present",
        "type": "boolean"
    },
    {
        "name": "by_format",
        "baseName": "by_format",
        "type": "any"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "error_msg",
        "baseName": "error_msg",
        "type": "string"
    },
    {
        "name": "initiator",
        "baseName": "initiator",
        "type": "V20PresExRecord.InitiatorEnum"
    },
    {
        "name": "pres",
        "baseName": "pres",
        "type": "any"
    },
    {
        "name": "pres_ex_id",
        "baseName": "pres_ex_id",
        "type": "string"
    },
    {
        "name": "pres_proposal",
        "baseName": "pres_proposal",
        "type": "any"
    },
    {
        "name": "pres_request",
        "baseName": "pres_request",
        "type": "any"
    },
    {
        "name": "role",
        "baseName": "role",
        "type": "V20PresExRecord.RoleEnum"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "V20PresExRecord.StateEnum"
    },
    {
        "name": "thread_id",
        "baseName": "thread_id",
        "type": "string"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    },
    {
        "name": "verified",
        "baseName": "verified",
        "type": "V20PresExRecord.VerifiedEnum"
    }
];
(function (V20PresExRecord) {
    let InitiatorEnum;
    (function (InitiatorEnum) {
        InitiatorEnum[InitiatorEnum["Self"] = 'self'] = "Self";
        InitiatorEnum[InitiatorEnum["External"] = 'external'] = "External";
    })(InitiatorEnum = V20PresExRecord.InitiatorEnum || (V20PresExRecord.InitiatorEnum = {}));
    let RoleEnum;
    (function (RoleEnum) {
        RoleEnum[RoleEnum["Prover"] = 'prover'] = "Prover";
        RoleEnum[RoleEnum["Verifier"] = 'verifier'] = "Verifier";
    })(RoleEnum = V20PresExRecord.RoleEnum || (V20PresExRecord.RoleEnum = {}));
    let StateEnum;
    (function (StateEnum) {
        StateEnum[StateEnum["ProposalSent"] = 'proposal-sent'] = "ProposalSent";
        StateEnum[StateEnum["ProposalReceived"] = 'proposal-received'] = "ProposalReceived";
        StateEnum[StateEnum["RequestSent"] = 'request-sent'] = "RequestSent";
        StateEnum[StateEnum["RequestReceived"] = 'request-received'] = "RequestReceived";
        StateEnum[StateEnum["PresentationSent"] = 'presentation-sent'] = "PresentationSent";
        StateEnum[StateEnum["PresentationReceived"] = 'presentation-received'] = "PresentationReceived";
        StateEnum[StateEnum["Done"] = 'done'] = "Done";
        StateEnum[StateEnum["Abandoned"] = 'abandoned'] = "Abandoned";
    })(StateEnum = V20PresExRecord.StateEnum || (V20PresExRecord.StateEnum = {}));
    let VerifiedEnum;
    (function (VerifiedEnum) {
        VerifiedEnum[VerifiedEnum["True"] = 'true'] = "True";
        VerifiedEnum[VerifiedEnum["False"] = 'false'] = "False";
    })(VerifiedEnum = V20PresExRecord.VerifiedEnum || (V20PresExRecord.VerifiedEnum = {}));
})(V20PresExRecord = exports.V20PresExRecord || (exports.V20PresExRecord = {}));
class V20PresExRecordByFormat {
    static getAttributeTypeMap() {
        return V20PresExRecordByFormat.attributeTypeMap;
    }
}
exports.V20PresExRecordByFormat = V20PresExRecordByFormat;
V20PresExRecordByFormat.discriminator = undefined;
V20PresExRecordByFormat.attributeTypeMap = [
    {
        "name": "pres",
        "baseName": "pres",
        "type": "any"
    },
    {
        "name": "pres_proposal",
        "baseName": "pres_proposal",
        "type": "any"
    },
    {
        "name": "pres_request",
        "baseName": "pres_request",
        "type": "any"
    }
];
class V20PresExRecordList {
    static getAttributeTypeMap() {
        return V20PresExRecordList.attributeTypeMap;
    }
}
exports.V20PresExRecordList = V20PresExRecordList;
V20PresExRecordList.discriminator = undefined;
V20PresExRecordList.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<V20PresExRecord>"
    }
];
class V20PresFormat {
    static getAttributeTypeMap() {
        return V20PresFormat.attributeTypeMap;
    }
}
exports.V20PresFormat = V20PresFormat;
V20PresFormat.discriminator = undefined;
V20PresFormat.attributeTypeMap = [
    {
        "name": "attach_id",
        "baseName": "attach_id",
        "type": "string"
    },
    {
        "name": "format",
        "baseName": "format",
        "type": "string"
    }
];
class V20PresProblemReportRequest {
    static getAttributeTypeMap() {
        return V20PresProblemReportRequest.attributeTypeMap;
    }
}
exports.V20PresProblemReportRequest = V20PresProblemReportRequest;
V20PresProblemReportRequest.discriminator = undefined;
V20PresProblemReportRequest.attributeTypeMap = [
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    }
];
class V20PresProposal {
    static getAttributeTypeMap() {
        return V20PresProposal.attributeTypeMap;
    }
}
exports.V20PresProposal = V20PresProposal;
V20PresProposal.discriminator = undefined;
V20PresProposal.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "formats",
        "baseName": "formats",
        "type": "Array<V20PresFormat>"
    },
    {
        "name": "proposalsattach",
        "baseName": "proposals~attach",
        "type": "Array<AttachDecorator>"
    }
];
class V20PresProposalByFormat {
    static getAttributeTypeMap() {
        return V20PresProposalByFormat.attributeTypeMap;
    }
}
exports.V20PresProposalByFormat = V20PresProposalByFormat;
V20PresProposalByFormat.discriminator = undefined;
V20PresProposalByFormat.attributeTypeMap = [
    {
        "name": "dif",
        "baseName": "dif",
        "type": "any"
    },
    {
        "name": "indy",
        "baseName": "indy",
        "type": "any"
    }
];
class V20PresProposalRequest {
    static getAttributeTypeMap() {
        return V20PresProposalRequest.attributeTypeMap;
    }
}
exports.V20PresProposalRequest = V20PresProposalRequest;
V20PresProposalRequest.discriminator = undefined;
V20PresProposalRequest.attributeTypeMap = [
    {
        "name": "auto_present",
        "baseName": "auto_present",
        "type": "boolean"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "presentation_proposal",
        "baseName": "presentation_proposal",
        "type": "V20PresProposalByFormat"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20PresRequest {
    static getAttributeTypeMap() {
        return V20PresRequest.attributeTypeMap;
    }
}
exports.V20PresRequest = V20PresRequest;
V20PresRequest.discriminator = undefined;
V20PresRequest.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "@id",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "@type",
        "type": "string"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "formats",
        "baseName": "formats",
        "type": "Array<V20PresFormat>"
    },
    {
        "name": "request_presentationsattach",
        "baseName": "request_presentations~attach",
        "type": "Array<AttachDecorator>"
    },
    {
        "name": "will_confirm",
        "baseName": "will_confirm",
        "type": "boolean"
    }
];
class V20PresRequestByFormat {
    static getAttributeTypeMap() {
        return V20PresRequestByFormat.attributeTypeMap;
    }
}
exports.V20PresRequestByFormat = V20PresRequestByFormat;
V20PresRequestByFormat.discriminator = undefined;
V20PresRequestByFormat.attributeTypeMap = [
    {
        "name": "dif",
        "baseName": "dif",
        "type": "any"
    },
    {
        "name": "indy",
        "baseName": "indy",
        "type": "any"
    }
];
class V20PresSendRequestRequest {
    static getAttributeTypeMap() {
        return V20PresSendRequestRequest.attributeTypeMap;
    }
}
exports.V20PresSendRequestRequest = V20PresSendRequestRequest;
V20PresSendRequestRequest.discriminator = undefined;
V20PresSendRequestRequest.attributeTypeMap = [
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    },
    {
        "name": "connection_id",
        "baseName": "connection_id",
        "type": "string"
    },
    {
        "name": "presentation_request",
        "baseName": "presentation_request",
        "type": "V20PresRequestByFormat"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20PresSpecByFormatRequest {
    static getAttributeTypeMap() {
        return V20PresSpecByFormatRequest.attributeTypeMap;
    }
}
exports.V20PresSpecByFormatRequest = V20PresSpecByFormatRequest;
V20PresSpecByFormatRequest.discriminator = undefined;
V20PresSpecByFormatRequest.attributeTypeMap = [
    {
        "name": "dif",
        "baseName": "dif",
        "type": "any"
    },
    {
        "name": "indy",
        "baseName": "indy",
        "type": "any"
    },
    {
        "name": "trace",
        "baseName": "trace",
        "type": "boolean"
    }
];
class V20PresentProofModuleResponse {
    static getAttributeTypeMap() {
        return V20PresentProofModuleResponse.attributeTypeMap;
    }
}
exports.V20PresentProofModuleResponse = V20PresentProofModuleResponse;
V20PresentProofModuleResponse.discriminator = undefined;
V20PresentProofModuleResponse.attributeTypeMap = [];
class VCRecord {
    static getAttributeTypeMap() {
        return VCRecord.attributeTypeMap;
    }
}
exports.VCRecord = VCRecord;
VCRecord.discriminator = undefined;
VCRecord.attributeTypeMap = [
    {
        "name": "contexts",
        "baseName": "contexts",
        "type": "Array<string>"
    },
    {
        "name": "cred_tags",
        "baseName": "cred_tags",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "cred_value",
        "baseName": "cred_value",
        "type": "any"
    },
    {
        "name": "expanded_types",
        "baseName": "expanded_types",
        "type": "Array<string>"
    },
    {
        "name": "given_id",
        "baseName": "given_id",
        "type": "string"
    },
    {
        "name": "issuer_id",
        "baseName": "issuer_id",
        "type": "string"
    },
    {
        "name": "proof_types",
        "baseName": "proof_types",
        "type": "Array<string>"
    },
    {
        "name": "record_id",
        "baseName": "record_id",
        "type": "string"
    },
    {
        "name": "schema_ids",
        "baseName": "schema_ids",
        "type": "Array<string>"
    },
    {
        "name": "subject_ids",
        "baseName": "subject_ids",
        "type": "Array<string>"
    }
];
class VCRecordList {
    static getAttributeTypeMap() {
        return VCRecordList.attributeTypeMap;
    }
}
exports.VCRecordList = VCRecordList;
VCRecordList.discriminator = undefined;
VCRecordList.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<VCRecord>"
    }
];
class VerifyRequest {
    static getAttributeTypeMap() {
        return VerifyRequest.attributeTypeMap;
    }
}
exports.VerifyRequest = VerifyRequest;
VerifyRequest.discriminator = undefined;
VerifyRequest.attributeTypeMap = [
    {
        "name": "doc",
        "baseName": "doc",
        "type": "any"
    },
    {
        "name": "verkey",
        "baseName": "verkey",
        "type": "string"
    }
];
class VerifyResponse {
    static getAttributeTypeMap() {
        return VerifyResponse.attributeTypeMap;
    }
}
exports.VerifyResponse = VerifyResponse;
VerifyResponse.discriminator = undefined;
VerifyResponse.attributeTypeMap = [
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    },
    {
        "name": "valid",
        "baseName": "valid",
        "type": "boolean"
    }
];
class W3CCredentialsListRequest {
    static getAttributeTypeMap() {
        return W3CCredentialsListRequest.attributeTypeMap;
    }
}
exports.W3CCredentialsListRequest = W3CCredentialsListRequest;
W3CCredentialsListRequest.discriminator = undefined;
W3CCredentialsListRequest.attributeTypeMap = [
    {
        "name": "contexts",
        "baseName": "contexts",
        "type": "Array<string>"
    },
    {
        "name": "given_id",
        "baseName": "given_id",
        "type": "string"
    },
    {
        "name": "issuer_id",
        "baseName": "issuer_id",
        "type": "string"
    },
    {
        "name": "max_results",
        "baseName": "max_results",
        "type": "number"
    },
    {
        "name": "proof_types",
        "baseName": "proof_types",
        "type": "Array<string>"
    },
    {
        "name": "schema_ids",
        "baseName": "schema_ids",
        "type": "Array<string>"
    },
    {
        "name": "subject_ids",
        "baseName": "subject_ids",
        "type": "Array<string>"
    },
    {
        "name": "tag_query",
        "baseName": "tag_query",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "types",
        "baseName": "types",
        "type": "Array<string>"
    }
];
class WalletList {
    static getAttributeTypeMap() {
        return WalletList.attributeTypeMap;
    }
}
exports.WalletList = WalletList;
WalletList.discriminator = undefined;
WalletList.attributeTypeMap = [
    {
        "name": "results",
        "baseName": "results",
        "type": "Array<WalletRecord>"
    }
];
class WalletModuleResponse {
    static getAttributeTypeMap() {
        return WalletModuleResponse.attributeTypeMap;
    }
}
exports.WalletModuleResponse = WalletModuleResponse;
WalletModuleResponse.discriminator = undefined;
WalletModuleResponse.attributeTypeMap = [];
class WalletRecord {
    static getAttributeTypeMap() {
        return WalletRecord.attributeTypeMap;
    }
}
exports.WalletRecord = WalletRecord;
WalletRecord.discriminator = undefined;
WalletRecord.attributeTypeMap = [
    {
        "name": "created_at",
        "baseName": "created_at",
        "type": "string"
    },
    {
        "name": "key_management_mode",
        "baseName": "key_management_mode",
        "type": "WalletRecord.KeyManagementModeEnum"
    },
    {
        "name": "settings",
        "baseName": "settings",
        "type": "any"
    },
    {
        "name": "state",
        "baseName": "state",
        "type": "string"
    },
    {
        "name": "updated_at",
        "baseName": "updated_at",
        "type": "string"
    },
    {
        "name": "wallet_id",
        "baseName": "wallet_id",
        "type": "string"
    }
];
(function (WalletRecord) {
    let KeyManagementModeEnum;
    (function (KeyManagementModeEnum) {
        KeyManagementModeEnum[KeyManagementModeEnum["Managed"] = 'managed'] = "Managed";
        KeyManagementModeEnum[KeyManagementModeEnum["Unmanaged"] = 'unmanaged'] = "Unmanaged";
    })(KeyManagementModeEnum = WalletRecord.KeyManagementModeEnum || (WalletRecord.KeyManagementModeEnum = {}));
})(WalletRecord = exports.WalletRecord || (exports.WalletRecord = {}));
class WriteLedgerRequest {
    static getAttributeTypeMap() {
        return WriteLedgerRequest.attributeTypeMap;
    }
}
exports.WriteLedgerRequest = WriteLedgerRequest;
WriteLedgerRequest.discriminator = undefined;
WriteLedgerRequest.attributeTypeMap = [
    {
        "name": "ledger_id",
        "baseName": "ledger_id",
        "type": "string"
    }
];
let enumsMap = {
    "AttachmentDef.TypeEnum": AttachmentDef.TypeEnum,
    "ConnRecord.AcceptEnum": ConnRecord.AcceptEnum,
    "ConnRecord.ConnectionProtocolEnum": ConnRecord.ConnectionProtocolEnum,
    "ConnRecord.InvitationModeEnum": ConnRecord.InvitationModeEnum,
    "ConnRecord.RoutingStateEnum": ConnRecord.RoutingStateEnum,
    "ConnRecord.TheirRoleEnum": ConnRecord.TheirRoleEnum,
    "Constraints.StatusActiveEnum": Constraints.StatusActiveEnum,
    "Constraints.StatusRevokedEnum": Constraints.StatusRevokedEnum,
    "Constraints.StatusSuspendedEnum": Constraints.StatusSuspendedEnum,
    "Constraints.SubjectIsIssuerEnum": Constraints.SubjectIsIssuerEnum,
    "CreateWalletRequest.KeyManagementModeEnum": CreateWalletRequest.KeyManagementModeEnum,
    "CreateWalletRequest.WalletDispatchTypeEnum": CreateWalletRequest.WalletDispatchTypeEnum,
    "CreateWalletRequest.WalletTypeEnum": CreateWalletRequest.WalletTypeEnum,
    "CreateWalletResponse.KeyManagementModeEnum": CreateWalletResponse.KeyManagementModeEnum,
    "DID.KeyTypeEnum": DID.KeyTypeEnum,
    "DID.MethodEnum": DID.MethodEnum,
    "DID.PostureEnum": DID.PostureEnum,
    "DIDCreate.MethodEnum": DIDCreate.MethodEnum,
    "DIDCreateOptions.KeyTypeEnum": DIDCreateOptions.KeyTypeEnum,
    "DIDEndpointWithType.EndpointTypeEnum": DIDEndpointWithType.EndpointTypeEnum,
    "DIFField.PredicateEnum": DIFField.PredicateEnum,
    "DIFHolder.DirectiveEnum": DIFHolder.DirectiveEnum,
    "GetNymRoleResponse.RoleEnum": GetNymRoleResponse.RoleEnum,
    "IndyGEProofPred.PTypeEnum": IndyGEProofPred.PTypeEnum,
    "IndyPresPredSpec.PredicateEnum": IndyPresPredSpec.PredicateEnum,
    "IndyProofReqPredSpec.PTypeEnum": IndyProofReqPredSpec.PTypeEnum,
    "IndyRevRegDef.RevocDefTypeEnum": IndyRevRegDef.RevocDefTypeEnum,
    "IndyRevRegDefValue.IssuanceTypeEnum": IndyRevRegDefValue.IssuanceTypeEnum,
    "IssuerRevRegRecord.RevocDefTypeEnum": IssuerRevRegRecord.RevocDefTypeEnum,
    "KeylistUpdateRule.ActionEnum": KeylistUpdateRule.ActionEnum,
    "QueryItem.FeatureTypeEnum": QueryItem.FeatureTypeEnum,
    "SubmissionRequirements.RuleEnum": SubmissionRequirements.RuleEnum,
    "TransactionJobs.TransactionMyJobEnum": TransactionJobs.TransactionMyJobEnum,
    "TransactionJobs.TransactionTheirJobEnum": TransactionJobs.TransactionTheirJobEnum,
    "UpdateWalletRequest.WalletDispatchTypeEnum": UpdateWalletRequest.WalletDispatchTypeEnum,
    "V10CredentialExchange.InitiatorEnum": V10CredentialExchange.InitiatorEnum,
    "V10CredentialExchange.RoleEnum": V10CredentialExchange.RoleEnum,
    "V10PresentationExchange.InitiatorEnum": V10PresentationExchange.InitiatorEnum,
    "V10PresentationExchange.RoleEnum": V10PresentationExchange.RoleEnum,
    "V10PresentationExchange.VerifiedEnum": V10PresentationExchange.VerifiedEnum,
    "V20CredExRecord.InitiatorEnum": V20CredExRecord.InitiatorEnum,
    "V20CredExRecord.RoleEnum": V20CredExRecord.RoleEnum,
    "V20CredExRecord.StateEnum": V20CredExRecord.StateEnum,
    "V20PresExRecord.InitiatorEnum": V20PresExRecord.InitiatorEnum,
    "V20PresExRecord.RoleEnum": V20PresExRecord.RoleEnum,
    "V20PresExRecord.StateEnum": V20PresExRecord.StateEnum,
    "V20PresExRecord.VerifiedEnum": V20PresExRecord.VerifiedEnum,
    "WalletRecord.KeyManagementModeEnum": WalletRecord.KeyManagementModeEnum,
};
let typeMap = {
    "AMLRecord": AMLRecord,
    "ActionMenuFetchResult": ActionMenuFetchResult,
    "ActionMenuModulesResult": ActionMenuModulesResult,
    "AdminAPIMessageTracing": AdminAPIMessageTracing,
    "AdminConfig": AdminConfig,
    "AdminMediationDeny": AdminMediationDeny,
    "AdminModules": AdminModules,
    "AdminReset": AdminReset,
    "AdminShutdown": AdminShutdown,
    "AdminStatus": AdminStatus,
    "AdminStatusLiveliness": AdminStatusLiveliness,
    "AdminStatusReadiness": AdminStatusReadiness,
    "AttachDecorator": AttachDecorator,
    "AttachDecoratorData": AttachDecoratorData,
    "AttachDecoratorData1JWS": AttachDecoratorData1JWS,
    "AttachDecoratorDataJWS": AttachDecoratorDataJWS,
    "AttachDecoratorDataJWSHeader": AttachDecoratorDataJWSHeader,
    "AttachmentDef": AttachmentDef,
    "AttributeMimeTypesResult": AttributeMimeTypesResult,
    "BasicMessageModuleResponse": BasicMessageModuleResponse,
    "ClaimFormat": ClaimFormat,
    "ClearPendingRevocationsRequest": ClearPendingRevocationsRequest,
    "ConnRecord": ConnRecord,
    "ConnectionInvitation": ConnectionInvitation,
    "ConnectionList": ConnectionList,
    "ConnectionMetadata": ConnectionMetadata,
    "ConnectionMetadataSetRequest": ConnectionMetadataSetRequest,
    "ConnectionModuleResponse": ConnectionModuleResponse,
    "ConnectionStaticRequest": ConnectionStaticRequest,
    "ConnectionStaticResult": ConnectionStaticResult,
    "Constraints": Constraints,
    "CreateInvitationRequest": CreateInvitationRequest,
    "CreateWalletRequest": CreateWalletRequest,
    "CreateWalletResponse": CreateWalletResponse,
    "CreateWalletTokenRequest": CreateWalletTokenRequest,
    "CreateWalletTokenResponse": CreateWalletTokenResponse,
    "CredAttrSpec": CredAttrSpec,
    "CredDefValue": CredDefValue,
    "CredDefValuePrimary": CredDefValuePrimary,
    "CredDefValueRevocation": CredDefValueRevocation,
    "CredInfoList": CredInfoList,
    "CredRevRecordResult": CredRevRecordResult,
    "CredRevokedResult": CredRevokedResult,
    "Credential": Credential,
    "CredentialDefinition": CredentialDefinition,
    "CredentialDefinitionGetResult": CredentialDefinitionGetResult,
    "CredentialDefinitionSendRequest": CredentialDefinitionSendRequest,
    "CredentialDefinitionSendResult": CredentialDefinitionSendResult,
    "CredentialDefinitionsCreatedResult": CredentialDefinitionsCreatedResult,
    "CredentialOffer": CredentialOffer,
    "CredentialPreview": CredentialPreview,
    "CredentialProposal": CredentialProposal,
    "CredentialStatusOptions": CredentialStatusOptions,
    "DID": DID,
    "DIDCreate": DIDCreate,
    "DIDCreateOptions": DIDCreateOptions,
    "DIDEndpoint": DIDEndpoint,
    "DIDEndpointWithType": DIDEndpointWithType,
    "DIDList": DIDList,
    "DIDResult": DIDResult,
    "DIDXRequest": DIDXRequest,
    "DIFField": DIFField,
    "DIFHolder": DIFHolder,
    "DIFOptions": DIFOptions,
    "DIFPresSpec": DIFPresSpec,
    "DIFProofProposal": DIFProofProposal,
    "DIFProofRequest": DIFProofRequest,
    "Disclose": Disclose,
    "Disclosures": Disclosures,
    "Doc": Doc,
    "EndorserInfo": EndorserInfo,
    "EndpointsResult": EndpointsResult,
    "Filter": Filter,
    "Generated": Generated,
    "GetDIDEndpointResponse": GetDIDEndpointResponse,
    "GetDIDVerkeyResponse": GetDIDVerkeyResponse,
    "GetNymRoleResponse": GetNymRoleResponse,
    "HolderModuleResponse": HolderModuleResponse,
    "IndyAttrValue": IndyAttrValue,
    "IndyCredAbstract": IndyCredAbstract,
    "IndyCredInfo": IndyCredInfo,
    "IndyCredPrecis": IndyCredPrecis,
    "IndyCredRequest": IndyCredRequest,
    "IndyCredential": IndyCredential,
    "IndyEQProof": IndyEQProof,
    "IndyGEProof": IndyGEProof,
    "IndyGEProofPred": IndyGEProofPred,
    "IndyKeyCorrectnessProof": IndyKeyCorrectnessProof,
    "IndyNonRevocProof": IndyNonRevocProof,
    "IndyNonRevocationInterval": IndyNonRevocationInterval,
    "IndyPresAttrSpec": IndyPresAttrSpec,
    "IndyPresPredSpec": IndyPresPredSpec,
    "IndyPresPreview": IndyPresPreview,
    "IndyPresSpec": IndyPresSpec,
    "IndyPrimaryProof": IndyPrimaryProof,
    "IndyProof": IndyProof,
    "IndyProofIdentifier": IndyProofIdentifier,
    "IndyProofProof": IndyProofProof,
    "IndyProofProofAggregatedProof": IndyProofProofAggregatedProof,
    "IndyProofProofProofsProof": IndyProofProofProofsProof,
    "IndyProofReqAttrSpec": IndyProofReqAttrSpec,
    "IndyProofReqAttrSpecNonRevoked": IndyProofReqAttrSpecNonRevoked,
    "IndyProofReqPredSpec": IndyProofReqPredSpec,
    "IndyProofReqPredSpecNonRevoked": IndyProofReqPredSpecNonRevoked,
    "IndyProofRequest": IndyProofRequest,
    "IndyProofRequestNonRevoked": IndyProofRequestNonRevoked,
    "IndyProofRequestedProof": IndyProofRequestedProof,
    "IndyProofRequestedProofPredicate": IndyProofRequestedProofPredicate,
    "IndyProofRequestedProofRevealedAttr": IndyProofRequestedProofRevealedAttr,
    "IndyProofRequestedProofRevealedAttrGroup": IndyProofRequestedProofRevealedAttrGroup,
    "IndyRequestedCredsRequestedAttr": IndyRequestedCredsRequestedAttr,
    "IndyRequestedCredsRequestedPred": IndyRequestedCredsRequestedPred,
    "IndyRevRegDef": IndyRevRegDef,
    "IndyRevRegDefValue": IndyRevRegDefValue,
    "IndyRevRegDefValuePublicKeys": IndyRevRegDefValuePublicKeys,
    "IndyRevRegDefValuePublicKeysAccumKey": IndyRevRegDefValuePublicKeysAccumKey,
    "IndyRevRegEntry": IndyRevRegEntry,
    "IndyRevRegEntryValue": IndyRevRegEntryValue,
    "InputDescriptors": InputDescriptors,
    "IntroModuleResponse": IntroModuleResponse,
    "InvitationCreateRequest": InvitationCreateRequest,
    "InvitationMessage": InvitationMessage,
    "InvitationRecord": InvitationRecord,
    "InvitationResult": InvitationResult,
    "IssueCredentialModuleResponse": IssueCredentialModuleResponse,
    "IssuerCredRevRecord": IssuerCredRevRecord,
    "IssuerRevRegRecord": IssuerRevRegRecord,
    "Keylist": Keylist,
    "KeylistQuery": KeylistQuery,
    "KeylistQueryFilterRequest": KeylistQueryFilterRequest,
    "KeylistQueryPaginate": KeylistQueryPaginate,
    "KeylistUpdate": KeylistUpdate,
    "KeylistUpdateRequest": KeylistUpdateRequest,
    "KeylistUpdateRule": KeylistUpdateRule,
    "LDProofVCDetail": LDProofVCDetail,
    "LDProofVCDetailOptions": LDProofVCDetailOptions,
    "LedgerConfigInstance": LedgerConfigInstance,
    "LedgerConfigList": LedgerConfigList,
    "LedgerModulesResult": LedgerModulesResult,
    "LinkedDataProof": LinkedDataProof,
    "MediationCreateRequest": MediationCreateRequest,
    "MediationDeny": MediationDeny,
    "MediationGrant": MediationGrant,
    "MediationList": MediationList,
    "MediationRecord": MediationRecord,
    "Menu": Menu,
    "MenuForm": MenuForm,
    "MenuFormParam": MenuFormParam,
    "MenuJson": MenuJson,
    "MenuOption": MenuOption,
    "ModelDate": ModelDate,
    "MultitenantModuleResponse": MultitenantModuleResponse,
    "PerformRequest": PerformRequest,
    "PingRequest": PingRequest,
    "PingRequestResponse": PingRequestResponse,
    "PresentationDefinition": PresentationDefinition,
    "PresentationProposal": PresentationProposal,
    "PresentationRequest": PresentationRequest,
    "ProtocolDescriptor": ProtocolDescriptor,
    "PublishRevocations": PublishRevocations,
    "Queries": Queries,
    "Query": Query,
    "QueryItem": QueryItem,
    "QuestionRequest": QuestionRequest,
    "QuestionRequestResponse": QuestionRequestResponse,
    "RawEncoded": RawEncoded,
    "ReceiveInvitationRequest": ReceiveInvitationRequest,
    "RegisterLedgerNymResponse": RegisterLedgerNymResponse,
    "RemoveWalletRequest": RemoveWalletRequest,
    "ResolutionResult": ResolutionResult,
    "RevRegCreateRequest": RevRegCreateRequest,
    "RevRegIssuedResult": RevRegIssuedResult,
    "RevRegResult": RevRegResult,
    "RevRegUpdateTailsFileUri": RevRegUpdateTailsFileUri,
    "RevRegsCreated": RevRegsCreated,
    "RevocationModuleResponse": RevocationModuleResponse,
    "RevokeRequest": RevokeRequest,
    "RouteRecord": RouteRecord,
    "Schema": Schema,
    "SchemaGetResult": SchemaGetResult,
    "SchemaInputDescriptor": SchemaInputDescriptor,
    "SchemaSendRequest": SchemaSendRequest,
    "SchemaSendResult": SchemaSendResult,
    "SchemasCreatedResult": SchemasCreatedResult,
    "SchemasInputDescriptorFilter": SchemasInputDescriptorFilter,
    "SendMenu": SendMenu,
    "SendMessage": SendMessage,
    "SignRequest": SignRequest,
    "SignResponse": SignResponse,
    "SignatureOptions": SignatureOptions,
    "SignedDoc": SignedDoc,
    "SubmissionRequirements": SubmissionRequirements,
    "TAAAccept": TAAAccept,
    "TAAAcceptance": TAAAcceptance,
    "TAAInfo": TAAInfo,
    "TAARecord": TAARecord,
    "TAAResult": TAAResult,
    "TransactionJobs": TransactionJobs,
    "TransactionList": TransactionList,
    "TransactionRecord": TransactionRecord,
    "TxnOrCredentialDefinitionSendResult": TxnOrCredentialDefinitionSendResult,
    "TxnOrPublishRevocationsResult": TxnOrPublishRevocationsResult,
    "TxnOrRevRegResult": TxnOrRevRegResult,
    "TxnOrSchemaSendResult": TxnOrSchemaSendResult,
    "UpdateWalletRequest": UpdateWalletRequest,
    "V10CredentialBoundOfferRequest": V10CredentialBoundOfferRequest,
    "V10CredentialConnFreeOfferRequest": V10CredentialConnFreeOfferRequest,
    "V10CredentialCreate": V10CredentialCreate,
    "V10CredentialExchange": V10CredentialExchange,
    "V10CredentialExchangeListResult": V10CredentialExchangeListResult,
    "V10CredentialFreeOfferRequest": V10CredentialFreeOfferRequest,
    "V10CredentialIssueRequest": V10CredentialIssueRequest,
    "V10CredentialProblemReportRequest": V10CredentialProblemReportRequest,
    "V10CredentialProposalRequestMand": V10CredentialProposalRequestMand,
    "V10CredentialProposalRequestOpt": V10CredentialProposalRequestOpt,
    "V10CredentialStoreRequest": V10CredentialStoreRequest,
    "V10DiscoveryExchangeListResult": V10DiscoveryExchangeListResult,
    "V10DiscoveryExchangeResult": V10DiscoveryExchangeResult,
    "V10DiscoveryRecord": V10DiscoveryRecord,
    "V10PresentProofModuleResponse": V10PresentProofModuleResponse,
    "V10PresentationCreateRequestRequest": V10PresentationCreateRequestRequest,
    "V10PresentationExchange": V10PresentationExchange,
    "V10PresentationExchangeList": V10PresentationExchangeList,
    "V10PresentationProblemReportRequest": V10PresentationProblemReportRequest,
    "V10PresentationProposalRequest": V10PresentationProposalRequest,
    "V10PresentationSendRequestRequest": V10PresentationSendRequestRequest,
    "V20CredAttrSpec": V20CredAttrSpec,
    "V20CredBoundOfferRequest": V20CredBoundOfferRequest,
    "V20CredExFree": V20CredExFree,
    "V20CredExRecord": V20CredExRecord,
    "V20CredExRecordByFormat": V20CredExRecordByFormat,
    "V20CredExRecordDetail": V20CredExRecordDetail,
    "V20CredExRecordIndy": V20CredExRecordIndy,
    "V20CredExRecordLDProof": V20CredExRecordLDProof,
    "V20CredExRecordListResult": V20CredExRecordListResult,
    "V20CredFilter": V20CredFilter,
    "V20CredFilterIndy": V20CredFilterIndy,
    "V20CredFilterLDProof": V20CredFilterLDProof,
    "V20CredFormat": V20CredFormat,
    "V20CredIssue": V20CredIssue,
    "V20CredIssueProblemReportRequest": V20CredIssueProblemReportRequest,
    "V20CredIssueRequest": V20CredIssueRequest,
    "V20CredOffer": V20CredOffer,
    "V20CredOfferConnFreeRequest": V20CredOfferConnFreeRequest,
    "V20CredOfferRequest": V20CredOfferRequest,
    "V20CredPreview": V20CredPreview,
    "V20CredProposal": V20CredProposal,
    "V20CredRequest": V20CredRequest,
    "V20CredRequestFree": V20CredRequestFree,
    "V20CredRequestRequest": V20CredRequestRequest,
    "V20CredStoreRequest": V20CredStoreRequest,
    "V20DiscoveryExchangeListResult": V20DiscoveryExchangeListResult,
    "V20DiscoveryExchangeResult": V20DiscoveryExchangeResult,
    "V20DiscoveryRecord": V20DiscoveryRecord,
    "V20IssueCredSchemaCore": V20IssueCredSchemaCore,
    "V20IssueCredentialModuleResponse": V20IssueCredentialModuleResponse,
    "V20Pres": V20Pres,
    "V20PresCreateRequestRequest": V20PresCreateRequestRequest,
    "V20PresExRecord": V20PresExRecord,
    "V20PresExRecordByFormat": V20PresExRecordByFormat,
    "V20PresExRecordList": V20PresExRecordList,
    "V20PresFormat": V20PresFormat,
    "V20PresProblemReportRequest": V20PresProblemReportRequest,
    "V20PresProposal": V20PresProposal,
    "V20PresProposalByFormat": V20PresProposalByFormat,
    "V20PresProposalRequest": V20PresProposalRequest,
    "V20PresRequest": V20PresRequest,
    "V20PresRequestByFormat": V20PresRequestByFormat,
    "V20PresSendRequestRequest": V20PresSendRequestRequest,
    "V20PresSpecByFormatRequest": V20PresSpecByFormatRequest,
    "V20PresentProofModuleResponse": V20PresentProofModuleResponse,
    "VCRecord": VCRecord,
    "VCRecordList": VCRecordList,
    "VerifyRequest": VerifyRequest,
    "VerifyResponse": VerifyResponse,
    "W3CCredentialsListRequest": W3CCredentialsListRequest,
    "WalletList": WalletList,
    "WalletModuleResponse": WalletModuleResponse,
    "WalletRecord": WalletRecord,
    "WriteLedgerRequest": WriteLedgerRequest,
};
class HttpBasicAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    constructor() {
        this.accessToken = '';
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(_) {
        // Do nothing
    }
}
exports.VoidAuth = VoidAuth;
var ActionMenuApiApiKeys;
(function (ActionMenuApiApiKeys) {
    ActionMenuApiApiKeys[ActionMenuApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(ActionMenuApiApiKeys = exports.ActionMenuApiApiKeys || (exports.ActionMenuApiApiKeys = {}));
class ActionMenuApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ActionMenuApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Close the active menu associated with a connection
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    actionMenuConnIdClosePost(conn_id, options = {}) {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/close'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdClosePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch the active menu
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    actionMenuConnIdFetchPost(conn_id, options = {}) {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/fetch'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdFetchPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuFetchResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Perform an action associated with the active menu
     * @param conn_id Connection identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    actionMenuConnIdPerformPost(conn_id, body, options = {}) {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/perform'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdPerformPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PerformRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Request the active menu
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    actionMenuConnIdRequestPost(conn_id, options = {}) {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/request'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdRequestPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send an action menu to a connection
     * @param conn_id Connection identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    actionMenuConnIdSendMenuPost(conn_id, body, options = {}) {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/send-menu'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdSendMenuPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SendMenu")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ActionMenuApi = ActionMenuApi;
var BasicmessageApiApiKeys;
(function (BasicmessageApiApiKeys) {
    BasicmessageApiApiKeys[BasicmessageApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(BasicmessageApiApiKeys = exports.BasicmessageApiApiKeys || (exports.BasicmessageApiApiKeys = {}));
class BasicmessageApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[BasicmessageApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Send a basic message to a connection
     * @param conn_id Connection identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdSendMessagePost(conn_id, body, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}/send-message'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdSendMessagePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SendMessage")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "BasicMessageModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.BasicmessageApi = BasicmessageApi;
var ConnectionApiApiKeys;
(function (ConnectionApiApiKeys) {
    ConnectionApiApiKeys[ConnectionApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(ConnectionApiApiKeys = exports.ConnectionApiApiKeys || (exports.ConnectionApiApiKeys = {}));
class ConnectionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ConnectionApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Accept a stored connection invitation
     * @param conn_id Connection identifier
     * @param mediation_id Identifier for active mediation record to be used
     * @param my_endpoint My URL endpoint
     * @param my_label Label for connection
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdAcceptInvitationPost(conn_id, mediation_id, my_endpoint, my_label, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}/accept-invitation'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdAcceptInvitationPost.');
        }
        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }
        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }
        if (my_label !== undefined) {
            localVarQueryParameters['my_label'] = ObjectSerializer.serialize(my_label, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Accept a stored connection request
     * @param conn_id Connection identifier
     * @param my_endpoint My URL endpoint
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdAcceptRequestPost(conn_id, my_endpoint, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}/accept-request'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdAcceptRequestPost.');
        }
        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove an existing connection record
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdDelete(conn_id, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnectionModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch connection remote endpoint
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdEndpointsGet(conn_id, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}/endpoints'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdEndpointsGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "EndpointsResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Assign another connection as the inbound connection
     * @param conn_id Connection identifier
     * @param ref_id Inbound connection identifier
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdEstablishInboundRefIdPost(conn_id, ref_id, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}/establish-inbound/{ref_id}'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)))
            .replace('{' + 'ref_id' + '}', encodeURIComponent(String(ref_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdEstablishInboundRefIdPost.');
        }
        // verify required parameter 'ref_id' is not null or undefined
        if (ref_id === null || ref_id === undefined) {
            throw new Error('Required parameter ref_id was null or undefined when calling connectionsConnIdEstablishInboundRefIdPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnectionModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch a single connection record
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdGet(conn_id, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch connection metadata
     * @param conn_id Connection identifier
     * @param key Key to retrieve.
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdMetadataGet(conn_id, key, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}/metadata'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdMetadataGet.');
        }
        if (key !== undefined) {
            localVarQueryParameters['key'] = ObjectSerializer.serialize(key, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnectionMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Set connection metadata
     * @param conn_id Connection identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdMetadataPost(conn_id, body, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}/metadata'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdMetadataPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ConnectionMetadataSetRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnectionMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Create a new connection invitation
     * @param body
     * @param alias Alias
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param multi_use Create invitation for multiple use (default false)
     * @param _public Create invitation from public DID (default false)
     * @param {*} [options] Override http request options.
     */
    connectionsCreateInvitationPost(body, alias, auto_accept, multi_use, _public, options = {}) {
        const localVarPath = this.basePath + '/connections/create-invitation';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }
        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }
        if (multi_use !== undefined) {
            localVarQueryParameters['multi_use'] = ObjectSerializer.serialize(multi_use, "boolean");
        }
        if (_public !== undefined) {
            localVarQueryParameters['public'] = ObjectSerializer.serialize(_public, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateInvitationRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "InvitationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Create a new static connection
     * @param body
     * @param {*} [options] Override http request options.
     */
    connectionsCreateStaticPost(body, options = {}) {
        const localVarPath = this.basePath + '/connections/create-static';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ConnectionStaticRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnectionStaticResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Query agent-to-agent connections
     * @param alias Alias
     * @param connection_protocol Connection protocol used
     * @param invitation_key invitation key
     * @param my_did My DID
     * @param state Connection state
     * @param their_did Their DID
     * @param their_role Their role in the connection protocol
     * @param {*} [options] Override http request options.
     */
    connectionsGet(alias, connection_protocol, invitation_key, my_did, state, their_did, their_role, options = {}) {
        const localVarPath = this.basePath + '/connections';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }
        if (connection_protocol !== undefined) {
            localVarQueryParameters['connection_protocol'] = ObjectSerializer.serialize(connection_protocol, "'connections/1.0' | 'didexchange/1.0'");
        }
        if (invitation_key !== undefined) {
            localVarQueryParameters['invitation_key'] = ObjectSerializer.serialize(invitation_key, "string");
        }
        if (my_did !== undefined) {
            localVarQueryParameters['my_did'] = ObjectSerializer.serialize(my_did, "string");
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'request' | 'start' | 'invitation' | 'abandoned' | 'completed' | 'response' | 'error' | 'active' | 'init'");
        }
        if (their_did !== undefined) {
            localVarQueryParameters['their_did'] = ObjectSerializer.serialize(their_did, "string");
        }
        if (their_role !== undefined) {
            localVarQueryParameters['their_role'] = ObjectSerializer.serialize(their_role, "'invitee' | 'requester' | 'inviter' | 'responder'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnectionList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Receive a new connection invitation
     * @param body
     * @param alias Alias
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param mediation_id Identifier for active mediation record to be used
     * @param {*} [options] Override http request options.
     */
    connectionsReceiveInvitationPost(body, alias, auto_accept, mediation_id, options = {}) {
        const localVarPath = this.basePath + '/connections/receive-invitation';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }
        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }
        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ReceiveInvitationRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ConnectionApi = ConnectionApi;
var CredentialDefinitionApiApiKeys;
(function (CredentialDefinitionApiApiKeys) {
    CredentialDefinitionApiApiKeys[CredentialDefinitionApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(CredentialDefinitionApiApiKeys = exports.CredentialDefinitionApiApiKeys || (exports.CredentialDefinitionApiApiKeys = {}));
class CredentialDefinitionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[CredentialDefinitionApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Search for matching credential definitions that agent originated
     * @param cred_def_id Credential definition id
     * @param issuer_did Issuer DID
     * @param schema_id Schema identifier
     * @param schema_issuer_did Schema issuer DID
     * @param schema_name Schema name
     * @param schema_version Schema version
     * @param {*} [options] Override http request options.
     */
    credentialDefinitionsCreatedGet(cred_def_id, issuer_did, schema_id, schema_issuer_did, schema_name, schema_version, options = {}) {
        const localVarPath = this.basePath + '/credential-definitions/created';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (cred_def_id !== undefined) {
            localVarQueryParameters['cred_def_id'] = ObjectSerializer.serialize(cred_def_id, "string");
        }
        if (issuer_did !== undefined) {
            localVarQueryParameters['issuer_did'] = ObjectSerializer.serialize(issuer_did, "string");
        }
        if (schema_id !== undefined) {
            localVarQueryParameters['schema_id'] = ObjectSerializer.serialize(schema_id, "string");
        }
        if (schema_issuer_did !== undefined) {
            localVarQueryParameters['schema_issuer_did'] = ObjectSerializer.serialize(schema_issuer_did, "string");
        }
        if (schema_name !== undefined) {
            localVarQueryParameters['schema_name'] = ObjectSerializer.serialize(schema_name, "string");
        }
        if (schema_version !== undefined) {
            localVarQueryParameters['schema_version'] = ObjectSerializer.serialize(schema_version, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CredentialDefinitionsCreatedResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Gets a credential definition from the ledger
     * @param cred_def_id Credential definition identifier
     * @param {*} [options] Override http request options.
     */
    credentialDefinitionsCredDefIdGet(cred_def_id, options = {}) {
        const localVarPath = this.basePath + '/credential-definitions/{cred_def_id}'
            .replace('{' + 'cred_def_id' + '}', encodeURIComponent(String(cred_def_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_def_id' is not null or undefined
        if (cred_def_id === null || cred_def_id === undefined) {
            throw new Error('Required parameter cred_def_id was null or undefined when calling credentialDefinitionsCredDefIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CredentialDefinitionGetResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Writes a credential definition non-secret record to the wallet
     * @param cred_def_id Credential definition identifier
     * @param {*} [options] Override http request options.
     */
    credentialDefinitionsCredDefIdWriteRecordPost(cred_def_id, options = {}) {
        const localVarPath = this.basePath + '/credential-definitions/{cred_def_id}/write_record'
            .replace('{' + 'cred_def_id' + '}', encodeURIComponent(String(cred_def_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_def_id' is not null or undefined
        if (cred_def_id === null || cred_def_id === undefined) {
            throw new Error('Required parameter cred_def_id was null or undefined when calling credentialDefinitionsCredDefIdWriteRecordPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CredentialDefinitionGetResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a credential definition to the ledger
     * @param body
     * @param conn_id Connection identifier
     * @param create_transaction_for_endorser Create Transaction For Endorser&#39;s signature
     * @param {*} [options] Override http request options.
     */
    credentialDefinitionsPost(body, conn_id, create_transaction_for_endorser, options = {}) {
        const localVarPath = this.basePath + '/credential-definitions';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }
        if (create_transaction_for_endorser !== undefined) {
            localVarQueryParameters['create_transaction_for_endorser'] = ObjectSerializer.serialize(create_transaction_for_endorser, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CredentialDefinitionSendRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TxnOrCredentialDefinitionSendResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.CredentialDefinitionApi = CredentialDefinitionApi;
var CredentialsApiApiKeys;
(function (CredentialsApiApiKeys) {
    CredentialsApiApiKeys[CredentialsApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(CredentialsApiApiKeys = exports.CredentialsApiApiKeys || (exports.CredentialsApiApiKeys = {}));
class CredentialsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[CredentialsApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Remove credential from wallet by id
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    credentialCredentialIdDelete(credential_id, options = {}) {
        const localVarPath = this.basePath + '/credential/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialCredentialIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "HolderModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch credential from wallet by id
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    credentialCredentialIdGet(credential_id, options = {}) {
        const localVarPath = this.basePath + '/credential/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialCredentialIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "IndyCredInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get attribute MIME types from wallet
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    credentialMimeTypesCredentialIdGet(credential_id, options = {}) {
        const localVarPath = this.basePath + '/credential/mime-types/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialMimeTypesCredentialIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AttributeMimeTypesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Query credential revocation status by id
     * @param credential_id Credential identifier
     * @param from Earliest epoch of revocation status interval of interest
     * @param to Latest epoch of revocation status interval of interest
     * @param {*} [options] Override http request options.
     */
    credentialRevokedCredentialIdGet(credential_id, from, to, options = {}) {
        const localVarPath = this.basePath + '/credential/revoked/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialRevokedCredentialIdGet.');
        }
        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "string");
        }
        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CredRevokedResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove W3C credential from wallet by id
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    credentialW3cCredentialIdDelete(credential_id, options = {}) {
        const localVarPath = this.basePath + '/credential/w3c/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialW3cCredentialIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "HolderModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch W3C credential from wallet by id
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    credentialW3cCredentialIdGet(credential_id, options = {}) {
        const localVarPath = this.basePath + '/credential/w3c/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialW3cCredentialIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "VCRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch credentials from wallet
     * @param count Maximum number to retrieve
     * @param start Start index
     * @param wql (JSON) WQL query
     * @param {*} [options] Override http request options.
     */
    credentialsGet(count, start, wql, options = {}) {
        const localVarPath = this.basePath + '/credentials';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "string");
        }
        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "string");
        }
        if (wql !== undefined) {
            localVarQueryParameters['wql'] = ObjectSerializer.serialize(wql, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CredInfoList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch W3C credentials from wallet
     * @param body
     * @param count Maximum number to retrieve
     * @param start Start index
     * @param wql (JSON) WQL query
     * @param {*} [options] Override http request options.
     */
    credentialsW3cPost(body, count, start, wql, options = {}) {
        const localVarPath = this.basePath + '/credentials/w3c';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "string");
        }
        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "string");
        }
        if (wql !== undefined) {
            localVarQueryParameters['wql'] = ObjectSerializer.serialize(wql, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "W3CCredentialsListRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "VCRecordList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.CredentialsApi = CredentialsApi;
var DidExchangeApiApiKeys;
(function (DidExchangeApiApiKeys) {
    DidExchangeApiApiKeys[DidExchangeApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(DidExchangeApiApiKeys = exports.DidExchangeApiApiKeys || (exports.DidExchangeApiApiKeys = {}));
class DidExchangeApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DidExchangeApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Accept a stored connection invitation
     * @param conn_id Connection identifier
     * @param my_endpoint My URL endpoint
     * @param my_label Label for connection request
     * @param {*} [options] Override http request options.
     */
    didexchangeConnIdAcceptInvitationPost(conn_id, my_endpoint, my_label, options = {}) {
        const localVarPath = this.basePath + '/didexchange/{conn_id}/accept-invitation'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling didexchangeConnIdAcceptInvitationPost.');
        }
        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }
        if (my_label !== undefined) {
            localVarQueryParameters['my_label'] = ObjectSerializer.serialize(my_label, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Accept a stored connection request
     * @param conn_id Connection identifier
     * @param mediation_id Identifier for active mediation record to be used
     * @param my_endpoint My URL endpoint
     * @param {*} [options] Override http request options.
     */
    didexchangeConnIdAcceptRequestPost(conn_id, mediation_id, my_endpoint, options = {}) {
        const localVarPath = this.basePath + '/didexchange/{conn_id}/accept-request'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling didexchangeConnIdAcceptRequestPost.');
        }
        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }
        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Create and send a request against public DID's implicit invitation
     * @param their_public_did Qualified public DID to which to request connection
     * @param alias Alias for connection
     * @param mediation_id Identifier for active mediation record to be used
     * @param my_endpoint My URL endpoint
     * @param my_label Label for connection request
     * @param use_public_did Use public DID for this connection
     * @param {*} [options] Override http request options.
     */
    didexchangeCreateRequestPost(their_public_did, alias, mediation_id, my_endpoint, my_label, use_public_did, options = {}) {
        const localVarPath = this.basePath + '/didexchange/create-request';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'their_public_did' is not null or undefined
        if (their_public_did === null || their_public_did === undefined) {
            throw new Error('Required parameter their_public_did was null or undefined when calling didexchangeCreateRequestPost.');
        }
        if (their_public_did !== undefined) {
            localVarQueryParameters['their_public_did'] = ObjectSerializer.serialize(their_public_did, "string");
        }
        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }
        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }
        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }
        if (my_label !== undefined) {
            localVarQueryParameters['my_label'] = ObjectSerializer.serialize(my_label, "string");
        }
        if (use_public_did !== undefined) {
            localVarQueryParameters['use_public_did'] = ObjectSerializer.serialize(use_public_did, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Receive request against public DID's implicit invitation
     * @param body
     * @param alias Alias for connection
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param mediation_id Identifier for active mediation record to be used
     * @param my_endpoint My URL endpoint
     * @param {*} [options] Override http request options.
     */
    didexchangeReceiveRequestPost(body, alias, auto_accept, mediation_id, my_endpoint, options = {}) {
        const localVarPath = this.basePath + '/didexchange/receive-request';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }
        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }
        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }
        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DIDXRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DidExchangeApi = DidExchangeApi;
var DiscoverFeaturesApiApiKeys;
(function (DiscoverFeaturesApiApiKeys) {
    DiscoverFeaturesApiApiKeys[DiscoverFeaturesApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(DiscoverFeaturesApiApiKeys = exports.DiscoverFeaturesApiApiKeys || (exports.DiscoverFeaturesApiApiKeys = {}));
class DiscoverFeaturesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DiscoverFeaturesApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Query supported features
     * @param comment Comment
     * @param connection_id Connection identifier, if none specified, then the query will provide features for this agent.
     * @param query Protocol feature query
     * @param {*} [options] Override http request options.
     */
    discoverFeaturesQueryGet(comment, connection_id, query, options = {}) {
        const localVarPath = this.basePath + '/discover-features/query';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (comment !== undefined) {
            localVarQueryParameters['comment'] = ObjectSerializer.serialize(comment, "string");
        }
        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }
        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10DiscoveryExchangeResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Discover Features records
     * @param connection_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    discoverFeaturesRecordsGet(connection_id, options = {}) {
        const localVarPath = this.basePath + '/discover-features/records';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10DiscoveryExchangeListResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DiscoverFeaturesApi = DiscoverFeaturesApi;
var DiscoverFeaturesV20ApiApiKeys;
(function (DiscoverFeaturesV20ApiApiKeys) {
    DiscoverFeaturesV20ApiApiKeys[DiscoverFeaturesV20ApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(DiscoverFeaturesV20ApiApiKeys = exports.DiscoverFeaturesV20ApiApiKeys || (exports.DiscoverFeaturesV20ApiApiKeys = {}));
class DiscoverFeaturesV20Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DiscoverFeaturesV20ApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Query supported features
     * @param connection_id Connection identifier, if none specified, then the query will provide features for this agent.
     * @param query_goal_code Goal-code feature-type query
     * @param query_protocol Protocol feature-type query
     * @param {*} [options] Override http request options.
     */
    discoverFeatures20QueriesGet(connection_id, query_goal_code, query_protocol, options = {}) {
        const localVarPath = this.basePath + '/discover-features-2.0/queries';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }
        if (query_goal_code !== undefined) {
            localVarQueryParameters['query_goal_code'] = ObjectSerializer.serialize(query_goal_code, "string");
        }
        if (query_protocol !== undefined) {
            localVarQueryParameters['query_protocol'] = ObjectSerializer.serialize(query_protocol, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20DiscoveryExchangeResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Discover Features v2.0 records
     * @param connection_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    discoverFeatures20RecordsGet(connection_id, options = {}) {
        const localVarPath = this.basePath + '/discover-features-2.0/records';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20DiscoveryExchangeListResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DiscoverFeaturesV20Api = DiscoverFeaturesV20Api;
var EndorseTransactionApiApiKeys;
(function (EndorseTransactionApiApiKeys) {
    EndorseTransactionApiApiKeys[EndorseTransactionApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(EndorseTransactionApiApiKeys = exports.EndorseTransactionApiApiKeys || (exports.EndorseTransactionApiApiKeys = {}));
class EndorseTransactionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[EndorseTransactionApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary For Author to resend a particular transaction request
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    transactionTranIdResendPost(tran_id, options = {}) {
        const localVarPath = this.basePath + '/transaction/{tran_id}/resend'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionTranIdResendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Set Endorser Info
     * @param conn_id Connection identifier
     * @param endorser_did Endorser DID
     * @param endorser_name Endorser Name
     * @param {*} [options] Override http request options.
     */
    transactionsConnIdSetEndorserInfoPost(conn_id, endorser_did, endorser_name, options = {}) {
        const localVarPath = this.basePath + '/transactions/{conn_id}/set-endorser-info'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling transactionsConnIdSetEndorserInfoPost.');
        }
        // verify required parameter 'endorser_did' is not null or undefined
        if (endorser_did === null || endorser_did === undefined) {
            throw new Error('Required parameter endorser_did was null or undefined when calling transactionsConnIdSetEndorserInfoPost.');
        }
        if (endorser_did !== undefined) {
            localVarQueryParameters['endorser_did'] = ObjectSerializer.serialize(endorser_did, "string");
        }
        if (endorser_name !== undefined) {
            localVarQueryParameters['endorser_name'] = ObjectSerializer.serialize(endorser_name, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "EndorserInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Set transaction jobs
     * @param conn_id Connection identifier
     * @param transaction_my_job Transaction related jobs
     * @param {*} [options] Override http request options.
     */
    transactionsConnIdSetEndorserRolePost(conn_id, transaction_my_job, options = {}) {
        const localVarPath = this.basePath + '/transactions/{conn_id}/set-endorser-role'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling transactionsConnIdSetEndorserRolePost.');
        }
        if (transaction_my_job !== undefined) {
            localVarQueryParameters['transaction_my_job'] = ObjectSerializer.serialize(transaction_my_job, "'TRANSACTION_AUTHOR' | 'TRANSACTION_ENDORSER' | 'reset'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TransactionJobs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary For author to send a transaction request
     * @param tran_id Transaction identifier
     * @param body
     * @param endorser_write_txn Endorser will write the transaction after endorsing it
     * @param {*} [options] Override http request options.
     */
    transactionsCreateRequestPost(tran_id, body, endorser_write_txn, options = {}) {
        const localVarPath = this.basePath + '/transactions/create-request';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsCreateRequestPost.');
        }
        if (tran_id !== undefined) {
            localVarQueryParameters['tran_id'] = ObjectSerializer.serialize(tran_id, "string");
        }
        if (endorser_write_txn !== undefined) {
            localVarQueryParameters['endorser_write_txn'] = ObjectSerializer.serialize(endorser_write_txn, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ModelDate")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Query transactions
     * @param {*} [options] Override http request options.
     */
    transactionsGet(options = {}) {
        const localVarPath = this.basePath + '/transactions';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TransactionList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary For Author to cancel a particular transaction request
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    transactionsTranIdCancelPost(tran_id, options = {}) {
        const localVarPath = this.basePath + '/transactions/{tran_id}/cancel'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdCancelPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary For Endorser to endorse a particular transaction record
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    transactionsTranIdEndorsePost(tran_id, options = {}) {
        const localVarPath = this.basePath + '/transactions/{tran_id}/endorse'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdEndorsePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch a single transaction record
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    transactionsTranIdGet(tran_id, options = {}) {
        const localVarPath = this.basePath + '/transactions/{tran_id}'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary For Endorser to refuse a particular transaction record
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    transactionsTranIdRefusePost(tran_id, options = {}) {
        const localVarPath = this.basePath + '/transactions/{tran_id}/refuse'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdRefusePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary For Author / Endorser to write an endorsed transaction to the ledger
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    transactionsTranIdWritePost(tran_id, options = {}) {
        const localVarPath = this.basePath + '/transactions/{tran_id}/write'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdWritePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.EndorseTransactionApi = EndorseTransactionApi;
var IntroductionApiApiKeys;
(function (IntroductionApiApiKeys) {
    IntroductionApiApiKeys[IntroductionApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(IntroductionApiApiKeys = exports.IntroductionApiApiKeys || (exports.IntroductionApiApiKeys = {}));
class IntroductionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[IntroductionApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Start an introduction between two connections
     * @param conn_id Connection identifier
     * @param target_connection_id Target connection identifier
     * @param message Message
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdStartIntroductionPost(conn_id, target_connection_id, message, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}/start-introduction'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdStartIntroductionPost.');
        }
        // verify required parameter 'target_connection_id' is not null or undefined
        if (target_connection_id === null || target_connection_id === undefined) {
            throw new Error('Required parameter target_connection_id was null or undefined when calling connectionsConnIdStartIntroductionPost.');
        }
        if (target_connection_id !== undefined) {
            localVarQueryParameters['target_connection_id'] = ObjectSerializer.serialize(target_connection_id, "string");
        }
        if (message !== undefined) {
            localVarQueryParameters['message'] = ObjectSerializer.serialize(message, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "IntroModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.IntroductionApi = IntroductionApi;
var IssueCredentialV10ApiApiKeys;
(function (IssueCredentialV10ApiApiKeys) {
    IssueCredentialV10ApiApiKeys[IssueCredentialV10ApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(IssueCredentialV10ApiApiKeys = exports.IssueCredentialV10ApiApiKeys || (exports.IssueCredentialV10ApiApiKeys = {}));
class IssueCredentialV10Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[IssueCredentialV10ApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a credential offer, independent of any proposal or connection
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredentialCreateOfferPost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/create-offer';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialConnFreeOfferRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send holder a credential, automating entire flow
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredentialCreatePost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/create';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialCreate")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove an existing credential exchange record
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    issueCredentialRecordsCredExIdDelete(cred_ex_id, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "IssueCredentialModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch a single credential exchange record
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    issueCredentialRecordsCredExIdGet(cred_ex_id, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send holder a credential
     * @param cred_ex_id Credential exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredentialRecordsCredExIdIssuePost(cred_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/issue'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdIssuePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialIssueRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send a problem report for credential exchange
     * @param cred_ex_id Credential exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredentialRecordsCredExIdProblemReportPost(cred_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/problem-report'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdProblemReportPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialProblemReportRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "IssueCredentialModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send holder a credential offer in reference to a proposal with preview
     * @param cred_ex_id Credential exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredentialRecordsCredExIdSendOfferPost(cred_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/send-offer'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdSendOfferPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialBoundOfferRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send issuer a credential request
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    issueCredentialRecordsCredExIdSendRequestPost(cred_ex_id, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/send-request'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdSendRequestPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Store a received credential
     * @param cred_ex_id Credential exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredentialRecordsCredExIdStorePost(cred_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/store'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdStorePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialStoreRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch all credential exchange records
     * @param connection_id Connection identifier
     * @param role Role assigned in credential exchange
     * @param state Credential exchange state
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    issueCredentialRecordsGet(connection_id, role, state, thread_id, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/records';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }
        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'issuer' | 'holder'");
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'proposal_sent' | 'proposal_received' | 'offer_sent' | 'offer_received' | 'request_sent' | 'request_received' | 'credential_issued' | 'credential_received' | 'credential_acked' | 'credential_revoked'");
        }
        if (thread_id !== undefined) {
            localVarQueryParameters['thread_id'] = ObjectSerializer.serialize(thread_id, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchangeListResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send holder a credential offer, independent of any proposal
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredentialSendOfferPost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/send-offer';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialFreeOfferRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send holder a credential, automating entire flow
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredentialSendPost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialProposalRequestMand")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send issuer a credential proposal
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredentialSendProposalPost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential/send-proposal';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialProposalRequestOpt")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.IssueCredentialV10Api = IssueCredentialV10Api;
var IssueCredentialV20ApiApiKeys;
(function (IssueCredentialV20ApiApiKeys) {
    IssueCredentialV20ApiApiKeys[IssueCredentialV20ApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(IssueCredentialV20ApiApiKeys = exports.IssueCredentialV20ApiApiKeys || (exports.IssueCredentialV20ApiApiKeys = {}));
class IssueCredentialV20Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[IssueCredentialV20ApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a credential offer, independent of any proposal or connection
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20CreateOfferPost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/create-offer';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredOfferConnFreeRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Create credential from attribute values
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20CreatePost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/create';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20IssueCredSchemaCore")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove an existing credential exchange record
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    issueCredential20RecordsCredExIdDelete(cred_ex_id, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20IssueCredentialModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch a single credential exchange record
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    issueCredential20RecordsCredExIdGet(cred_ex_id, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecordDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send holder a credential
     * @param cred_ex_id Credential exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20RecordsCredExIdIssuePost(cred_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/issue'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdIssuePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredIssueRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecordDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send a problem report for credential exchange
     * @param cred_ex_id Credential exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20RecordsCredExIdProblemReportPost(cred_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/problem-report'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdProblemReportPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredIssueProblemReportRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20IssueCredentialModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send holder a credential offer in reference to a proposal with preview
     * @param cred_ex_id Credential exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20RecordsCredExIdSendOfferPost(cred_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/send-offer'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdSendOfferPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredBoundOfferRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send issuer a credential request
     * @param cred_ex_id Credential exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20RecordsCredExIdSendRequestPost(cred_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/send-request'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdSendRequestPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredRequestRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Store a received credential
     * @param cred_ex_id Credential exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20RecordsCredExIdStorePost(cred_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/store'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdStorePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredStoreRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecordDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch all credential exchange records
     * @param connection_id Connection identifier
     * @param role Role assigned in credential exchange
     * @param state Credential exchange state
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    issueCredential20RecordsGet(connection_id, role, state, thread_id, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/records';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }
        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'issuer' | 'holder'");
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'proposal-sent' | 'proposal-received' | 'offer-sent' | 'offer-received' | 'request-sent' | 'request-received' | 'credential-issued' | 'credential-received' | 'done' | 'credential-revoked'");
        }
        if (thread_id !== undefined) {
            localVarQueryParameters['thread_id'] = ObjectSerializer.serialize(thread_id, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecordListResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send holder a credential offer, independent of any proposal
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20SendOfferPost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/send-offer';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredOfferRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send holder a credential, automating entire flow
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20SendPost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredExFree")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send issuer a credential proposal
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20SendProposalPost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/send-proposal';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredExFree")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send issuer a credential request not bound to an existing thread. Indy credentials cannot start at a request
     * @param body
     * @param {*} [options] Override http request options.
     */
    issueCredential20SendRequestPost(body, options = {}) {
        const localVarPath = this.basePath + '/issue-credential-2.0/send-request';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredRequestFree")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.IssueCredentialV20Api = IssueCredentialV20Api;
var JsonldApiApiKeys;
(function (JsonldApiApiKeys) {
    JsonldApiApiKeys[JsonldApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(JsonldApiApiKeys = exports.JsonldApiApiKeys || (exports.JsonldApiApiKeys = {}));
class JsonldApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[JsonldApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Sign a JSON-LD structure and return it
     * @param body
     * @param {*} [options] Override http request options.
     */
    jsonldSignPost(body, options = {}) {
        const localVarPath = this.basePath + '/jsonld/sign';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SignRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "SignResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Verify a JSON-LD structure.
     * @param body
     * @param {*} [options] Override http request options.
     */
    jsonldVerifyPost(body, options = {}) {
        const localVarPath = this.basePath + '/jsonld/verify';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "VerifyRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "VerifyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.JsonldApi = JsonldApi;
var LedgerApiApiKeys;
(function (LedgerApiApiKeys) {
    LedgerApiApiKeys[LedgerApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(LedgerApiApiKeys = exports.LedgerApiApiKeys || (exports.LedgerApiApiKeys = {}));
class LedgerApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[LedgerApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Get the endpoint for a DID from the ledger.
     * @param did DID of interest
     * @param endpoint_type Endpoint type of interest (default &#39;Endpoint&#39;)
     * @param {*} [options] Override http request options.
     */
    ledgerDidEndpointGet(did, endpoint_type, options = {}) {
        const localVarPath = this.basePath + '/ledger/did-endpoint';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling ledgerDidEndpointGet.');
        }
        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }
        if (endpoint_type !== undefined) {
            localVarQueryParameters['endpoint_type'] = ObjectSerializer.serialize(endpoint_type, "'Endpoint' | 'Profile' | 'LinkedDomains'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetDIDEndpointResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the verkey for a DID from the ledger.
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    ledgerDidVerkeyGet(did, options = {}) {
        const localVarPath = this.basePath + '/ledger/did-verkey';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling ledgerDidVerkeyGet.');
        }
        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetDIDVerkeyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the role from the NYM registration of a public DID.
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    ledgerGetNymRoleGet(did, options = {}) {
        const localVarPath = this.basePath + '/ledger/get-nym-role';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling ledgerGetNymRoleGet.');
        }
        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetNymRoleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch the multiple ledger configuration currently in use
     * @param {*} [options] Override http request options.
     */
    ledgerMultipleConfigGet(options = {}) {
        const localVarPath = this.basePath + '/ledger/multiple/config';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "LedgerConfigList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch the current write ledger
     * @param {*} [options] Override http request options.
     */
    ledgerMultipleGetWriteLedgerGet(options = {}) {
        const localVarPath = this.basePath + '/ledger/multiple/get-write-ledger';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "WriteLedgerRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send a NYM registration to the ledger.
     * @param did DID to register
     * @param verkey Verification key
     * @param alias Alias
     * @param role Role
     * @param {*} [options] Override http request options.
     */
    ledgerRegisterNymPost(did, verkey, alias, role, options = {}) {
        const localVarPath = this.basePath + '/ledger/register-nym';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling ledgerRegisterNymPost.');
        }
        // verify required parameter 'verkey' is not null or undefined
        if (verkey === null || verkey === undefined) {
            throw new Error('Required parameter verkey was null or undefined when calling ledgerRegisterNymPost.');
        }
        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }
        if (verkey !== undefined) {
            localVarQueryParameters['verkey'] = ObjectSerializer.serialize(verkey, "string");
        }
        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }
        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'STEWARD' | 'TRUSTEE' | 'ENDORSER' | 'NETWORK_MONITOR' | 'reset'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RegisterLedgerNymResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Rotate key pair for public DID.
     * @param {*} [options] Override http request options.
     */
    ledgerRotatePublicDidKeypairPatch(options = {}) {
        const localVarPath = this.basePath + '/ledger/rotate-public-did-keypair';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "LedgerModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Accept the transaction author agreement
     * @param body
     * @param {*} [options] Override http request options.
     */
    ledgerTaaAcceptPost(body, options = {}) {
        const localVarPath = this.basePath + '/ledger/taa/accept';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TAAAccept")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "LedgerModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch the current transaction author agreement, if any
     * @param {*} [options] Override http request options.
     */
    ledgerTaaGet(options = {}) {
        const localVarPath = this.basePath + '/ledger/taa';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TAAResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.LedgerApi = LedgerApi;
var MediationApiApiKeys;
(function (MediationApiApiKeys) {
    MediationApiApiKeys[MediationApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(MediationApiApiKeys = exports.MediationApiApiKeys || (exports.MediationApiApiKeys = {}));
class MediationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[MediationApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Clear default mediator
     * @param {*} [options] Override http request options.
     */
    mediationDefaultMediatorDelete(options = {}) {
        const localVarPath = this.basePath + '/mediation/default-mediator';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get default mediator
     * @param {*} [options] Override http request options.
     */
    mediationDefaultMediatorGet(options = {}) {
        const localVarPath = this.basePath + '/mediation/default-mediator';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Retrieve keylists by connection or role
     * @param conn_id Connection identifier (optional)
     * @param role Filer on role, &#39;client&#39; for keys         mediated by other agents, &#39;server&#39; for keys         mediated by this agent
     * @param {*} [options] Override http request options.
     */
    mediationKeylistsGet(conn_id, role, options = {}) {
        const localVarPath = this.basePath + '/mediation/keylists';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }
        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'client' | 'server'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Keylist");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send keylist query to mediator
     * @param mediation_id Mediation record identifier
     * @param body
     * @param paginate_limit limit number of results
     * @param paginate_offset offset to use in pagination
     * @param {*} [options] Override http request options.
     */
    mediationKeylistsMediationIdSendKeylistQueryPost(mediation_id, body, paginate_limit, paginate_offset, options = {}) {
        const localVarPath = this.basePath + '/mediation/keylists/{mediation_id}/send-keylist-query'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationKeylistsMediationIdSendKeylistQueryPost.');
        }
        if (paginate_limit !== undefined) {
            localVarQueryParameters['paginate_limit'] = ObjectSerializer.serialize(paginate_limit, "number");
        }
        if (paginate_offset !== undefined) {
            localVarQueryParameters['paginate_offset'] = ObjectSerializer.serialize(paginate_offset, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "KeylistQueryFilterRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "KeylistQuery");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send keylist update to mediator
     * @param mediation_id Mediation record identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    mediationKeylistsMediationIdSendKeylistUpdatePost(mediation_id, body, options = {}) {
        const localVarPath = this.basePath + '/mediation/keylists/{mediation_id}/send-keylist-update'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationKeylistsMediationIdSendKeylistUpdatePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "KeylistUpdateRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "KeylistUpdate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Set default mediator
     * @param mediation_id Mediation record identifier
     * @param {*} [options] Override http request options.
     */
    mediationMediationIdDefaultMediatorPut(mediation_id, options = {}) {
        const localVarPath = this.basePath + '/mediation/{mediation_id}/default-mediator'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationMediationIdDefaultMediatorPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Request mediation from connection
     * @param conn_id Connection identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    mediationRequestConnIdPost(conn_id, body, options = {}) {
        const localVarPath = this.basePath + '/mediation/request/{conn_id}'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling mediationRequestConnIdPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MediationCreateRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Query mediation requests, returns list of all mediation records
     * @param conn_id Connection identifier (optional)
     * @param mediator_terms List of mediator rules for recipient
     * @param recipient_terms List of recipient rules for mediation
     * @param state Mediation state (optional)
     * @param {*} [options] Override http request options.
     */
    mediationRequestsGet(conn_id, mediator_terms, recipient_terms, state, options = {}) {
        const localVarPath = this.basePath + '/mediation/requests';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }
        if (mediator_terms !== undefined) {
            localVarQueryParameters['mediator_terms'] = ObjectSerializer.serialize(mediator_terms, "Array<string>");
        }
        if (recipient_terms !== undefined) {
            localVarQueryParameters['recipient_terms'] = ObjectSerializer.serialize(recipient_terms, "Array<string>");
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'request' | 'granted' | 'denied'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MediationList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete mediation request by ID
     * @param mediation_id Mediation record identifier
     * @param {*} [options] Override http request options.
     */
    mediationRequestsMediationIdDelete(mediation_id, options = {}) {
        const localVarPath = this.basePath + '/mediation/requests/{mediation_id}'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationRequestsMediationIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Deny a stored mediation request
     * @param mediation_id Mediation record identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    mediationRequestsMediationIdDenyPost(mediation_id, body, options = {}) {
        const localVarPath = this.basePath + '/mediation/requests/{mediation_id}/deny'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationRequestsMediationIdDenyPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminMediationDeny")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MediationDeny");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Retrieve mediation request record
     * @param mediation_id Mediation record identifier
     * @param {*} [options] Override http request options.
     */
    mediationRequestsMediationIdGet(mediation_id, options = {}) {
        const localVarPath = this.basePath + '/mediation/requests/{mediation_id}'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationRequestsMediationIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Grant received mediation
     * @param mediation_id Mediation record identifier
     * @param {*} [options] Override http request options.
     */
    mediationRequestsMediationIdGrantPost(mediation_id, options = {}) {
        const localVarPath = this.basePath + '/mediation/requests/{mediation_id}/grant'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationRequestsMediationIdGrantPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MediationGrant");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.MediationApi = MediationApi;
var MultitenancyApiApiKeys;
(function (MultitenancyApiApiKeys) {
    MultitenancyApiApiKeys[MultitenancyApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(MultitenancyApiApiKeys = exports.MultitenancyApiApiKeys || (exports.MultitenancyApiApiKeys = {}));
class MultitenancyApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[MultitenancyApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a subwallet
     * @param body
     * @param {*} [options] Override http request options.
     */
    multitenancyWalletPost(body, options = {}) {
        const localVarPath = this.basePath + '/multitenancy/wallet';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateWalletRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CreateWalletResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get a single subwallet
     * @param wallet_id Subwallet identifier
     * @param {*} [options] Override http request options.
     */
    multitenancyWalletWalletIdGet(wallet_id, options = {}) {
        const localVarPath = this.basePath + '/multitenancy/wallet/{wallet_id}'
            .replace('{' + 'wallet_id' + '}', encodeURIComponent(String(wallet_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'wallet_id' is not null or undefined
        if (wallet_id === null || wallet_id === undefined) {
            throw new Error('Required parameter wallet_id was null or undefined when calling multitenancyWalletWalletIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "WalletRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update a subwallet
     * @param wallet_id Subwallet identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    multitenancyWalletWalletIdPut(wallet_id, body, options = {}) {
        const localVarPath = this.basePath + '/multitenancy/wallet/{wallet_id}'
            .replace('{' + 'wallet_id' + '}', encodeURIComponent(String(wallet_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'wallet_id' is not null or undefined
        if (wallet_id === null || wallet_id === undefined) {
            throw new Error('Required parameter wallet_id was null or undefined when calling multitenancyWalletWalletIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateWalletRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "WalletRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove a subwallet
     * @param wallet_id Subwallet identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    multitenancyWalletWalletIdRemovePost(wallet_id, body, options = {}) {
        const localVarPath = this.basePath + '/multitenancy/wallet/{wallet_id}/remove'
            .replace('{' + 'wallet_id' + '}', encodeURIComponent(String(wallet_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'wallet_id' is not null or undefined
        if (wallet_id === null || wallet_id === undefined) {
            throw new Error('Required parameter wallet_id was null or undefined when calling multitenancyWalletWalletIdRemovePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RemoveWalletRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MultitenantModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get auth token for a subwallet
     * @param wallet_id
     * @param body
     * @param {*} [options] Override http request options.
     */
    multitenancyWalletWalletIdTokenPost(wallet_id, body, options = {}) {
        const localVarPath = this.basePath + '/multitenancy/wallet/{wallet_id}/token'
            .replace('{' + 'wallet_id' + '}', encodeURIComponent(String(wallet_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'wallet_id' is not null or undefined
        if (wallet_id === null || wallet_id === undefined) {
            throw new Error('Required parameter wallet_id was null or undefined when calling multitenancyWalletWalletIdTokenPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateWalletTokenRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CreateWalletTokenResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Query subwallets
     * @param wallet_name Wallet name
     * @param {*} [options] Override http request options.
     */
    multitenancyWalletsGet(wallet_name, options = {}) {
        const localVarPath = this.basePath + '/multitenancy/wallets';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (wallet_name !== undefined) {
            localVarQueryParameters['wallet_name'] = ObjectSerializer.serialize(wallet_name, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "WalletList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.MultitenancyApi = MultitenancyApi;
var OutOfBandApiApiKeys;
(function (OutOfBandApiApiKeys) {
    OutOfBandApiApiKeys[OutOfBandApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(OutOfBandApiApiKeys = exports.OutOfBandApiApiKeys || (exports.OutOfBandApiApiKeys = {}));
class OutOfBandApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[OutOfBandApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a new connection invitation
     * @param body
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param multi_use Create invitation for multiple use (default false)
     * @param {*} [options] Override http request options.
     */
    outOfBandCreateInvitationPost(body, auto_accept, multi_use, options = {}) {
        const localVarPath = this.basePath + '/out-of-band/create-invitation';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }
        if (multi_use !== undefined) {
            localVarQueryParameters['multi_use'] = ObjectSerializer.serialize(multi_use, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "InvitationCreateRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "InvitationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Receive a new connection invitation
     * @param body
     * @param alias Alias for connection
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param mediation_id Identifier for active mediation record to be used
     * @param use_existing_connection Use an existing connection, if possible
     * @param {*} [options] Override http request options.
     */
    outOfBandReceiveInvitationPost(body, alias, auto_accept, mediation_id, use_existing_connection, options = {}) {
        const localVarPath = this.basePath + '/out-of-band/receive-invitation';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }
        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }
        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }
        if (use_existing_connection !== undefined) {
            localVarQueryParameters['use_existing_connection'] = ObjectSerializer.serialize(use_existing_connection, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "InvitationMessage")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.OutOfBandApi = OutOfBandApi;
var PresentProofV10ApiApiKeys;
(function (PresentProofV10ApiApiKeys) {
    PresentProofV10ApiApiKeys[PresentProofV10ApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(PresentProofV10ApiApiKeys = exports.PresentProofV10ApiApiKeys || (exports.PresentProofV10ApiApiKeys = {}));
class PresentProofV10Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PresentProofV10ApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Creates a presentation request not bound to any proposal or connection
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProofCreateRequestPost(body, options = {}) {
        const localVarPath = this.basePath + '/present-proof/create-request';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10PresentationCreateRequestRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch all present-proof exchange records
     * @param connection_id Connection identifier
     * @param role Role assigned in presentation exchange
     * @param state Presentation exchange state
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    presentProofRecordsGet(connection_id, role, state, thread_id, options = {}) {
        const localVarPath = this.basePath + '/present-proof/records';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }
        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'prover' | 'verifier'");
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'proposal_sent' | 'proposal_received' | 'request_sent' | 'request_received' | 'presentation_sent' | 'presentation_received' | 'verified' | 'presentation_acked'");
        }
        if (thread_id !== undefined) {
            localVarQueryParameters['thread_id'] = ObjectSerializer.serialize(thread_id, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchangeList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch credentials for a presentation request from wallet
     * @param pres_ex_id Presentation exchange identifier
     * @param count Maximum number to retrieve
     * @param extra_query (JSON) object mapping referents to extra WQL queries
     * @param referent Proof request referents of interest, comma-separated
     * @param start Start index
     * @param {*} [options] Override http request options.
     */
    presentProofRecordsPresExIdCredentialsGet(pres_ex_id, count, extra_query, referent, start, options = {}) {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/credentials'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdCredentialsGet.');
        }
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "string");
        }
        if (extra_query !== undefined) {
            localVarQueryParameters['extra_query'] = ObjectSerializer.serialize(extra_query, "string");
        }
        if (referent !== undefined) {
            localVarQueryParameters['referent'] = ObjectSerializer.serialize(referent, "string");
        }
        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<IndyCredPrecis>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove an existing presentation exchange record
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    presentProofRecordsPresExIdDelete(pres_ex_id, options = {}) {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentProofModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch a single presentation exchange record
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    presentProofRecordsPresExIdGet(pres_ex_id, options = {}) {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send a problem report for presentation exchange
     * @param pres_ex_id Presentation exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProofRecordsPresExIdProblemReportPost(pres_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/problem-report'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdProblemReportPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10PresentationProblemReportRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentProofModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a proof presentation
     * @param pres_ex_id Presentation exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProofRecordsPresExIdSendPresentationPost(pres_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/send-presentation'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdSendPresentationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "IndyPresSpec")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a presentation request in reference to a proposal
     * @param pres_ex_id Presentation exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProofRecordsPresExIdSendRequestPost(pres_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/send-request'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdSendRequestPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminAPIMessageTracing")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Verify a received presentation
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    presentProofRecordsPresExIdVerifyPresentationPost(pres_ex_id, options = {}) {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/verify-presentation'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdVerifyPresentationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a presentation proposal
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProofSendProposalPost(body, options = {}) {
        const localVarPath = this.basePath + '/present-proof/send-proposal';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10PresentationProposalRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a free presentation request not bound to any proposal
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProofSendRequestPost(body, options = {}) {
        const localVarPath = this.basePath + '/present-proof/send-request';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10PresentationSendRequestRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PresentProofV10Api = PresentProofV10Api;
var PresentProofV20ApiApiKeys;
(function (PresentProofV20ApiApiKeys) {
    PresentProofV20ApiApiKeys[PresentProofV20ApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(PresentProofV20ApiApiKeys = exports.PresentProofV20ApiApiKeys || (exports.PresentProofV20ApiApiKeys = {}));
class PresentProofV20Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PresentProofV20ApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Creates a presentation request not bound to any proposal or connection
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProof20CreateRequestPost(body, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/create-request';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresCreateRequestRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch all present-proof exchange records
     * @param connection_id Connection identifier
     * @param role Role assigned in presentation exchange
     * @param state Presentation exchange state
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    presentProof20RecordsGet(connection_id, role, state, thread_id, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/records';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }
        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'prover' | 'verifier'");
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'proposal-sent' | 'proposal-received' | 'request-sent' | 'request-received' | 'presentation-sent' | 'presentation-received' | 'done' | 'abandoned'");
        }
        if (thread_id !== undefined) {
            localVarQueryParameters['thread_id'] = ObjectSerializer.serialize(thread_id, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecordList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch credentials from wallet for presentation request
     * @param pres_ex_id Presentation exchange identifier
     * @param count Maximum number to retrieve
     * @param extra_query (JSON) object mapping referents to extra WQL queries
     * @param referent Proof request referents of interest, comma-separated
     * @param start Start index
     * @param {*} [options] Override http request options.
     */
    presentProof20RecordsPresExIdCredentialsGet(pres_ex_id, count, extra_query, referent, start, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/credentials'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdCredentialsGet.');
        }
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "string");
        }
        if (extra_query !== undefined) {
            localVarQueryParameters['extra_query'] = ObjectSerializer.serialize(extra_query, "string");
        }
        if (referent !== undefined) {
            localVarQueryParameters['referent'] = ObjectSerializer.serialize(referent, "string");
        }
        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<IndyCredPrecis>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove an existing presentation exchange record
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    presentProof20RecordsPresExIdDelete(pres_ex_id, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresentProofModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch a single presentation exchange record
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    presentProof20RecordsPresExIdGet(pres_ex_id, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send a problem report for presentation exchange
     * @param pres_ex_id Presentation exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProof20RecordsPresExIdProblemReportPost(pres_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/problem-report'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdProblemReportPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresProblemReportRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresentProofModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a proof presentation
     * @param pres_ex_id Presentation exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProof20RecordsPresExIdSendPresentationPost(pres_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/send-presentation'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdSendPresentationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresSpecByFormatRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a presentation request in reference to a proposal
     * @param pres_ex_id Presentation exchange identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProof20RecordsPresExIdSendRequestPost(pres_ex_id, body, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/send-request'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdSendRequestPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminAPIMessageTracing")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Verify a received presentation
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    presentProof20RecordsPresExIdVerifyPresentationPost(pres_ex_id, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/verify-presentation'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdVerifyPresentationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a presentation proposal
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProof20SendProposalPost(body, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/send-proposal';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresProposalRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a free presentation request not bound to any proposal
     * @param body
     * @param {*} [options] Override http request options.
     */
    presentProof20SendRequestPost(body, options = {}) {
        const localVarPath = this.basePath + '/present-proof-2.0/send-request';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresSendRequestRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PresentProofV20Api = PresentProofV20Api;
var QAProtocolApiApiKeys;
(function (QAProtocolApiApiKeys) {
    QAProtocolApiApiKeys[QAProtocolApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(QAProtocolApiApiKeys = exports.QAProtocolApiApiKeys || (exports.QAProtocolApiApiKeys = {}));
class QAProtocolApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[QAProtocolApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Question & Answer Protocol
     * @param conn_id Connection identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    qaConnIdSendQuestionPost(conn_id, body, options = {}) {
        const localVarPath = this.basePath + '/qa/{conn_id}/send-question'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling qaConnIdSendQuestionPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QuestionRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "QuestionRequestResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Question & Answer Protocol
     * @param {*} [options] Override http request options.
     */
    qaGetQuestionsGet(options = {}) {
        const localVarPath = this.basePath + '/qa/get-questions';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Question & Answer Protocol
     * @param {*} [options] Override http request options.
     */
    qaGetQuestionsHead(options = {}) {
        const localVarPath = this.basePath + '/qa/get-questions';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Question & Answer Protocol
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    qaThreadIdDelete(thread_id, options = {}) {
        const localVarPath = this.basePath + '/qa/{thread_id}'
            .replace('{' + 'thread_id' + '}', encodeURIComponent(String(thread_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'thread_id' is not null or undefined
        if (thread_id === null || thread_id === undefined) {
            throw new Error('Required parameter thread_id was null or undefined when calling qaThreadIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Question & Answer Protocol
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    qaThreadIdSendAnswerPost(thread_id, options = {}) {
        const localVarPath = this.basePath + '/qa/{thread_id}/send-answer'
            .replace('{' + 'thread_id' + '}', encodeURIComponent(String(thread_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'thread_id' is not null or undefined
        if (thread_id === null || thread_id === undefined) {
            throw new Error('Required parameter thread_id was null or undefined when calling qaThreadIdSendAnswerPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.QAProtocolApi = QAProtocolApi;
var ResolverApiApiKeys;
(function (ResolverApiApiKeys) {
    ResolverApiApiKeys[ResolverApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(ResolverApiApiKeys = exports.ResolverApiApiKeys || (exports.ResolverApiApiKeys = {}));
class ResolverApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ResolverApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Retrieve doc for requested did
     * @param did DID
     * @param {*} [options] Override http request options.
     */
    resolverResolveDidGet(did, options = {}) {
        const localVarPath = this.basePath + '/resolver/resolve/{did}'
            .replace('{' + 'did' + '}', encodeURIComponent(String(did)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling resolverResolveDidGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ResolutionResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ResolverApi = ResolverApi;
var RevocationApiApiKeys;
(function (RevocationApiApiKeys) {
    RevocationApiApiKeys[RevocationApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(RevocationApiApiKeys = exports.RevocationApiApiKeys || (exports.RevocationApiApiKeys = {}));
class RevocationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[RevocationApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Get current active revocation registry by credential definition id
     * @param cred_def_id Credential definition identifier
     * @param {*} [options] Override http request options.
     */
    revocationActiveRegistryCredDefIdGet(cred_def_id, options = {}) {
        const localVarPath = this.basePath + '/revocation/active-registry/{cred_def_id}'
            .replace('{' + 'cred_def_id' + '}', encodeURIComponent(String(cred_def_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'cred_def_id' is not null or undefined
        if (cred_def_id === null || cred_def_id === undefined) {
            throw new Error('Required parameter cred_def_id was null or undefined when calling revocationActiveRegistryCredDefIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Clear pending revocations
     * @param body
     * @param {*} [options] Override http request options.
     */
    revocationClearPendingRevocationsPost(body, options = {}) {
        const localVarPath = this.basePath + '/revocation/clear-pending-revocations';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ClearPendingRevocationsRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "PublishRevocations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Creates a new revocation registry
     * @param body
     * @param {*} [options] Override http request options.
     */
    revocationCreateRegistryPost(body, options = {}) {
        const localVarPath = this.basePath + '/revocation/create-registry';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RevRegCreateRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get credential revocation status
     * @param cred_ex_id Credential exchange identifier
     * @param cred_rev_id Credential revocation identifier
     * @param rev_reg_id Revocation registry identifier
     * @param {*} [options] Override http request options.
     */
    revocationCredentialRecordGet(cred_ex_id, cred_rev_id, rev_reg_id, options = {}) {
        const localVarPath = this.basePath + '/revocation/credential-record';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (cred_ex_id !== undefined) {
            localVarQueryParameters['cred_ex_id'] = ObjectSerializer.serialize(cred_ex_id, "string");
        }
        if (cred_rev_id !== undefined) {
            localVarQueryParameters['cred_rev_id'] = ObjectSerializer.serialize(cred_rev_id, "string");
        }
        if (rev_reg_id !== undefined) {
            localVarQueryParameters['rev_reg_id'] = ObjectSerializer.serialize(rev_reg_id, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CredRevRecordResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Publish pending revocations to ledger
     * @param body
     * @param {*} [options] Override http request options.
     */
    revocationPublishRevocationsPost(body, options = {}) {
        const localVarPath = this.basePath + '/revocation/publish-revocations';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PublishRevocations")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TxnOrPublishRevocationsResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Search for matching revocation registries that current agent created
     * @param cred_def_id Credential definition identifier
     * @param state Revocation registry state
     * @param {*} [options] Override http request options.
     */
    revocationRegistriesCreatedGet(cred_def_id, state, options = {}) {
        const localVarPath = this.basePath + '/revocation/registries/created';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (cred_def_id !== undefined) {
            localVarQueryParameters['cred_def_id'] = ObjectSerializer.serialize(cred_def_id, "string");
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'init' | 'generated' | 'posted' | 'active' | 'full'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevRegsCreated");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send revocation registry definition to ledger
     * @param rev_reg_id Revocation Registry identifier
     * @param conn_id Connection identifier
     * @param create_transaction_for_endorser Create Transaction For Endorser&#39;s signature
     * @param {*} [options] Override http request options.
     */
    revocationRegistryRevRegIdDefinitionPost(rev_reg_id, conn_id, create_transaction_for_endorser, options = {}) {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/definition'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdDefinitionPost.');
        }
        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }
        if (create_transaction_for_endorser !== undefined) {
            localVarQueryParameters['create_transaction_for_endorser'] = ObjectSerializer.serialize(create_transaction_for_endorser, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TxnOrRevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send revocation registry entry to ledger
     * @param rev_reg_id Revocation Registry identifier
     * @param conn_id Connection identifier
     * @param create_transaction_for_endorser Create Transaction For Endorser&#39;s signature
     * @param {*} [options] Override http request options.
     */
    revocationRegistryRevRegIdEntryPost(rev_reg_id, conn_id, create_transaction_for_endorser, options = {}) {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/entry'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdEntryPost.');
        }
        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }
        if (create_transaction_for_endorser !== undefined) {
            localVarQueryParameters['create_transaction_for_endorser'] = ObjectSerializer.serialize(create_transaction_for_endorser, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get revocation registry by revocation registry id
     * @param rev_reg_id Revocation Registry identifier
     * @param {*} [options] Override http request options.
     */
    revocationRegistryRevRegIdGet(rev_reg_id, options = {}) {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get number of credentials issued against revocation registry
     * @param rev_reg_id Revocation Registry identifier
     * @param {*} [options] Override http request options.
     */
    revocationRegistryRevRegIdIssuedGet(rev_reg_id, options = {}) {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/issued'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdIssuedGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevRegIssuedResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update revocation registry with new public URI to its tails file
     * @param rev_reg_id Revocation Registry identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    revocationRegistryRevRegIdPatch(rev_reg_id, body, options = {}) {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdPatch.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RevRegUpdateTailsFileUri")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Set revocation registry state manually
     * @param rev_reg_id Revocation Registry identifier
     * @param state Revocation registry state to set
     * @param {*} [options] Override http request options.
     */
    revocationRegistryRevRegIdSetStatePatch(rev_reg_id, state, options = {}) {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/set-state'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdSetStatePatch.');
        }
        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling revocationRegistryRevRegIdSetStatePatch.');
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'init' | 'generated' | 'posted' | 'active' | 'full'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Download tails file
     * @param rev_reg_id Revocation Registry identifier
     * @param {*} [options] Override http request options.
     */
    revocationRegistryRevRegIdTailsFileGet(rev_reg_id, options = {}) {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/tails-file'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdTailsFileGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Upload local tails file to server
     * @param rev_reg_id Revocation Registry identifier
     * @param {*} [options] Override http request options.
     */
    revocationRegistryRevRegIdTailsFilePut(rev_reg_id, options = {}) {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/tails-file'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdTailsFilePut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevocationModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Revoke an issued credential
     * @param body
     * @param {*} [options] Override http request options.
     */
    revocationRevokePost(body, options = {}) {
        const localVarPath = this.basePath + '/revocation/revoke';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RevokeRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RevocationModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.RevocationApi = RevocationApi;
var SchemaApiApiKeys;
(function (SchemaApiApiKeys) {
    SchemaApiApiKeys[SchemaApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(SchemaApiApiKeys = exports.SchemaApiApiKeys || (exports.SchemaApiApiKeys = {}));
class SchemaApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SchemaApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Search for matching schema that agent originated
     * @param schema_id Schema identifier
     * @param schema_issuer_did Schema issuer DID
     * @param schema_name Schema name
     * @param schema_version Schema version
     * @param {*} [options] Override http request options.
     */
    schemasCreatedGet(schema_id, schema_issuer_did, schema_name, schema_version, options = {}) {
        const localVarPath = this.basePath + '/schemas/created';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (schema_id !== undefined) {
            localVarQueryParameters['schema_id'] = ObjectSerializer.serialize(schema_id, "string");
        }
        if (schema_issuer_did !== undefined) {
            localVarQueryParameters['schema_issuer_did'] = ObjectSerializer.serialize(schema_issuer_did, "string");
        }
        if (schema_name !== undefined) {
            localVarQueryParameters['schema_name'] = ObjectSerializer.serialize(schema_name, "string");
        }
        if (schema_version !== undefined) {
            localVarQueryParameters['schema_version'] = ObjectSerializer.serialize(schema_version, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "SchemasCreatedResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Sends a schema to the ledger
     * @param body
     * @param conn_id Connection identifier
     * @param create_transaction_for_endorser Create Transaction For Endorser&#39;s signature
     * @param {*} [options] Override http request options.
     */
    schemasPost(body, conn_id, create_transaction_for_endorser, options = {}) {
        const localVarPath = this.basePath + '/schemas';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }
        if (create_transaction_for_endorser !== undefined) {
            localVarQueryParameters['create_transaction_for_endorser'] = ObjectSerializer.serialize(create_transaction_for_endorser, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SchemaSendRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TxnOrSchemaSendResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Gets a schema from the ledger
     * @param schema_id Schema identifier
     * @param {*} [options] Override http request options.
     */
    schemasSchemaIdGet(schema_id, options = {}) {
        const localVarPath = this.basePath + '/schemas/{schema_id}'
            .replace('{' + 'schema_id' + '}', encodeURIComponent(String(schema_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'schema_id' is not null or undefined
        if (schema_id === null || schema_id === undefined) {
            throw new Error('Required parameter schema_id was null or undefined when calling schemasSchemaIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "SchemaGetResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Writes a schema non-secret record to the wallet
     * @param schema_id Schema identifier
     * @param {*} [options] Override http request options.
     */
    schemasSchemaIdWriteRecordPost(schema_id, options = {}) {
        const localVarPath = this.basePath + '/schemas/{schema_id}/write_record'
            .replace('{' + 'schema_id' + '}', encodeURIComponent(String(schema_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'schema_id' is not null or undefined
        if (schema_id === null || schema_id === undefined) {
            throw new Error('Required parameter schema_id was null or undefined when calling schemasSchemaIdWriteRecordPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "SchemaGetResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SchemaApi = SchemaApi;
var ServerApiApiKeys;
(function (ServerApiApiKeys) {
    ServerApiApiKeys[ServerApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(ServerApiApiKeys = exports.ServerApiApiKeys || (exports.ServerApiApiKeys = {}));
class ServerApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ServerApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Fetch the list of loaded plugins
     * @param {*} [options] Override http request options.
     */
    pluginsGet(options = {}) {
        const localVarPath = this.basePath + '/plugins';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AdminModules");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Shut down server
     * @param {*} [options] Override http request options.
     */
    shutdownGet(options = {}) {
        const localVarPath = this.basePath + '/shutdown';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AdminShutdown");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch the server configuration
     * @param {*} [options] Override http request options.
     */
    statusConfigGet(options = {}) {
        const localVarPath = this.basePath + '/status/config';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AdminConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch the server status
     * @param {*} [options] Override http request options.
     */
    statusGet(options = {}) {
        const localVarPath = this.basePath + '/status';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AdminStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Liveliness check
     * @param {*} [options] Override http request options.
     */
    statusLiveGet(options = {}) {
        const localVarPath = this.basePath + '/status/live';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AdminStatusLiveliness");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Readiness check
     * @param {*} [options] Override http request options.
     */
    statusReadyGet(options = {}) {
        const localVarPath = this.basePath + '/status/ready';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AdminStatusReadiness");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Reset statistics
     * @param {*} [options] Override http request options.
     */
    statusResetPost(options = {}) {
        const localVarPath = this.basePath + '/status/reset';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AdminReset");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ServerApi = ServerApi;
var TrustpingApiApiKeys;
(function (TrustpingApiApiKeys) {
    TrustpingApiApiKeys[TrustpingApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(TrustpingApiApiKeys = exports.TrustpingApiApiKeys || (exports.TrustpingApiApiKeys = {}));
class TrustpingApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[TrustpingApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Send a trust ping to a connection
     * @param conn_id Connection identifier
     * @param body
     * @param {*} [options] Override http request options.
     */
    connectionsConnIdSendPingPost(conn_id, body, options = {}) {
        const localVarPath = this.basePath + '/connections/{conn_id}/send-ping'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdSendPingPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PingRequest")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "PingRequestResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.TrustpingApi = TrustpingApi;
var WalletApiApiKeys;
(function (WalletApiApiKeys) {
    WalletApiApiKeys[WalletApiApiKeys["AuthorizationHeader"] = 0] = "AuthorizationHeader";
})(WalletApiApiKeys = exports.WalletApiApiKeys || (exports.WalletApiApiKeys = {}));
class WalletApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[WalletApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a local DID
     * @param body
     * @param {*} [options] Override http request options.
     */
    walletDidCreatePost(body, options = {}) {
        const localVarPath = this.basePath + '/wallet/did/create';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DIDCreate")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "DIDResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary List wallet DIDs
     * @param did DID of interest
     * @param key_type Key type to query for.
     * @param method DID method to query for. e.g. sov to only fetch indy/sov DIDs
     * @param posture Whether DID is current public DID, posted to ledger but current public DID, or local to the wallet
     * @param verkey Verification key of interest
     * @param {*} [options] Override http request options.
     */
    walletDidGet(did, key_type, method, posture, verkey, options = {}) {
        const localVarPath = this.basePath + '/wallet/did';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }
        if (key_type !== undefined) {
            localVarQueryParameters['key_type'] = ObjectSerializer.serialize(key_type, "'ed25519' | 'bls12381g2'");
        }
        if (method !== undefined) {
            localVarQueryParameters['method'] = ObjectSerializer.serialize(method, "'key' | 'sov'");
        }
        if (posture !== undefined) {
            localVarQueryParameters['posture'] = ObjectSerializer.serialize(posture, "'public' | 'posted' | 'wallet_only'");
        }
        if (verkey !== undefined) {
            localVarQueryParameters['verkey'] = ObjectSerializer.serialize(verkey, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "DIDList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Rotate keypair for a DID not posted to the ledger
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    walletDidLocalRotateKeypairPatch(did, options = {}) {
        const localVarPath = this.basePath + '/wallet/did/local/rotate-keypair';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling walletDidLocalRotateKeypairPatch.');
        }
        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "WalletModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Fetch the current public DID
     * @param {*} [options] Override http request options.
     */
    walletDidPublicGet(options = {}) {
        const localVarPath = this.basePath + '/wallet/did/public';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "DIDResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Assign the current public DID
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    walletDidPublicPost(did, options = {}) {
        const localVarPath = this.basePath + '/wallet/did/public';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling walletDidPublicPost.');
        }
        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "DIDResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Query DID endpoint in wallet
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    walletGetDidEndpointGet(did, options = {}) {
        const localVarPath = this.basePath + '/wallet/get-did-endpoint';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling walletGetDidEndpointGet.');
        }
        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "DIDEndpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update endpoint in wallet and on ledger if posted to it
     * @param body
     * @param {*} [options] Override http request options.
     */
    walletSetDidEndpointPost(body, options = {}) {
        const localVarPath = this.basePath + '/wallet/set-did-endpoint';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DIDEndpointWithType")
        };
        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "WalletModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.WalletApi = WalletApi;
