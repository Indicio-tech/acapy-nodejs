/**
 * acapy
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.7.3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

let defaultBasePath = 'https://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AMLRecord {
    'aml'?: { [key: string]: string; };
    'amlContext'?: string;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aml",
            "baseName": "aml",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "amlContext",
            "baseName": "amlContext",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AMLRecord.attributeTypeMap;
    }
}

export class ActionMenuFetchResult {
    /**
    * Action menu
    */
    'result'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ActionMenuFetchResult.attributeTypeMap;
    }
}

export class ActionMenuModulesResult {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ActionMenuModulesResult.attributeTypeMap;
    }
}

export class AdminAPIMessageTracing {
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AdminAPIMessageTracing.attributeTypeMap;
    }
}

export class AdminConfig {
    /**
    * Configuration settings
    */
    'config'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "config",
            "baseName": "config",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return AdminConfig.attributeTypeMap;
    }
}

export class AdminMediationDeny {
    /**
    * List of mediator rules for recipient
    */
    'mediator_terms'?: Array<string>;
    /**
    * List of recipient rules for mediation
    */
    'recipient_terms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mediator_terms",
            "baseName": "mediator_terms",
            "type": "Array<string>"
        },
        {
            "name": "recipient_terms",
            "baseName": "recipient_terms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminMediationDeny.attributeTypeMap;
    }
}

export class AdminModules {
    /**
    * List of admin modules
    */
    'result'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminModules.attributeTypeMap;
    }
}

export class AdminReset {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminReset.attributeTypeMap;
    }
}

export class AdminShutdown {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminShutdown.attributeTypeMap;
    }
}

export class AdminStatus {
    /**
    * Conductor statistics
    */
    'conductor'?: any;
    /**
    * Default label
    */
    'label'?: string;
    /**
    * Timing results
    */
    'timing'?: any;
    /**
    * Version code
    */
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "conductor",
            "baseName": "conductor",
            "type": "any"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "timing",
            "baseName": "timing",
            "type": "any"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminStatus.attributeTypeMap;
    }
}

export class AdminStatusLiveliness {
    /**
    * Liveliness status
    */
    'alive'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alive",
            "baseName": "alive",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AdminStatusLiveliness.attributeTypeMap;
    }
}

export class AdminStatusReadiness {
    /**
    * Readiness status
    */
    'ready'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ready",
            "baseName": "ready",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AdminStatusReadiness.attributeTypeMap;
    }
}

export class AttachDecorator {
    /**
    * Attachment identifier
    */
    'id'?: string;
    /**
    * Byte count of data included by reference
    */
    'byte_count'?: number;
    'data': AttachDecoratorData;
    /**
    * Human-readable description of content
    */
    'description'?: string;
    /**
    * File name
    */
    'filename'?: string;
    /**
    * Hint regarding last modification datetime, in ISO-8601 format
    */
    'lastmod_time'?: string;
    /**
    * MIME type
    */
    'mime_type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "byte_count",
            "baseName": "byte_count",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "AttachDecoratorData"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "lastmod_time",
            "baseName": "lastmod_time",
            "type": "string"
        },
        {
            "name": "mime_type",
            "baseName": "mime-type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecorator.attributeTypeMap;
    }
}

export class AttachDecoratorData {
    /**
    * Base64-encoded data
    */
    'base64'?: string;
    /**
    * JSON-serialized data
    */
    'json'?: any;
    /**
    * Detached Java Web Signature
    */
    'jws'?: any;
    /**
    * List of hypertext links to data
    */
    'links'?: Array<string>;
    /**
    * SHA256 hash (binhex encoded) of content
    */
    'sha256'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base64",
            "baseName": "base64",
            "type": "string"
        },
        {
            "name": "json",
            "baseName": "json",
            "type": "any"
        },
        {
            "name": "jws",
            "baseName": "jws",
            "type": "any"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Array<string>"
        },
        {
            "name": "sha256",
            "baseName": "sha256",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecoratorData.attributeTypeMap;
    }
}

export class AttachDecoratorData1JWS {
    'header': AttachDecoratorDataJWSHeader;
    /**
    * protected JWS header
    */
    '_protected'?: string;
    /**
    * signature
    */
    'signature': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "AttachDecoratorDataJWSHeader"
        },
        {
            "name": "_protected",
            "baseName": "protected",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecoratorData1JWS.attributeTypeMap;
    }
}

export class AttachDecoratorDataJWS {
    'header'?: AttachDecoratorDataJWSHeader;
    /**
    * protected JWS header
    */
    '_protected'?: string;
    /**
    * signature
    */
    'signature'?: string;
    /**
    * List of signatures
    */
    'signatures'?: Array<AttachDecoratorData1JWS>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "AttachDecoratorDataJWSHeader"
        },
        {
            "name": "_protected",
            "baseName": "protected",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "string"
        },
        {
            "name": "signatures",
            "baseName": "signatures",
            "type": "Array<AttachDecoratorData1JWS>"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecoratorDataJWS.attributeTypeMap;
    }
}

export class AttachDecoratorDataJWSHeader {
    /**
    * Key identifier, in W3C did:key or DID URL format
    */
    'kid': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kid",
            "baseName": "kid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecoratorDataJWSHeader.attributeTypeMap;
    }
}

export class AttachmentDef {
    /**
    * Attachment identifier
    */
    'id'?: string;
    /**
    * Attachment type
    */
    'type'?: AttachmentDef.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "AttachmentDef.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return AttachmentDef.attributeTypeMap;
    }
}

export namespace AttachmentDef {
    export enum TypeEnum {
        CredentialOffer = <any> 'credential-offer',
        PresentProof = <any> 'present-proof'
    }
}
export class AttributeMimeTypesResult {
    'results'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return AttributeMimeTypesResult.attributeTypeMap;
    }
}

export class BasicMessageModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return BasicMessageModuleResponse.attributeTypeMap;
    }
}

export class ClaimFormat {
    'jwt'?: any;
    'jwt_vc'?: any;
    'jwt_vp'?: any;
    'ldp'?: any;
    'ldp_vc'?: any;
    'ldp_vp'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jwt",
            "baseName": "jwt",
            "type": "any"
        },
        {
            "name": "jwt_vc",
            "baseName": "jwt_vc",
            "type": "any"
        },
        {
            "name": "jwt_vp",
            "baseName": "jwt_vp",
            "type": "any"
        },
        {
            "name": "ldp",
            "baseName": "ldp",
            "type": "any"
        },
        {
            "name": "ldp_vc",
            "baseName": "ldp_vc",
            "type": "any"
        },
        {
            "name": "ldp_vp",
            "baseName": "ldp_vp",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ClaimFormat.attributeTypeMap;
    }
}

export class ClearPendingRevocationsRequest {
    /**
    * Credential revocation ids by revocation registry id: omit for all, specify null or empty list for all pending per revocation registry
    */
    'purge'?: { [key: string]: Array<string>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purge",
            "baseName": "purge",
            "type": "{ [key: string]: Array<string>; }"
        }    ];

    static getAttributeTypeMap() {
        return ClearPendingRevocationsRequest.attributeTypeMap;
    }
}

export class ConnRecord {
    /**
    * Connection acceptance: manual or auto
    */
    'accept'?: ConnRecord.AcceptEnum;
    /**
    * Optional alias to apply to connection for later use
    */
    'alias'?: string;
    /**
    * Connection identifier
    */
    'connection_id'?: string;
    /**
    * Connection protocol used
    */
    'connection_protocol'?: ConnRecord.ConnectionProtocolEnum;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Error message
    */
    'error_msg'?: string;
    /**
    * Inbound routing connection id to use
    */
    'inbound_connection_id'?: string;
    /**
    * Public key for connection
    */
    'invitation_key'?: string;
    /**
    * Invitation mode
    */
    'invitation_mode'?: ConnRecord.InvitationModeEnum;
    /**
    * ID of out-of-band invitation message
    */
    'invitation_msg_id'?: string;
    /**
    * Our DID for connection
    */
    'my_did'?: string;
    /**
    * Connection request identifier
    */
    'request_id'?: string;
    /**
    * State per RFC 23
    */
    'rfc23_state'?: string;
    /**
    * Routing state of connection
    */
    'routing_state'?: ConnRecord.RoutingStateEnum;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Their DID for connection
    */
    'their_did'?: string;
    /**
    * Their label for connection
    */
    'their_label'?: string;
    /**
    * Other agent's public DID for connection
    */
    'their_public_did'?: string;
    /**
    * Their role in the connection protocol
    */
    'their_role'?: ConnRecord.TheirRoleEnum;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accept",
            "baseName": "accept",
            "type": "ConnRecord.AcceptEnum"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "connection_protocol",
            "baseName": "connection_protocol",
            "type": "ConnRecord.ConnectionProtocolEnum"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "error_msg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "inbound_connection_id",
            "baseName": "inbound_connection_id",
            "type": "string"
        },
        {
            "name": "invitation_key",
            "baseName": "invitation_key",
            "type": "string"
        },
        {
            "name": "invitation_mode",
            "baseName": "invitation_mode",
            "type": "ConnRecord.InvitationModeEnum"
        },
        {
            "name": "invitation_msg_id",
            "baseName": "invitation_msg_id",
            "type": "string"
        },
        {
            "name": "my_did",
            "baseName": "my_did",
            "type": "string"
        },
        {
            "name": "request_id",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "rfc23_state",
            "baseName": "rfc23_state",
            "type": "string"
        },
        {
            "name": "routing_state",
            "baseName": "routing_state",
            "type": "ConnRecord.RoutingStateEnum"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "their_did",
            "baseName": "their_did",
            "type": "string"
        },
        {
            "name": "their_label",
            "baseName": "their_label",
            "type": "string"
        },
        {
            "name": "their_public_did",
            "baseName": "their_public_did",
            "type": "string"
        },
        {
            "name": "their_role",
            "baseName": "their_role",
            "type": "ConnRecord.TheirRoleEnum"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConnRecord.attributeTypeMap;
    }
}

export namespace ConnRecord {
    export enum AcceptEnum {
        Manual = <any> 'manual',
        Auto = <any> 'auto'
    }
    export enum ConnectionProtocolEnum {
        Connections10 = <any> 'connections/1.0',
        Didexchange10 = <any> 'didexchange/1.0'
    }
    export enum InvitationModeEnum {
        Once = <any> 'once',
        Multi = <any> 'multi',
        Static = <any> 'static'
    }
    export enum RoutingStateEnum {
        None = <any> 'none',
        Request = <any> 'request',
        Active = <any> 'active',
        Error = <any> 'error'
    }
    export enum TheirRoleEnum {
        Invitee = <any> 'invitee',
        Requester = <any> 'requester',
        Inviter = <any> 'inviter',
        Responder = <any> 'responder'
    }
}
export class ConnectionInvitation {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * DID for connection invitation
    */
    'did'?: string;
    /**
    * Optional image URL for connection invitation
    */
    'imageUrl'?: string;
    /**
    * Optional label for connection invitation
    */
    'label'?: string;
    /**
    * List of recipient keys
    */
    'recipientKeys'?: Array<string>;
    /**
    * List of routing keys
    */
    'routingKeys'?: Array<string>;
    /**
    * Service endpoint at which to reach this agent
    */
    'serviceEndpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "recipientKeys",
            "baseName": "recipientKeys",
            "type": "Array<string>"
        },
        {
            "name": "routingKeys",
            "baseName": "routingKeys",
            "type": "Array<string>"
        },
        {
            "name": "serviceEndpoint",
            "baseName": "serviceEndpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionInvitation.attributeTypeMap;
    }
}

export class ConnectionList {
    /**
    * List of connection records
    */
    'results'?: Array<ConnRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<ConnRecord>"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionList.attributeTypeMap;
    }
}

export class ConnectionMetadata {
    /**
    * Dictionary of metadata associated with connection.
    */
    'results'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionMetadata.attributeTypeMap;
    }
}

export class ConnectionMetadataSetRequest {
    /**
    * Dictionary of metadata to set for connection.
    */
    'metadata': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionMetadataSetRequest.attributeTypeMap;
    }
}

export class ConnectionModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ConnectionModuleResponse.attributeTypeMap;
    }
}

export class ConnectionStaticRequest {
    /**
    * Alias to assign to this connection
    */
    'alias'?: string;
    /**
    * Local DID
    */
    'my_did'?: string;
    /**
    * Seed to use for the local DID
    */
    'my_seed'?: string;
    /**
    * Remote DID
    */
    'their_did'?: string;
    /**
    * URL endpoint for other party
    */
    'their_endpoint'?: string;
    /**
    * Other party's label for this connection
    */
    'their_label'?: string;
    /**
    * Seed to use for the remote DID
    */
    'their_seed'?: string;
    /**
    * Remote verification key
    */
    'their_verkey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "my_did",
            "baseName": "my_did",
            "type": "string"
        },
        {
            "name": "my_seed",
            "baseName": "my_seed",
            "type": "string"
        },
        {
            "name": "their_did",
            "baseName": "their_did",
            "type": "string"
        },
        {
            "name": "their_endpoint",
            "baseName": "their_endpoint",
            "type": "string"
        },
        {
            "name": "their_label",
            "baseName": "their_label",
            "type": "string"
        },
        {
            "name": "their_seed",
            "baseName": "their_seed",
            "type": "string"
        },
        {
            "name": "their_verkey",
            "baseName": "their_verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionStaticRequest.attributeTypeMap;
    }
}

export class ConnectionStaticResult {
    /**
    * Local DID
    */
    'my_did': string;
    /**
    * My URL endpoint
    */
    'my_endpoint': string;
    /**
    * My verification key
    */
    'my_verkey': string;
    'record': ConnRecord;
    /**
    * Remote DID
    */
    'their_did': string;
    /**
    * Remote verification key
    */
    'their_verkey': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "my_did",
            "baseName": "my_did",
            "type": "string"
        },
        {
            "name": "my_endpoint",
            "baseName": "my_endpoint",
            "type": "string"
        },
        {
            "name": "my_verkey",
            "baseName": "my_verkey",
            "type": "string"
        },
        {
            "name": "record",
            "baseName": "record",
            "type": "ConnRecord"
        },
        {
            "name": "their_did",
            "baseName": "their_did",
            "type": "string"
        },
        {
            "name": "their_verkey",
            "baseName": "their_verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionStaticResult.attributeTypeMap;
    }
}

export class Constraints {
    'fields'?: Array<DIFField>;
    'is_holder'?: Array<DIFHolder>;
    /**
    * LimitDisclosure
    */
    'limit_disclosure'?: string;
    'status_active'?: Constraints.StatusActiveEnum;
    'status_revoked'?: Constraints.StatusRevokedEnum;
    'status_suspended'?: Constraints.StatusSuspendedEnum;
    /**
    * SubjectIsIssuer
    */
    'subject_is_issuer'?: Constraints.SubjectIsIssuerEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<DIFField>"
        },
        {
            "name": "is_holder",
            "baseName": "is_holder",
            "type": "Array<DIFHolder>"
        },
        {
            "name": "limit_disclosure",
            "baseName": "limit_disclosure",
            "type": "string"
        },
        {
            "name": "status_active",
            "baseName": "status_active",
            "type": "Constraints.StatusActiveEnum"
        },
        {
            "name": "status_revoked",
            "baseName": "status_revoked",
            "type": "Constraints.StatusRevokedEnum"
        },
        {
            "name": "status_suspended",
            "baseName": "status_suspended",
            "type": "Constraints.StatusSuspendedEnum"
        },
        {
            "name": "subject_is_issuer",
            "baseName": "subject_is_issuer",
            "type": "Constraints.SubjectIsIssuerEnum"
        }    ];

    static getAttributeTypeMap() {
        return Constraints.attributeTypeMap;
    }
}

export namespace Constraints {
    export enum StatusActiveEnum {
        Required = <any> 'required',
        Allowed = <any> 'allowed',
        Disallowed = <any> 'disallowed'
    }
    export enum StatusRevokedEnum {
        Required = <any> 'required',
        Allowed = <any> 'allowed',
        Disallowed = <any> 'disallowed'
    }
    export enum StatusSuspendedEnum {
        Required = <any> 'required',
        Allowed = <any> 'allowed',
        Disallowed = <any> 'disallowed'
    }
    export enum SubjectIsIssuerEnum {
        Required = <any> 'required',
        Preferred = <any> 'preferred'
    }
}
export class CreateInvitationRequest {
    /**
    * Identifier for active mediation record to be used
    */
    'mediation_id'?: string;
    /**
    * Optional metadata to attach to the connection created with the invitation
    */
    'metadata'?: any;
    /**
    * Optional label for connection invitation
    */
    'my_label'?: string;
    /**
    * List of recipient keys
    */
    'recipient_keys'?: Array<string>;
    /**
    * List of routing keys
    */
    'routing_keys'?: Array<string>;
    /**
    * Connection endpoint
    */
    'service_endpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mediation_id",
            "baseName": "mediation_id",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        },
        {
            "name": "my_label",
            "baseName": "my_label",
            "type": "string"
        },
        {
            "name": "recipient_keys",
            "baseName": "recipient_keys",
            "type": "Array<string>"
        },
        {
            "name": "routing_keys",
            "baseName": "routing_keys",
            "type": "Array<string>"
        },
        {
            "name": "service_endpoint",
            "baseName": "service_endpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateInvitationRequest.attributeTypeMap;
    }
}

export class CreateWalletRequest {
    /**
    * Image url for this wallet. This image url is publicized            (self-attested) to other agents as part of forming a connection.
    */
    'image_url'?: string;
    /**
    * Key management method to use for this wallet.
    */
    'key_management_mode'?: CreateWalletRequest.KeyManagementModeEnum;
    /**
    * Label for this wallet. This label is publicized            (self-attested) to other agents as part of forming a connection.
    */
    'label'?: string;
    /**
    * Webhook target dispatch type for this wallet.             default - Dispatch only to webhooks associated with this wallet.             base - Dispatch only to webhooks associated with the base wallet.             both - Dispatch to both webhook targets.
    */
    'wallet_dispatch_type'?: CreateWalletRequest.WalletDispatchTypeEnum;
    /**
    * Master key used for key derivation.
    */
    'wallet_key'?: string;
    /**
    * Wallet name
    */
    'wallet_name'?: string;
    /**
    * Type of the wallet to create
    */
    'wallet_type'?: CreateWalletRequest.WalletTypeEnum;
    /**
    * List of Webhook URLs associated with this subwallet
    */
    'wallet_webhook_urls'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "image_url",
            "baseName": "image_url",
            "type": "string"
        },
        {
            "name": "key_management_mode",
            "baseName": "key_management_mode",
            "type": "CreateWalletRequest.KeyManagementModeEnum"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "wallet_dispatch_type",
            "baseName": "wallet_dispatch_type",
            "type": "CreateWalletRequest.WalletDispatchTypeEnum"
        },
        {
            "name": "wallet_key",
            "baseName": "wallet_key",
            "type": "string"
        },
        {
            "name": "wallet_name",
            "baseName": "wallet_name",
            "type": "string"
        },
        {
            "name": "wallet_type",
            "baseName": "wallet_type",
            "type": "CreateWalletRequest.WalletTypeEnum"
        },
        {
            "name": "wallet_webhook_urls",
            "baseName": "wallet_webhook_urls",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateWalletRequest.attributeTypeMap;
    }
}

export namespace CreateWalletRequest {
    export enum KeyManagementModeEnum {
        Managed = <any> 'managed'
    }
    export enum WalletDispatchTypeEnum {
        Default = <any> 'default',
        Both = <any> 'both',
        Base = <any> 'base'
    }
    export enum WalletTypeEnum {
        Askar = <any> 'askar',
        InMemory = <any> 'in_memory',
        Indy = <any> 'indy'
    }
}
export class CreateWalletResponse {
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Mode regarding management of wallet key
    */
    'key_management_mode': CreateWalletResponse.KeyManagementModeEnum;
    /**
    * Settings for this wallet.
    */
    'settings'?: any;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Authorization token to authenticate wallet requests
    */
    'token'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;
    /**
    * Wallet record ID
    */
    'wallet_id': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "key_management_mode",
            "baseName": "key_management_mode",
            "type": "CreateWalletResponse.KeyManagementModeEnum"
        },
        {
            "name": "settings",
            "baseName": "settings",
            "type": "any"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "wallet_id",
            "baseName": "wallet_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateWalletResponse.attributeTypeMap;
    }
}

export namespace CreateWalletResponse {
    export enum KeyManagementModeEnum {
        Managed = <any> 'managed',
        Unmanaged = <any> 'unmanaged'
    }
}
export class CreateWalletTokenRequest {
    /**
    * Master key used for key derivation. Only required for             unamanged wallets.
    */
    'wallet_key'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "wallet_key",
            "baseName": "wallet_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateWalletTokenRequest.attributeTypeMap;
    }
}

export class CreateWalletTokenResponse {
    /**
    * Authorization token to authenticate wallet requests
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateWalletTokenResponse.attributeTypeMap;
    }
}

export class CredAttrSpec {
    /**
    * MIME type: omit for (null) default
    */
    'mime_type'?: string;
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Attribute value: base64-encode if MIME type is present
    */
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mime_type",
            "baseName": "mime-type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredAttrSpec.attributeTypeMap;
    }
}

export class CredDefValue {
    /**
    * Primary value for credential definition
    */
    'primary'?: any;
    /**
    * Revocation value for credential definition
    */
    'revocation'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "primary",
            "baseName": "primary",
            "type": "any"
        },
        {
            "name": "revocation",
            "baseName": "revocation",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CredDefValue.attributeTypeMap;
    }
}

export class CredDefValuePrimary {
    'n'?: string;
    'r'?: Generated;
    'rctxt'?: string;
    's'?: string;
    'z'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "n",
            "baseName": "n",
            "type": "string"
        },
        {
            "name": "r",
            "baseName": "r",
            "type": "Generated"
        },
        {
            "name": "rctxt",
            "baseName": "rctxt",
            "type": "string"
        },
        {
            "name": "s",
            "baseName": "s",
            "type": "string"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredDefValuePrimary.attributeTypeMap;
    }
}

export class CredDefValueRevocation {
    'g'?: string;
    'g_dash'?: string;
    'h'?: string;
    'h0'?: string;
    'h1'?: string;
    'h2'?: string;
    'h_cap'?: string;
    'htilde'?: string;
    'pk'?: string;
    'u'?: string;
    'y'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "g",
            "baseName": "g",
            "type": "string"
        },
        {
            "name": "g_dash",
            "baseName": "g_dash",
            "type": "string"
        },
        {
            "name": "h",
            "baseName": "h",
            "type": "string"
        },
        {
            "name": "h0",
            "baseName": "h0",
            "type": "string"
        },
        {
            "name": "h1",
            "baseName": "h1",
            "type": "string"
        },
        {
            "name": "h2",
            "baseName": "h2",
            "type": "string"
        },
        {
            "name": "h_cap",
            "baseName": "h_cap",
            "type": "string"
        },
        {
            "name": "htilde",
            "baseName": "htilde",
            "type": "string"
        },
        {
            "name": "pk",
            "baseName": "pk",
            "type": "string"
        },
        {
            "name": "u",
            "baseName": "u",
            "type": "string"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredDefValueRevocation.attributeTypeMap;
    }
}

export class CredInfoList {
    'results'?: Array<IndyCredInfo>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<IndyCredInfo>"
        }    ];

    static getAttributeTypeMap() {
        return CredInfoList.attributeTypeMap;
    }
}

export class CredRevRecordResult {
    'result'?: IssuerCredRevRecord;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "IssuerCredRevRecord"
        }    ];

    static getAttributeTypeMap() {
        return CredRevRecordResult.attributeTypeMap;
    }
}

export class CredRevokedResult {
    /**
    * Whether credential is revoked on the ledger
    */
    'revoked'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "revoked",
            "baseName": "revoked",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CredRevokedResult.attributeTypeMap;
    }
}

export class Credential {
    /**
    * The JSON-LD context of the credential
    */
    'context': Array<any>;
    'credentialSubject': any;
    /**
    * The expiration date
    */
    'expirationDate'?: string;
    'id'?: string;
    /**
    * The issuance date
    */
    'issuanceDate': string;
    /**
    * The JSON-LD Verifiable Credential Issuer. Either string of object with id field.
    */
    'issuer': any;
    /**
    * The proof of the credential
    */
    'proof'?: any;
    /**
    * The JSON-LD type of the credential
    */
    'type': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "@context",
            "type": "Array<any>"
        },
        {
            "name": "credentialSubject",
            "baseName": "credentialSubject",
            "type": "any"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "issuanceDate",
            "baseName": "issuanceDate",
            "type": "string"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "any"
        },
        {
            "name": "proof",
            "baseName": "proof",
            "type": "any"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Credential.attributeTypeMap;
    }
}

export class CredentialDefinition {
    /**
    * Credential definition identifier
    */
    'id'?: string;
    /**
    * Schema identifier within credential definition identifier
    */
    'schemaId'?: string;
    /**
    * Tag within credential definition identifier
    */
    'tag'?: string;
    /**
    * Signature type: CL for Camenisch-Lysyanskaya
    */
    'type'?: any;
    /**
    * Credential definition primary and revocation values
    */
    'value'?: any;
    /**
    * Node protocol version
    */
    'ver'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schemaId",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "any"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        },
        {
            "name": "ver",
            "baseName": "ver",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinition.attributeTypeMap;
    }
}

export class CredentialDefinitionGetResult {
    'credential_definition'?: CredentialDefinition;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential_definition",
            "baseName": "credential_definition",
            "type": "CredentialDefinition"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinitionGetResult.attributeTypeMap;
    }
}

export class CredentialDefinitionSendRequest {
    /**
    * Revocation registry size
    */
    'revocation_registry_size'?: number;
    /**
    * Schema identifier
    */
    'schema_id'?: string;
    /**
    * Revocation supported flag
    */
    'support_revocation'?: boolean;
    /**
    * Credential definition identifier tag
    */
    'tag'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "revocation_registry_size",
            "baseName": "revocation_registry_size",
            "type": "number"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "support_revocation",
            "baseName": "support_revocation",
            "type": "boolean"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinitionSendRequest.attributeTypeMap;
    }
}

export class CredentialDefinitionSendResult {
    /**
    * Credential definition identifier
    */
    'credential_definition_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential_definition_id",
            "baseName": "credential_definition_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinitionSendResult.attributeTypeMap;
    }
}

export class CredentialDefinitionsCreatedResult {
    'credential_definition_ids'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential_definition_ids",
            "baseName": "credential_definition_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinitionsCreatedResult.attributeTypeMap;
    }
}

export class CredentialOffer {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'credential_preview'?: CredentialPreview;
    'offersattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credential_preview",
            "baseName": "credential_preview",
            "type": "CredentialPreview"
        },
        {
            "name": "offersattach",
            "baseName": "offers~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return CredentialOffer.attributeTypeMap;
    }
}

export class CredentialPreview {
    /**
    * Message type identifier
    */
    'type'?: string;
    'attributes': Array<CredAttrSpec>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<CredAttrSpec>"
        }    ];

    static getAttributeTypeMap() {
        return CredentialPreview.attributeTypeMap;
    }
}

export class CredentialProposal {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'cred_def_id'?: string;
    'credential_proposal'?: CredentialPreview;
    'issuer_did'?: string;
    'schema_id'?: string;
    'schema_issuer_did'?: string;
    'schema_name'?: string;
    'schema_version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credential_proposal",
            "baseName": "credential_proposal",
            "type": "CredentialPreview"
        },
        {
            "name": "issuer_did",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schema_issuer_did",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schema_name",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schema_version",
            "baseName": "schema_version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialProposal.attributeTypeMap;
    }
}

export class CredentialStatusOptions {
    /**
    * Credential status method type to use for the credential. Should match status method registered in the Verifiable Credential Extension Registry
    */
    'type': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialStatusOptions.attributeTypeMap;
    }
}

export class DID {
    /**
    * DID of interest
    */
    'did'?: string;
    /**
    * Key type associated with the DID
    */
    'key_type'?: DID.KeyTypeEnum;
    /**
    * Did method associated with the DID
    */
    'method'?: DID.MethodEnum;
    /**
    * Whether DID is current public DID, posted to ledger but not current public DID, or local to the wallet
    */
    'posture'?: DID.PostureEnum;
    /**
    * Public verification key
    */
    'verkey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "key_type",
            "baseName": "key_type",
            "type": "DID.KeyTypeEnum"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "DID.MethodEnum"
        },
        {
            "name": "posture",
            "baseName": "posture",
            "type": "DID.PostureEnum"
        },
        {
            "name": "verkey",
            "baseName": "verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DID.attributeTypeMap;
    }
}

export namespace DID {
    export enum KeyTypeEnum {
        Ed25519 = <any> 'ed25519',
        Bls12381g2 = <any> 'bls12381g2'
    }
    export enum MethodEnum {
        Sov = <any> 'sov',
        Key = <any> 'key'
    }
    export enum PostureEnum {
        Public = <any> 'public',
        Posted = <any> 'posted',
        WalletOnly = <any> 'wallet_only'
    }
}
export class DIDCreate {
    'method'?: DIDCreate.MethodEnum;
    /**
    * To define a key type for a did:key
    */
    'options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "method",
            "baseName": "method",
            "type": "DIDCreate.MethodEnum"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DIDCreate.attributeTypeMap;
    }
}

export namespace DIDCreate {
    export enum MethodEnum {
        Key = <any> 'key',
        Sov = <any> 'sov'
    }
}
export class DIDCreateOptions {
    'key_type': DIDCreateOptions.KeyTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key_type",
            "baseName": "key_type",
            "type": "DIDCreateOptions.KeyTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return DIDCreateOptions.attributeTypeMap;
    }
}

export namespace DIDCreateOptions {
    export enum KeyTypeEnum {
        Ed25519 = <any> 'ed25519',
        Bls12381g2 = <any> 'bls12381g2'
    }
}
export class DIDEndpoint {
    /**
    * DID of interest
    */
    'did': string;
    /**
    * Endpoint to set (omit to delete)
    */
    'endpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DIDEndpoint.attributeTypeMap;
    }
}

export class DIDEndpointWithType {
    /**
    * DID of interest
    */
    'did': string;
    /**
    * Endpoint to set (omit to delete)
    */
    'endpoint'?: string;
    /**
    * Endpoint type to set (default 'Endpoint'); affects only public or posted DIDs
    */
    'endpoint_type'?: DIDEndpointWithType.EndpointTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        },
        {
            "name": "endpoint_type",
            "baseName": "endpoint_type",
            "type": "DIDEndpointWithType.EndpointTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return DIDEndpointWithType.attributeTypeMap;
    }
}

export namespace DIDEndpointWithType {
    export enum EndpointTypeEnum {
        Endpoint = <any> 'Endpoint',
        Profile = <any> 'Profile',
        LinkedDomains = <any> 'LinkedDomains'
    }
}
export class DIDList {
    /**
    * DID list
    */
    'results'?: Array<DID>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<DID>"
        }    ];

    static getAttributeTypeMap() {
        return DIDList.attributeTypeMap;
    }
}

export class DIDResult {
    'result'?: DID;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "DID"
        }    ];

    static getAttributeTypeMap() {
        return DIDResult.attributeTypeMap;
    }
}

export class DIDXRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * DID of exchange
    */
    'did'?: string;
    /**
    * As signed attachment, DID Doc associated with DID
    */
    'did_docattach'?: any;
    /**
    * Label for DID exchange request
    */
    'label': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "did_docattach",
            "baseName": "did_doc~attach",
            "type": "any"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DIDXRequest.attributeTypeMap;
    }
}

export class DIFField {
    'filter'?: Filter;
    /**
    * ID
    */
    'id'?: string;
    'path'?: Array<string>;
    /**
    * Preference
    */
    'predicate'?: DIFField.PredicateEnum;
    /**
    * Purpose
    */
    'purpose'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "Filter"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "Array<string>"
        },
        {
            "name": "predicate",
            "baseName": "predicate",
            "type": "DIFField.PredicateEnum"
        },
        {
            "name": "purpose",
            "baseName": "purpose",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DIFField.attributeTypeMap;
    }
}

export namespace DIFField {
    export enum PredicateEnum {
        Required = <any> 'required',
        Preferred = <any> 'preferred'
    }
}
export class DIFHolder {
    /**
    * Preference
    */
    'directive'?: DIFHolder.DirectiveEnum;
    'field_id'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "directive",
            "baseName": "directive",
            "type": "DIFHolder.DirectiveEnum"
        },
        {
            "name": "field_id",
            "baseName": "field_id",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return DIFHolder.attributeTypeMap;
    }
}

export namespace DIFHolder {
    export enum DirectiveEnum {
        Required = <any> 'required',
        Preferred = <any> 'preferred'
    }
}
export class DIFOptions {
    /**
    * Challenge protect against replay attack
    */
    'challenge'?: string;
    /**
    * Domain protect against replay attack
    */
    'domain'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenge",
            "baseName": "challenge",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DIFOptions.attributeTypeMap;
    }
}

export class DIFPresSpec {
    /**
    * Issuer identifier to sign the presentation, if different from current public DID
    */
    'issuer_id'?: string;
    'presentation_definition'?: PresentationDefinition;
    /**
    * Mapping of input_descriptor id to list of stored W3C credential record_id
    */
    'record_ids'?: any;
    /**
    * reveal doc [JSON-LD frame] dict used to derive the credential when selective disclosure is required
    */
    'reveal_doc'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "issuer_id",
            "baseName": "issuer_id",
            "type": "string"
        },
        {
            "name": "presentation_definition",
            "baseName": "presentation_definition",
            "type": "PresentationDefinition"
        },
        {
            "name": "record_ids",
            "baseName": "record_ids",
            "type": "any"
        },
        {
            "name": "reveal_doc",
            "baseName": "reveal_doc",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DIFPresSpec.attributeTypeMap;
    }
}

export class DIFProofProposal {
    'input_descriptors'?: Array<InputDescriptors>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "input_descriptors",
            "baseName": "input_descriptors",
            "type": "Array<InputDescriptors>"
        }    ];

    static getAttributeTypeMap() {
        return DIFProofProposal.attributeTypeMap;
    }
}

export class DIFProofRequest {
    'options'?: DIFOptions;
    'presentation_definition': PresentationDefinition;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "options",
            "baseName": "options",
            "type": "DIFOptions"
        },
        {
            "name": "presentation_definition",
            "baseName": "presentation_definition",
            "type": "PresentationDefinition"
        }    ];

    static getAttributeTypeMap() {
        return DIFProofRequest.attributeTypeMap;
    }
}

export class Disclose {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * List of protocol descriptors
    */
    'protocols': Array<ProtocolDescriptor>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "protocols",
            "baseName": "protocols",
            "type": "Array<ProtocolDescriptor>"
        }    ];

    static getAttributeTypeMap() {
        return Disclose.attributeTypeMap;
    }
}

export class Disclosures {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * List of protocol or goal_code descriptors
    */
    'disclosures': Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "disclosures",
            "baseName": "disclosures",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return Disclosures.attributeTypeMap;
    }
}

export class Doc {
    /**
    * Credential to sign
    */
    'credential': any;
    /**
    * Signature options
    */
    'options': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential",
            "baseName": "credential",
            "type": "any"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Doc.attributeTypeMap;
    }
}

export class EndorserInfo {
    /**
    * Endorser DID
    */
    'endorser_did': string;
    /**
    * Endorser Name
    */
    'endorser_name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endorser_did",
            "baseName": "endorser_did",
            "type": "string"
        },
        {
            "name": "endorser_name",
            "baseName": "endorser_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EndorserInfo.attributeTypeMap;
    }
}

export class EndpointsResult {
    /**
    * My endpoint
    */
    'my_endpoint'?: string;
    /**
    * Their endpoint
    */
    'their_endpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "my_endpoint",
            "baseName": "my_endpoint",
            "type": "string"
        },
        {
            "name": "their_endpoint",
            "baseName": "their_endpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EndpointsResult.attributeTypeMap;
    }
}

export class Filter {
    /**
    * Const
    */
    '_const'?: any;
    '_enum'?: Array<any>;
    /**
    * ExclusiveMaximum
    */
    'exclusiveMaximum'?: any;
    /**
    * ExclusiveMinimum
    */
    'exclusiveMinimum'?: any;
    /**
    * Format
    */
    'format'?: string;
    /**
    * Max Length
    */
    'maxLength'?: number;
    /**
    * Maximum
    */
    'maximum'?: any;
    /**
    * Min Length
    */
    'minLength'?: number;
    /**
    * Minimum
    */
    'minimum'?: any;
    /**
    * Not
    */
    'not'?: boolean;
    /**
    * Pattern
    */
    'pattern'?: string;
    /**
    * Type
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_const",
            "baseName": "const",
            "type": "any"
        },
        {
            "name": "_enum",
            "baseName": "enum",
            "type": "Array<any>"
        },
        {
            "name": "exclusiveMaximum",
            "baseName": "exclusiveMaximum",
            "type": "any"
        },
        {
            "name": "exclusiveMinimum",
            "baseName": "exclusiveMinimum",
            "type": "any"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        },
        {
            "name": "maxLength",
            "baseName": "maxLength",
            "type": "number"
        },
        {
            "name": "maximum",
            "baseName": "maximum",
            "type": "any"
        },
        {
            "name": "minLength",
            "baseName": "minLength",
            "type": "number"
        },
        {
            "name": "minimum",
            "baseName": "minimum",
            "type": "any"
        },
        {
            "name": "not",
            "baseName": "not",
            "type": "boolean"
        },
        {
            "name": "pattern",
            "baseName": "pattern",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Filter.attributeTypeMap;
    }
}

export class Generated {
    'master_secret'?: string;
    'number'?: string;
    'remainder'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "master_secret",
            "baseName": "master_secret",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "remainder",
            "baseName": "remainder",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Generated.attributeTypeMap;
    }
}

export class GetDIDEndpointResponse {
    /**
    * Full verification key
    */
    'endpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetDIDEndpointResponse.attributeTypeMap;
    }
}

export class GetDIDVerkeyResponse {
    /**
    * Full verification key
    */
    'verkey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "verkey",
            "baseName": "verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetDIDVerkeyResponse.attributeTypeMap;
    }
}

export class GetNymRoleResponse {
    /**
    * Ledger role
    */
    'role'?: GetNymRoleResponse.RoleEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "role",
            "baseName": "role",
            "type": "GetNymRoleResponse.RoleEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetNymRoleResponse.attributeTypeMap;
    }
}

export namespace GetNymRoleResponse {
    export enum RoleEnum {
        STEWARD = <any> 'STEWARD',
        TRUSTEE = <any> 'TRUSTEE',
        ENDORSER = <any> 'ENDORSER',
        NETWORKMONITOR = <any> 'NETWORK_MONITOR',
        USER = <any> 'USER',
        ROLEREMOVE = <any> 'ROLE_REMOVE'
    }
}
export class HolderModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return HolderModuleResponse.attributeTypeMap;
    }
}

export class IndyAttrValue {
    /**
    * Attribute encoded value
    */
    'encoded': string;
    /**
    * Attribute raw value
    */
    'raw': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "encoded",
            "baseName": "encoded",
            "type": "string"
        },
        {
            "name": "raw",
            "baseName": "raw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyAttrValue.attributeTypeMap;
    }
}

export class IndyCredAbstract {
    /**
    * Credential definition identifier
    */
    'cred_def_id': string;
    /**
    * Key correctness proof
    */
    'key_correctness_proof': any;
    /**
    * Nonce in credential abstract
    */
    'nonce': string;
    /**
    * Schema identifier
    */
    'schema_id': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "key_correctness_proof",
            "baseName": "key_correctness_proof",
            "type": "any"
        },
        {
            "name": "nonce",
            "baseName": "nonce",
            "type": "string"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredAbstract.attributeTypeMap;
    }
}

export class IndyCredInfo {
    /**
    * Attribute names and value
    */
    'attrs'?: { [key: string]: string; };
    /**
    * Credential definition identifier
    */
    'cred_def_id'?: string;
    /**
    * Credential revocation identifier
    */
    'cred_rev_id'?: string;
    /**
    * Wallet referent
    */
    'referent'?: string;
    /**
    * Revocation registry identifier
    */
    'rev_reg_id'?: string;
    /**
    * Schema identifier
    */
    'schema_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attrs",
            "baseName": "attrs",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "cred_rev_id",
            "baseName": "cred_rev_id",
            "type": "string"
        },
        {
            "name": "referent",
            "baseName": "referent",
            "type": "string"
        },
        {
            "name": "rev_reg_id",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredInfo.attributeTypeMap;
    }
}

export class IndyCredPrecis {
    /**
    * Credential info
    */
    'cred_info'?: any;
    /**
    * Non-revocation interval from presentation request
    */
    'interval'?: any;
    'presentation_referents'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_info",
            "baseName": "cred_info",
            "type": "any"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "any"
        },
        {
            "name": "presentation_referents",
            "baseName": "presentation_referents",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredPrecis.attributeTypeMap;
    }
}

export class IndyCredRequest {
    /**
    * Blinded master secret
    */
    'blinded_ms': any;
    /**
    * Blinded master secret correctness proof
    */
    'blinded_ms_correctness_proof': any;
    /**
    * Credential definition identifier
    */
    'cred_def_id': string;
    /**
    * Nonce in credential request
    */
    'nonce': string;
    /**
    * Prover DID
    */
    'prover_did'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "blinded_ms",
            "baseName": "blinded_ms",
            "type": "any"
        },
        {
            "name": "blinded_ms_correctness_proof",
            "baseName": "blinded_ms_correctness_proof",
            "type": "any"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "nonce",
            "baseName": "nonce",
            "type": "string"
        },
        {
            "name": "prover_did",
            "baseName": "prover_did",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredRequest.attributeTypeMap;
    }
}

export class IndyCredential {
    /**
    * Credential definition identifier
    */
    'cred_def_id': string;
    /**
    * Revocation registry state
    */
    'rev_reg'?: any;
    /**
    * Revocation registry identifier
    */
    'rev_reg_id'?: string;
    /**
    * Schema identifier
    */
    'schema_id': string;
    /**
    * Credential signature
    */
    'signature': any;
    /**
    * Credential signature correctness proof
    */
    'signature_correctness_proof': any;
    /**
    * Credential attributes
    */
    'values': { [key: string]: any; };
    /**
    * Witness for revocation proof
    */
    'witness'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "rev_reg",
            "baseName": "rev_reg",
            "type": "any"
        },
        {
            "name": "rev_reg_id",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "any"
        },
        {
            "name": "signature_correctness_proof",
            "baseName": "signature_correctness_proof",
            "type": "any"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "witness",
            "baseName": "witness",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredential.attributeTypeMap;
    }
}

export class IndyEQProof {
    'a_prime'?: string;
    'e'?: string;
    'm'?: { [key: string]: string; };
    'm2'?: string;
    'revealed_attrs'?: { [key: string]: string; };
    'v'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "a_prime",
            "baseName": "a_prime",
            "type": "string"
        },
        {
            "name": "e",
            "baseName": "e",
            "type": "string"
        },
        {
            "name": "m",
            "baseName": "m",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "m2",
            "baseName": "m2",
            "type": "string"
        },
        {
            "name": "revealed_attrs",
            "baseName": "revealed_attrs",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyEQProof.attributeTypeMap;
    }
}

export class IndyGEProof {
    'alpha'?: string;
    'mj'?: string;
    'predicate'?: IndyGEProofPred;
    'r'?: { [key: string]: string; };
    't'?: { [key: string]: string; };
    'u'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alpha",
            "baseName": "alpha",
            "type": "string"
        },
        {
            "name": "mj",
            "baseName": "mj",
            "type": "string"
        },
        {
            "name": "predicate",
            "baseName": "predicate",
            "type": "IndyGEProofPred"
        },
        {
            "name": "r",
            "baseName": "r",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "t",
            "baseName": "t",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "u",
            "baseName": "u",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return IndyGEProof.attributeTypeMap;
    }
}

export class IndyGEProofPred {
    /**
    * Attribute name, indy-canonicalized
    */
    'attr_name'?: string;
    /**
    * Predicate type
    */
    'p_type'?: IndyGEProofPred.PTypeEnum;
    /**
    * Predicate threshold value
    */
    'value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attr_name",
            "baseName": "attr_name",
            "type": "string"
        },
        {
            "name": "p_type",
            "baseName": "p_type",
            "type": "IndyGEProofPred.PTypeEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyGEProofPred.attributeTypeMap;
    }
}

export namespace IndyGEProofPred {
    export enum PTypeEnum {
        LT = <any> 'LT',
        LE = <any> 'LE',
        GE = <any> 'GE',
        GT = <any> 'GT'
    }
}
export class IndyKeyCorrectnessProof {
    /**
    * c in key correctness proof
    */
    'c': string;
    /**
    * xr_cap in key correctness proof
    */
    'xr_cap': Array<Array<string>>;
    /**
    * xz_cap in key correctness proof
    */
    'xz_cap': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "c",
            "baseName": "c",
            "type": "string"
        },
        {
            "name": "xr_cap",
            "baseName": "xr_cap",
            "type": "Array<Array<string>>"
        },
        {
            "name": "xz_cap",
            "baseName": "xz_cap",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyKeyCorrectnessProof.attributeTypeMap;
    }
}

export class IndyNonRevocProof {
    'c_list'?: { [key: string]: string; };
    'x_list'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "c_list",
            "baseName": "c_list",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "x_list",
            "baseName": "x_list",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return IndyNonRevocProof.attributeTypeMap;
    }
}

export class IndyNonRevocationInterval {
    /**
    * Earliest time of interest in non-revocation interval
    */
    'from'?: number;
    /**
    * Latest time of interest in non-revocation interval
    */
    'to'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyNonRevocationInterval.attributeTypeMap;
    }
}

export class IndyPresAttrSpec {
    'cred_def_id'?: string;
    /**
    * MIME type (default null)
    */
    'mime_type'?: string;
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Credential referent
    */
    'referent'?: string;
    /**
    * Attribute value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "mime_type",
            "baseName": "mime-type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "referent",
            "baseName": "referent",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyPresAttrSpec.attributeTypeMap;
    }
}

export class IndyPresPredSpec {
    /**
    * Credential definition identifier
    */
    'cred_def_id'?: string;
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Predicate type ('<', '<=', '>=', or '>')
    */
    'predicate': IndyPresPredSpec.PredicateEnum;
    /**
    * Threshold value
    */
    'threshold': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "predicate",
            "baseName": "predicate",
            "type": "IndyPresPredSpec.PredicateEnum"
        },
        {
            "name": "threshold",
            "baseName": "threshold",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyPresPredSpec.attributeTypeMap;
    }
}

export namespace IndyPresPredSpec {
    export enum PredicateEnum {
        LessThan = <any> '<',
        LessThanOrEqualTo = <any> '<=',
        GreaterThanOrEqualTo = <any> '>=',
        GreaterThan = <any> '>'
    }
}
export class IndyPresPreview {
    /**
    * Message type identifier
    */
    'type'?: string;
    'attributes': Array<IndyPresAttrSpec>;
    'predicates': Array<IndyPresPredSpec>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<IndyPresAttrSpec>"
        },
        {
            "name": "predicates",
            "baseName": "predicates",
            "type": "Array<IndyPresPredSpec>"
        }    ];

    static getAttributeTypeMap() {
        return IndyPresPreview.attributeTypeMap;
    }
}

export class IndyPresSpec {
    /**
    * Nested object mapping proof request attribute referents to requested-attribute specifiers
    */
    'requested_attributes': { [key: string]: IndyRequestedCredsRequestedAttr; };
    /**
    * Nested object mapping proof request predicate referents to requested-predicate specifiers
    */
    'requested_predicates': { [key: string]: IndyRequestedCredsRequestedPred; };
    /**
    * Self-attested attributes to build into proof
    */
    'self_attested_attributes': { [key: string]: string; };
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requested_attributes",
            "baseName": "requested_attributes",
            "type": "{ [key: string]: IndyRequestedCredsRequestedAttr; }"
        },
        {
            "name": "requested_predicates",
            "baseName": "requested_predicates",
            "type": "{ [key: string]: IndyRequestedCredsRequestedPred; }"
        },
        {
            "name": "self_attested_attributes",
            "baseName": "self_attested_attributes",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndyPresSpec.attributeTypeMap;
    }
}

export class IndyPrimaryProof {
    /**
    * Indy equality proof
    */
    'eq_proof'?: any;
    /**
    * Indy GE proofs
    */
    'ge_proofs'?: Array<IndyGEProof>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eq_proof",
            "baseName": "eq_proof",
            "type": "any"
        },
        {
            "name": "ge_proofs",
            "baseName": "ge_proofs",
            "type": "Array<IndyGEProof>"
        }    ];

    static getAttributeTypeMap() {
        return IndyPrimaryProof.attributeTypeMap;
    }
}

export class IndyProof {
    /**
    * Indy proof.identifiers content
    */
    'identifiers'?: Array<IndyProofIdentifier>;
    /**
    * Indy proof.proof content
    */
    'proof'?: any;
    /**
    * Indy proof.requested_proof content
    */
    'requested_proof'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifiers",
            "baseName": "identifiers",
            "type": "Array<IndyProofIdentifier>"
        },
        {
            "name": "proof",
            "baseName": "proof",
            "type": "any"
        },
        {
            "name": "requested_proof",
            "baseName": "requested_proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return IndyProof.attributeTypeMap;
    }
}

export class IndyProofIdentifier {
    /**
    * Credential definition identifier
    */
    'cred_def_id'?: string;
    /**
    * Revocation registry identifier
    */
    'rev_reg_id'?: string;
    /**
    * Schema identifier
    */
    'schema_id'?: string;
    /**
    * Timestamp epoch
    */
    'timestamp'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "rev_reg_id",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofIdentifier.attributeTypeMap;
    }
}

export class IndyProofProof {
    /**
    * Indy proof aggregated proof
    */
    'aggregated_proof'?: any;
    /**
    * Indy proof proofs
    */
    'proofs'?: Array<IndyProofProofProofsProof>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aggregated_proof",
            "baseName": "aggregated_proof",
            "type": "any"
        },
        {
            "name": "proofs",
            "baseName": "proofs",
            "type": "Array<IndyProofProofProofsProof>"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofProof.attributeTypeMap;
    }
}

export class IndyProofProofAggregatedProof {
    /**
    * c_hash value
    */
    'c_hash'?: string;
    /**
    * c_list value
    */
    'c_list'?: Array<Array<number>>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "c_hash",
            "baseName": "c_hash",
            "type": "string"
        },
        {
            "name": "c_list",
            "baseName": "c_list",
            "type": "Array<Array<number>>"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofProofAggregatedProof.attributeTypeMap;
    }
}

export class IndyProofProofProofsProof {
    /**
    * Indy non-revocation proof
    */
    'non_revoc_proof'?: any;
    /**
    * Indy primary proof
    */
    'primary_proof'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "non_revoc_proof",
            "baseName": "non_revoc_proof",
            "type": "any"
        },
        {
            "name": "primary_proof",
            "baseName": "primary_proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofProofProofsProof.attributeTypeMap;
    }
}

export class IndyProofReqAttrSpec {
    /**
    * Attribute name
    */
    'name'?: string;
    /**
    * Attribute name group
    */
    'names'?: Array<string>;
    'non_revoked'?: any;
    /**
    * If present, credential must satisfy one of given restrictions: specify schema_id, schema_issuer_did, schema_name, schema_version, issuer_did, cred_def_id, and/or attr::<attribute-name>::value where <attribute-name> represents a credential attribute name
    */
    'restrictions'?: Array<{ [key: string]: string; }>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "names",
            "baseName": "names",
            "type": "Array<string>"
        },
        {
            "name": "non_revoked",
            "baseName": "non_revoked",
            "type": "any"
        },
        {
            "name": "restrictions",
            "baseName": "restrictions",
            "type": "Array<{ [key: string]: string; }>"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofReqAttrSpec.attributeTypeMap;
    }
}

export class IndyProofReqAttrSpecNonRevoked {
    /**
    * Earliest time of interest in non-revocation interval
    */
    'from'?: number;
    /**
    * Latest time of interest in non-revocation interval
    */
    'to'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofReqAttrSpecNonRevoked.attributeTypeMap;
    }
}

export class IndyProofReqPredSpec {
    /**
    * Attribute name
    */
    'name': string;
    'non_revoked'?: any;
    /**
    * Predicate type ('<', '<=', '>=', or '>')
    */
    'p_type': IndyProofReqPredSpec.PTypeEnum;
    /**
    * Threshold value
    */
    'p_value': number;
    /**
    * If present, credential must satisfy one of given restrictions: specify schema_id, schema_issuer_did, schema_name, schema_version, issuer_did, cred_def_id, and/or attr::<attribute-name>::value where <attribute-name> represents a credential attribute name
    */
    'restrictions'?: Array<{ [key: string]: string; }>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "non_revoked",
            "baseName": "non_revoked",
            "type": "any"
        },
        {
            "name": "p_type",
            "baseName": "p_type",
            "type": "IndyProofReqPredSpec.PTypeEnum"
        },
        {
            "name": "p_value",
            "baseName": "p_value",
            "type": "number"
        },
        {
            "name": "restrictions",
            "baseName": "restrictions",
            "type": "Array<{ [key: string]: string; }>"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofReqPredSpec.attributeTypeMap;
    }
}

export namespace IndyProofReqPredSpec {
    export enum PTypeEnum {
        LessThan = <any> '<',
        LessThanOrEqualTo = <any> '<=',
        GreaterThanOrEqualTo = <any> '>=',
        GreaterThan = <any> '>'
    }
}
export class IndyProofReqPredSpecNonRevoked {
    /**
    * Earliest time of interest in non-revocation interval
    */
    'from'?: number;
    /**
    * Latest time of interest in non-revocation interval
    */
    'to'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofReqPredSpecNonRevoked.attributeTypeMap;
    }
}

export class IndyProofRequest {
    /**
    * Proof request name
    */
    'name'?: string;
    'non_revoked'?: any;
    /**
    * Nonce
    */
    'nonce'?: string;
    /**
    * Requested attribute specifications of proof request
    */
    'requested_attributes': { [key: string]: IndyProofReqAttrSpec; };
    /**
    * Requested predicate specifications of proof request
    */
    'requested_predicates': { [key: string]: IndyProofReqPredSpec; };
    /**
    * Proof request version
    */
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "non_revoked",
            "baseName": "non_revoked",
            "type": "any"
        },
        {
            "name": "nonce",
            "baseName": "nonce",
            "type": "string"
        },
        {
            "name": "requested_attributes",
            "baseName": "requested_attributes",
            "type": "{ [key: string]: IndyProofReqAttrSpec; }"
        },
        {
            "name": "requested_predicates",
            "baseName": "requested_predicates",
            "type": "{ [key: string]: IndyProofReqPredSpec; }"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequest.attributeTypeMap;
    }
}

export class IndyProofRequestNonRevoked {
    /**
    * Earliest time of interest in non-revocation interval
    */
    'from'?: number;
    /**
    * Latest time of interest in non-revocation interval
    */
    'to'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestNonRevoked.attributeTypeMap;
    }
}

export class IndyProofRequestedProof {
    /**
    * Proof requested proof predicates.
    */
    'predicates'?: { [key: string]: IndyProofRequestedProofPredicate; };
    /**
    * Proof requested proof revealed attribute groups
    */
    'revealed_attr_groups'?: { [key: string]: IndyProofRequestedProofRevealedAttrGroup; };
    /**
    * Proof requested proof revealed attributes
    */
    'revealed_attrs'?: { [key: string]: IndyProofRequestedProofRevealedAttr; };
    /**
    * Proof requested proof self-attested attributes
    */
    'self_attested_attrs'?: any;
    /**
    * Unrevealed attributes
    */
    'unrevealed_attrs'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "predicates",
            "baseName": "predicates",
            "type": "{ [key: string]: IndyProofRequestedProofPredicate; }"
        },
        {
            "name": "revealed_attr_groups",
            "baseName": "revealed_attr_groups",
            "type": "{ [key: string]: IndyProofRequestedProofRevealedAttrGroup; }"
        },
        {
            "name": "revealed_attrs",
            "baseName": "revealed_attrs",
            "type": "{ [key: string]: IndyProofRequestedProofRevealedAttr; }"
        },
        {
            "name": "self_attested_attrs",
            "baseName": "self_attested_attrs",
            "type": "any"
        },
        {
            "name": "unrevealed_attrs",
            "baseName": "unrevealed_attrs",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestedProof.attributeTypeMap;
    }
}

export class IndyProofRequestedProofPredicate {
    /**
    * Sub-proof index
    */
    'sub_proof_index'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sub_proof_index",
            "baseName": "sub_proof_index",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestedProofPredicate.attributeTypeMap;
    }
}

export class IndyProofRequestedProofRevealedAttr {
    /**
    * Encoded value
    */
    'encoded'?: string;
    /**
    * Raw value
    */
    'raw'?: string;
    /**
    * Sub-proof index
    */
    'sub_proof_index'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "encoded",
            "baseName": "encoded",
            "type": "string"
        },
        {
            "name": "raw",
            "baseName": "raw",
            "type": "string"
        },
        {
            "name": "sub_proof_index",
            "baseName": "sub_proof_index",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestedProofRevealedAttr.attributeTypeMap;
    }
}

export class IndyProofRequestedProofRevealedAttrGroup {
    /**
    * Sub-proof index
    */
    'sub_proof_index'?: number;
    /**
    * Indy proof requested proof revealed attr groups group value
    */
    'values'?: { [key: string]: RawEncoded; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sub_proof_index",
            "baseName": "sub_proof_index",
            "type": "number"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "{ [key: string]: RawEncoded; }"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestedProofRevealedAttrGroup.attributeTypeMap;
    }
}

export class IndyRequestedCredsRequestedAttr {
    /**
    * Wallet credential identifier (typically but not necessarily a UUID)
    */
    'cred_id': string;
    /**
    * Whether to reveal attribute in proof (default true)
    */
    'revealed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_id",
            "baseName": "cred_id",
            "type": "string"
        },
        {
            "name": "revealed",
            "baseName": "revealed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndyRequestedCredsRequestedAttr.attributeTypeMap;
    }
}

export class IndyRequestedCredsRequestedPred {
    /**
    * Wallet credential identifier (typically but not necessarily a UUID)
    */
    'cred_id': string;
    /**
    * Epoch timestamp of interest for non-revocation proof
    */
    'timestamp'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_id",
            "baseName": "cred_id",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyRequestedCredsRequestedPred.attributeTypeMap;
    }
}

export class IndyRevRegDef {
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    /**
    * Indy revocation registry identifier
    */
    'id'?: string;
    /**
    * Revocation registry type (specify CL_ACCUM)
    */
    'revocDefType'?: IndyRevRegDef.RevocDefTypeEnum;
    /**
    * Revocation registry tag
    */
    'tag'?: string;
    /**
    * Revocation registry definition value
    */
    'value'?: any;
    /**
    * Version of revocation registry definition
    */
    'ver'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credDefId",
            "baseName": "credDefId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "revocDefType",
            "baseName": "revocDefType",
            "type": "IndyRevRegDef.RevocDefTypeEnum"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        },
        {
            "name": "ver",
            "baseName": "ver",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegDef.attributeTypeMap;
    }
}

export namespace IndyRevRegDef {
    export enum RevocDefTypeEnum {
        CLACCUM = <any> 'CL_ACCUM'
    }
}
export class IndyRevRegDefValue {
    /**
    * Issuance type
    */
    'issuanceType'?: IndyRevRegDefValue.IssuanceTypeEnum;
    /**
    * Maximum number of credentials; registry size
    */
    'maxCredNum'?: number;
    /**
    * Public keys
    */
    'publicKeys'?: any;
    /**
    * Tails hash value
    */
    'tailsHash'?: string;
    /**
    * Tails file location
    */
    'tailsLocation'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "issuanceType",
            "baseName": "issuanceType",
            "type": "IndyRevRegDefValue.IssuanceTypeEnum"
        },
        {
            "name": "maxCredNum",
            "baseName": "maxCredNum",
            "type": "number"
        },
        {
            "name": "publicKeys",
            "baseName": "publicKeys",
            "type": "any"
        },
        {
            "name": "tailsHash",
            "baseName": "tailsHash",
            "type": "string"
        },
        {
            "name": "tailsLocation",
            "baseName": "tailsLocation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegDefValue.attributeTypeMap;
    }
}

export namespace IndyRevRegDefValue {
    export enum IssuanceTypeEnum {
        ONDEMAND = <any> 'ISSUANCE_ON_DEMAND',
        BYDEFAULT = <any> 'ISSUANCE_BY_DEFAULT'
    }
}
export class IndyRevRegDefValuePublicKeys {
    'accumKey'?: IndyRevRegDefValuePublicKeysAccumKey;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accumKey",
            "baseName": "accumKey",
            "type": "IndyRevRegDefValuePublicKeysAccumKey"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegDefValuePublicKeys.attributeTypeMap;
    }
}

export class IndyRevRegDefValuePublicKeysAccumKey {
    /**
    * Value for z
    */
    'z'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "z",
            "baseName": "z",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegDefValuePublicKeysAccumKey.attributeTypeMap;
    }
}

export class IndyRevRegEntry {
    /**
    * Revocation registry entry value
    */
    'value'?: any;
    /**
    * Version of revocation registry entry
    */
    'ver'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        },
        {
            "name": "ver",
            "baseName": "ver",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegEntry.attributeTypeMap;
    }
}

export class IndyRevRegEntryValue {
    /**
    * Accumulator value
    */
    'accum'?: string;
    /**
    * Previous accumulator value
    */
    'prevAccum'?: string;
    /**
    * Revoked credential revocation identifiers
    */
    'revoked'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accum",
            "baseName": "accum",
            "type": "string"
        },
        {
            "name": "prevAccum",
            "baseName": "prevAccum",
            "type": "string"
        },
        {
            "name": "revoked",
            "baseName": "revoked",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegEntryValue.attributeTypeMap;
    }
}

export class InputDescriptors {
    'constraints'?: Constraints;
    'group'?: Array<string>;
    /**
    * ID
    */
    'id'?: string;
    /**
    * Metadata dictionary
    */
    'metadata'?: any;
    /**
    * Name
    */
    'name'?: string;
    /**
    * Purpose
    */
    'purpose'?: string;
    /**
    * Accepts a list of schema or a dict containing filters like oneof_filter.
    */
    'schema'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "constraints",
            "baseName": "constraints",
            "type": "Constraints"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "Array<string>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "purpose",
            "baseName": "purpose",
            "type": "string"
        },
        {
            "name": "schema",
            "baseName": "schema",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InputDescriptors.attributeTypeMap;
    }
}

export class IntroModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return IntroModuleResponse.attributeTypeMap;
    }
}

export class InvitationCreateRequest {
    /**
    * Alias for connection
    */
    'alias'?: string;
    /**
    * Optional invitation attachments
    */
    'attachments'?: Array<AttachmentDef>;
    'handshake_protocols'?: Array<string>;
    /**
    * Identifier for active mediation record to be used
    */
    'mediation_id'?: string;
    /**
    * Optional metadata to attach to the connection created with the invitation
    */
    'metadata'?: any;
    /**
    * Label for connection invitation
    */
    'my_label'?: string;
    /**
    * Whether to use public DID in invitation
    */
    'use_public_did'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "attachments",
            "baseName": "attachments",
            "type": "Array<AttachmentDef>"
        },
        {
            "name": "handshake_protocols",
            "baseName": "handshake_protocols",
            "type": "Array<string>"
        },
        {
            "name": "mediation_id",
            "baseName": "mediation_id",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        },
        {
            "name": "my_label",
            "baseName": "my_label",
            "type": "string"
        },
        {
            "name": "use_public_did",
            "baseName": "use_public_did",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InvitationCreateRequest.attributeTypeMap;
    }
}

export class InvitationMessage {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    'handshake_protocols'?: Array<string>;
    /**
    * Optional label
    */
    'label'?: string;
    /**
    * Optional request attachment
    */
    'requestsattach'?: Array<AttachDecorator>;
    'services'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "handshake_protocols",
            "baseName": "handshake_protocols",
            "type": "Array<string>"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "requestsattach",
            "baseName": "requests~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "services",
            "baseName": "services",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return InvitationMessage.attributeTypeMap;
    }
}

export class InvitationRecord {
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Invitation message identifier
    */
    'invi_msg_id'?: string;
    /**
    * Out of band invitation message
    */
    'invitation'?: any;
    /**
    * Invitation record identifier
    */
    'invitation_id'?: string;
    /**
    * Invitation message URL
    */
    'invitation_url'?: string;
    /**
    * Out of band message exchange state
    */
    'state'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "invi_msg_id",
            "baseName": "invi_msg_id",
            "type": "string"
        },
        {
            "name": "invitation",
            "baseName": "invitation",
            "type": "any"
        },
        {
            "name": "invitation_id",
            "baseName": "invitation_id",
            "type": "string"
        },
        {
            "name": "invitation_url",
            "baseName": "invitation_url",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvitationRecord.attributeTypeMap;
    }
}

export class InvitationResult {
    /**
    * Connection identifier
    */
    'connection_id'?: string;
    'invitation'?: ConnectionInvitation;
    /**
    * Invitation URL
    */
    'invitation_url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "invitation",
            "baseName": "invitation",
            "type": "ConnectionInvitation"
        },
        {
            "name": "invitation_url",
            "baseName": "invitation_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvitationResult.attributeTypeMap;
    }
}

export class IssueCredentialModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return IssueCredentialModuleResponse.attributeTypeMap;
    }
}

export class IssuerCredRevRecord {
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Credential definition identifier
    */
    'cred_def_id'?: string;
    /**
    * Credential exchange record identifier at credential issue
    */
    'cred_ex_id'?: string;
    /**
    * Credential revocation identifier
    */
    'cred_rev_id'?: string;
    /**
    * Issuer credential revocation record identifier
    */
    'record_id'?: string;
    /**
    * Revocation registry identifier
    */
    'rev_reg_id'?: string;
    /**
    * Issue credential revocation record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "cred_ex_id",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "cred_rev_id",
            "baseName": "cred_rev_id",
            "type": "string"
        },
        {
            "name": "record_id",
            "baseName": "record_id",
            "type": "string"
        },
        {
            "name": "rev_reg_id",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssuerCredRevRecord.attributeTypeMap;
    }
}

export class IssuerRevRegRecord {
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Credential definition identifier
    */
    'cred_def_id'?: string;
    /**
    * Error message
    */
    'error_msg'?: string;
    /**
    * Issuer DID
    */
    'issuer_did'?: string;
    /**
    * Maximum number of credentials for revocation registry
    */
    'max_cred_num'?: number;
    /**
    * Credential revocation identifier for credential revoked and pending publication to ledger
    */
    'pending_pub'?: Array<string>;
    /**
    * Issuer revocation registry record identifier
    */
    'record_id'?: string;
    /**
    * Revocation registry type (specify CL_ACCUM)
    */
    'revoc_def_type'?: IssuerRevRegRecord.RevocDefTypeEnum;
    /**
    * Revocation registry definition
    */
    'revoc_reg_def'?: any;
    /**
    * Revocation registry entry
    */
    'revoc_reg_entry'?: any;
    /**
    * Revocation registry identifier
    */
    'revoc_reg_id'?: string;
    /**
    * Issue revocation registry record state
    */
    'state'?: string;
    /**
    * Tag within issuer revocation registry identifier
    */
    'tag'?: string;
    /**
    * Tails hash
    */
    'tails_hash'?: string;
    /**
    * Local path to tails file
    */
    'tails_local_path'?: string;
    /**
    * Public URI for tails file
    */
    'tails_public_uri'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "error_msg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "issuer_did",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "max_cred_num",
            "baseName": "max_cred_num",
            "type": "number"
        },
        {
            "name": "pending_pub",
            "baseName": "pending_pub",
            "type": "Array<string>"
        },
        {
            "name": "record_id",
            "baseName": "record_id",
            "type": "string"
        },
        {
            "name": "revoc_def_type",
            "baseName": "revoc_def_type",
            "type": "IssuerRevRegRecord.RevocDefTypeEnum"
        },
        {
            "name": "revoc_reg_def",
            "baseName": "revoc_reg_def",
            "type": "any"
        },
        {
            "name": "revoc_reg_entry",
            "baseName": "revoc_reg_entry",
            "type": "any"
        },
        {
            "name": "revoc_reg_id",
            "baseName": "revoc_reg_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "tails_hash",
            "baseName": "tails_hash",
            "type": "string"
        },
        {
            "name": "tails_local_path",
            "baseName": "tails_local_path",
            "type": "string"
        },
        {
            "name": "tails_public_uri",
            "baseName": "tails_public_uri",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssuerRevRegRecord.attributeTypeMap;
    }
}

export namespace IssuerRevRegRecord {
    export enum RevocDefTypeEnum {
        CLACCUM = <any> 'CL_ACCUM'
    }
}
export class Keylist {
    /**
    * List of keylist records
    */
    'results'?: Array<RouteRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<RouteRecord>"
        }    ];

    static getAttributeTypeMap() {
        return Keylist.attributeTypeMap;
    }
}

export class KeylistQuery {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Query dictionary object
    */
    'filter'?: any;
    /**
    * Pagination info
    */
    'paginate'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "paginate",
            "baseName": "paginate",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return KeylistQuery.attributeTypeMap;
    }
}

export class KeylistQueryFilterRequest {
    /**
    * Filter for keylist query
    */
    'filter'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return KeylistQueryFilterRequest.attributeTypeMap;
    }
}

export class KeylistQueryPaginate {
    /**
    * Limit for keylist query
    */
    'limit'?: number;
    /**
    * Offset value for query
    */
    'offset'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return KeylistQueryPaginate.attributeTypeMap;
    }
}

export class KeylistUpdate {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * List of update rules
    */
    'updates'?: Array<KeylistUpdateRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "updates",
            "baseName": "updates",
            "type": "Array<KeylistUpdateRule>"
        }    ];

    static getAttributeTypeMap() {
        return KeylistUpdate.attributeTypeMap;
    }
}

export class KeylistUpdateRequest {
    'updates'?: Array<KeylistUpdateRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "updates",
            "baseName": "updates",
            "type": "Array<KeylistUpdateRule>"
        }    ];

    static getAttributeTypeMap() {
        return KeylistUpdateRequest.attributeTypeMap;
    }
}

export class KeylistUpdateRule {
    /**
    * Action for specific key
    */
    'action': KeylistUpdateRule.ActionEnum;
    /**
    * Key to remove or add
    */
    'recipient_key': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "action",
            "baseName": "action",
            "type": "KeylistUpdateRule.ActionEnum"
        },
        {
            "name": "recipient_key",
            "baseName": "recipient_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KeylistUpdateRule.attributeTypeMap;
    }
}

export namespace KeylistUpdateRule {
    export enum ActionEnum {
        Add = <any> 'add',
        Remove = <any> 'remove'
    }
}
export class LDProofVCDetail {
    /**
    * Detail of the JSON-LD Credential to be issued
    */
    'credential': any;
    /**
    * Options for specifying how the linked data proof is created.
    */
    'options': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential",
            "baseName": "credential",
            "type": "any"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return LDProofVCDetail.attributeTypeMap;
    }
}

export class LDProofVCDetailOptions {
    /**
    * A challenge to include in the proof. SHOULD be provided by the requesting party of the credential (=holder)
    */
    'challenge'?: string;
    /**
    * The date and time of the proof (with a maximum accuracy in seconds). Defaults to current system time
    */
    'created'?: string;
    /**
    * The credential status mechanism to use for the credential. Omitting the property indicates the issued credential will not include a credential status
    */
    'credentialStatus'?: any;
    /**
    * The intended domain of validity for the proof
    */
    'domain'?: string;
    /**
    * The proof purpose used for the proof. Should match proof purposes registered in the Linked Data Proofs Specification
    */
    'proofPurpose'?: string;
    /**
    * The proof type used for the proof. Should match suites registered in the Linked Data Cryptographic Suite Registry
    */
    'proofType': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenge",
            "baseName": "challenge",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "credentialStatus",
            "baseName": "credentialStatus",
            "type": "any"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "proofPurpose",
            "baseName": "proofPurpose",
            "type": "string"
        },
        {
            "name": "proofType",
            "baseName": "proofType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LDProofVCDetailOptions.attributeTypeMap;
    }
}

export class LedgerConfigInstance {
    /**
    * genesis_file
    */
    'genesis_file'?: string;
    /**
    * genesis_transactions
    */
    'genesis_transactions'?: string;
    /**
    * genesis_url
    */
    'genesis_url'?: string;
    /**
    * ledger_id
    */
    'id'?: string;
    /**
    * is_production
    */
    'is_production'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "genesis_file",
            "baseName": "genesis_file",
            "type": "string"
        },
        {
            "name": "genesis_transactions",
            "baseName": "genesis_transactions",
            "type": "string"
        },
        {
            "name": "genesis_url",
            "baseName": "genesis_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "is_production",
            "baseName": "is_production",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LedgerConfigInstance.attributeTypeMap;
    }
}

export class LedgerConfigList {
    'ledger_config_list': Array<LedgerConfigInstance>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ledger_config_list",
            "baseName": "ledger_config_list",
            "type": "Array<LedgerConfigInstance>"
        }    ];

    static getAttributeTypeMap() {
        return LedgerConfigList.attributeTypeMap;
    }
}

export class LedgerModulesResult {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LedgerModulesResult.attributeTypeMap;
    }
}

export class LinkedDataProof {
    /**
    * Associates a challenge with a proof, for use with a proofPurpose such as authentication
    */
    'challenge'?: string;
    /**
    * The string value of an ISO8601 combined date and time string generated by the Signature Algorithm
    */
    'created': string;
    /**
    * A string value specifying the restricted domain of the signature.
    */
    'domain'?: string;
    /**
    * Associates a Detached Json Web Signature with a proof
    */
    'jws'?: string;
    /**
    * The nonce
    */
    'nonce'?: string;
    /**
    * Proof purpose
    */
    'proofPurpose': string;
    /**
    * The proof value of a proof
    */
    'proofValue'?: string;
    /**
    * Identifies the digital signature suite that was used to create the signature
    */
    'type': string;
    /**
    * Information used for proof verification
    */
    'verificationMethod': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenge",
            "baseName": "challenge",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "jws",
            "baseName": "jws",
            "type": "string"
        },
        {
            "name": "nonce",
            "baseName": "nonce",
            "type": "string"
        },
        {
            "name": "proofPurpose",
            "baseName": "proofPurpose",
            "type": "string"
        },
        {
            "name": "proofValue",
            "baseName": "proofValue",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "verificationMethod",
            "baseName": "verificationMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LinkedDataProof.attributeTypeMap;
    }
}

export class MediationCreateRequest {
    /**
    * List of mediator rules for recipient
    */
    'mediator_terms'?: Array<string>;
    /**
    * List of recipient rules for mediation
    */
    'recipient_terms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mediator_terms",
            "baseName": "mediator_terms",
            "type": "Array<string>"
        },
        {
            "name": "recipient_terms",
            "baseName": "recipient_terms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MediationCreateRequest.attributeTypeMap;
    }
}

export class MediationDeny {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    'mediator_terms'?: Array<string>;
    'recipient_terms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "mediator_terms",
            "baseName": "mediator_terms",
            "type": "Array<string>"
        },
        {
            "name": "recipient_terms",
            "baseName": "recipient_terms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MediationDeny.attributeTypeMap;
    }
}

export class MediationGrant {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * endpoint on which messages destined for the recipient are received.
    */
    'endpoint'?: string;
    'routing_keys'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        },
        {
            "name": "routing_keys",
            "baseName": "routing_keys",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MediationGrant.attributeTypeMap;
    }
}

export class MediationList {
    /**
    * List of mediation records
    */
    'results'?: Array<MediationRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<MediationRecord>"
        }    ];

    static getAttributeTypeMap() {
        return MediationList.attributeTypeMap;
    }
}

export class MediationRecord {
    'connection_id': string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    'endpoint'?: string;
    'mediation_id'?: string;
    'mediator_terms'?: Array<string>;
    'recipient_terms'?: Array<string>;
    'role': string;
    'routing_keys'?: Array<string>;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        },
        {
            "name": "mediation_id",
            "baseName": "mediation_id",
            "type": "string"
        },
        {
            "name": "mediator_terms",
            "baseName": "mediator_terms",
            "type": "Array<string>"
        },
        {
            "name": "recipient_terms",
            "baseName": "recipient_terms",
            "type": "Array<string>"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "routing_keys",
            "baseName": "routing_keys",
            "type": "Array<string>"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MediationRecord.attributeTypeMap;
    }
}

export class Menu {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Introductory text for the menu
    */
    'description'?: string;
    /**
    * An optional error message to display in menu header
    */
    'errormsg'?: string;
    /**
    * List of menu options
    */
    'options': Array<MenuOption>;
    /**
    * Menu title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "errormsg",
            "baseName": "errormsg",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<MenuOption>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Menu.attributeTypeMap;
    }
}

export class MenuForm {
    /**
    * Additional descriptive text for menu form
    */
    'description'?: string;
    /**
    * List of form parameters
    */
    'params'?: Array<MenuFormParam>;
    /**
    * Alternative label for form submit button
    */
    'submit_label'?: string;
    /**
    * Menu form title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "Array<MenuFormParam>"
        },
        {
            "name": "submit_label",
            "baseName": "submit-label",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuForm.attributeTypeMap;
    }
}

export class MenuFormParam {
    /**
    * Default parameter value
    */
    '_default'?: string;
    /**
    * Additional descriptive text for menu form parameter
    */
    'description'?: string;
    /**
    * Menu parameter name
    */
    'name': string;
    /**
    * Whether parameter is required
    */
    'required'?: boolean;
    /**
    * Menu parameter title
    */
    'title': string;
    /**
    * Menu form parameter input type
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_default",
            "baseName": "default",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuFormParam.attributeTypeMap;
    }
}

export class MenuJson {
    /**
    * Introductory text for the menu
    */
    'description'?: string;
    /**
    * Optional error message to display in menu header
    */
    'errormsg'?: string;
    /**
    * List of menu options
    */
    'options': Array<MenuOption>;
    /**
    * Menu title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "errormsg",
            "baseName": "errormsg",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<MenuOption>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuJson.attributeTypeMap;
    }
}

export class MenuOption {
    /**
    * Additional descriptive text for menu option
    */
    'description'?: string;
    /**
    * Whether to show option as disabled
    */
    'disabled'?: boolean;
    'form'?: MenuForm;
    /**
    * Menu option name (unique identifier)
    */
    'name': string;
    /**
    * Menu option title
    */
    'title': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "form",
            "baseName": "form",
            "type": "MenuForm"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuOption.attributeTypeMap;
    }
}

export class ModelDate {
    /**
    * Expiry Date
    */
    'expires_time': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expires_time",
            "baseName": "expires_time",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ModelDate.attributeTypeMap;
    }
}

export class MultitenantModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MultitenantModuleResponse.attributeTypeMap;
    }
}

export class PerformRequest {
    /**
    * Menu option name
    */
    'name'?: string;
    /**
    * Input parameter values
    */
    'params'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return PerformRequest.attributeTypeMap;
    }
}

export class PingRequest {
    /**
    * Comment for the ping message
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PingRequest.attributeTypeMap;
    }
}

export class PingRequestResponse {
    /**
    * Thread ID of the ping message
    */
    'thread_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PingRequestResponse.attributeTypeMap;
    }
}

export class PresentationDefinition {
    'format'?: ClaimFormat;
    /**
    * Unique Resource Identifier
    */
    'id'?: string;
    'input_descriptors'?: Array<InputDescriptors>;
    /**
    * Human-friendly name that describes what the presentation definition pertains to
    */
    'name'?: string;
    /**
    * Describes the purpose for which the Presentation Definition's inputs are being requested
    */
    'purpose'?: string;
    'submission_requirements'?: Array<SubmissionRequirements>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "format",
            "baseName": "format",
            "type": "ClaimFormat"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "input_descriptors",
            "baseName": "input_descriptors",
            "type": "Array<InputDescriptors>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "purpose",
            "baseName": "purpose",
            "type": "string"
        },
        {
            "name": "submission_requirements",
            "baseName": "submission_requirements",
            "type": "Array<SubmissionRequirements>"
        }    ];

    static getAttributeTypeMap() {
        return PresentationDefinition.attributeTypeMap;
    }
}

export class PresentationProposal {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'presentation_proposal': IndyPresPreview;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "presentation_proposal",
            "baseName": "presentation_proposal",
            "type": "IndyPresPreview"
        }    ];

    static getAttributeTypeMap() {
        return PresentationProposal.attributeTypeMap;
    }
}

export class PresentationRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'request_presentationsattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "request_presentationsattach",
            "baseName": "request_presentations~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return PresentationRequest.attributeTypeMap;
    }
}

export class ProtocolDescriptor {
    'pid': string;
    /**
    * List of roles
    */
    'roles'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pid",
            "baseName": "pid",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ProtocolDescriptor.attributeTypeMap;
    }
}

export class PublishRevocations {
    /**
    * Credential revocation ids by revocation registry id
    */
    'rrid2crid'?: { [key: string]: Array<string>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rrid2crid",
            "baseName": "rrid2crid",
            "type": "{ [key: string]: Array<string>; }"
        }    ];

    static getAttributeTypeMap() {
        return PublishRevocations.attributeTypeMap;
    }
}

export class Queries {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    'queries'?: Array<QueryItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "queries",
            "baseName": "queries",
            "type": "Array<QueryItem>"
        }    ];

    static getAttributeTypeMap() {
        return Queries.attributeTypeMap;
    }
}

export class Query {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    'comment'?: string;
    'query': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Query.attributeTypeMap;
    }
}

export class QueryItem {
    /**
    * feature type
    */
    'feature_type': QueryItem.FeatureTypeEnum;
    /**
    * match
    */
    'match': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "feature_type",
            "baseName": "feature-type",
            "type": "QueryItem.FeatureTypeEnum"
        },
        {
            "name": "match",
            "baseName": "match",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return QueryItem.attributeTypeMap;
    }
}

export namespace QueryItem {
    export enum FeatureTypeEnum {
        Protocol = <any> 'protocol',
        GoalCode = <any> 'goal-code'
    }
}
export class QuestionRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * This is optional fine-print giving context to the question and its various answers.
    */
    'question_detail'?: string;
    /**
    * The text of the question.
    */
    'question_text': string;
    /**
    * A list of dictionaries indicating possible valid responses to the question.
    */
    'valid_responses': Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "question_detail",
            "baseName": "question_detail",
            "type": "string"
        },
        {
            "name": "question_text",
            "baseName": "question_text",
            "type": "string"
        },
        {
            "name": "valid_responses",
            "baseName": "valid_responses",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return QuestionRequest.attributeTypeMap;
    }
}

export class QuestionRequestResponse {
    /**
    * Thread ID of the QAExchangeRecord message thread
    */
    '_id'?: string;
    /**
    * Connection ID to which the answer to the question will be sent; required if notify is true
    */
    'connection_id'?: string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * This is optional fine-print giving context to the question and its various answers.
    */
    'question_detail'?: string;
    /**
    * The text of the question.
    */
    'question_text': string;
    /**
    * The received answer response
    */
    'response'?: string;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Thread ID of the QAExchangeRecord message thread
    */
    'thread_id'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;
    /**
    * A list of dictionaries indicating possible valid responses to the question.
    */
    'valid_responses': Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "question_detail",
            "baseName": "question_detail",
            "type": "string"
        },
        {
            "name": "question_text",
            "baseName": "question_text",
            "type": "string"
        },
        {
            "name": "response",
            "baseName": "response",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "valid_responses",
            "baseName": "valid_responses",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return QuestionRequestResponse.attributeTypeMap;
    }
}

export class RawEncoded {
    /**
    * Encoded value
    */
    'encoded'?: string;
    /**
    * Raw value
    */
    'raw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "encoded",
            "baseName": "encoded",
            "type": "string"
        },
        {
            "name": "raw",
            "baseName": "raw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RawEncoded.attributeTypeMap;
    }
}

export class ReceiveInvitationRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * DID for connection invitation
    */
    'did'?: string;
    /**
    * Optional image URL for connection invitation
    */
    'imageUrl'?: string;
    /**
    * Optional label for connection invitation
    */
    'label'?: string;
    /**
    * List of recipient keys
    */
    'recipientKeys'?: Array<string>;
    /**
    * List of routing keys
    */
    'routingKeys'?: Array<string>;
    /**
    * Service endpoint at which to reach this agent
    */
    'serviceEndpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "recipientKeys",
            "baseName": "recipientKeys",
            "type": "Array<string>"
        },
        {
            "name": "routingKeys",
            "baseName": "routingKeys",
            "type": "Array<string>"
        },
        {
            "name": "serviceEndpoint",
            "baseName": "serviceEndpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReceiveInvitationRequest.attributeTypeMap;
    }
}

export class RegisterLedgerNymResponse {
    /**
    * Success of nym registration operation
    */
    'success'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RegisterLedgerNymResponse.attributeTypeMap;
    }
}

export class RemoveWalletRequest {
    /**
    * Master key used for key derivation. Only required for             unmanaged wallets.
    */
    'wallet_key'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "wallet_key",
            "baseName": "wallet_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RemoveWalletRequest.attributeTypeMap;
    }
}

export class ResolutionResult {
    /**
    * DID Document
    */
    'did_doc': any;
    /**
    * Resolution metadata
    */
    'metadata': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "did_doc",
            "baseName": "did_doc",
            "type": "any"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ResolutionResult.attributeTypeMap;
    }
}

export class RevRegCreateRequest {
    /**
    * Credential definition identifier
    */
    'credential_definition_id'?: string;
    /**
    * Revocation registry size
    */
    'max_cred_num'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential_definition_id",
            "baseName": "credential_definition_id",
            "type": "string"
        },
        {
            "name": "max_cred_num",
            "baseName": "max_cred_num",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevRegCreateRequest.attributeTypeMap;
    }
}

export class RevRegIssuedResult {
    /**
    * Number of credentials issued against revocation registry
    */
    'result'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevRegIssuedResult.attributeTypeMap;
    }
}

export class RevRegResult {
    'result'?: IssuerRevRegRecord;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "IssuerRevRegRecord"
        }    ];

    static getAttributeTypeMap() {
        return RevRegResult.attributeTypeMap;
    }
}

export class RevRegUpdateTailsFileUri {
    /**
    * Public URI to the tails file
    */
    'tails_public_uri': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tails_public_uri",
            "baseName": "tails_public_uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RevRegUpdateTailsFileUri.attributeTypeMap;
    }
}

export class RevRegsCreated {
    'rev_reg_ids'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rev_reg_ids",
            "baseName": "rev_reg_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RevRegsCreated.attributeTypeMap;
    }
}

export class RevocationModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RevocationModuleResponse.attributeTypeMap;
    }
}

export class RevokeRequest {
    /**
    * Optional comment to include in revocation notification
    */
    'comment'?: string;
    /**
    * Connection ID to which the revocation notification will be sent; required if notify is true
    */
    'connection_id'?: string;
    /**
    * Credential exchange identifier
    */
    'cred_ex_id'?: string;
    /**
    * Credential revocation identifier
    */
    'cred_rev_id'?: string;
    /**
    * Send a notification to the credential recipient
    */
    'notify'?: boolean;
    /**
    * (True) publish revocation to ledger immediately, or (default, False) mark it pending
    */
    'publish'?: boolean;
    /**
    * Revocation registry identifier
    */
    'rev_reg_id'?: string;
    /**
    * Thread ID of the credential exchange message thread resulting in the credential now being revoked; required if notify is true
    */
    'thread_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "cred_ex_id",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "cred_rev_id",
            "baseName": "cred_rev_id",
            "type": "string"
        },
        {
            "name": "notify",
            "baseName": "notify",
            "type": "boolean"
        },
        {
            "name": "publish",
            "baseName": "publish",
            "type": "boolean"
        },
        {
            "name": "rev_reg_id",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RevokeRequest.attributeTypeMap;
    }
}

export class RouteRecord {
    'connection_id'?: string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    'recipient_key': string;
    'record_id'?: string;
    'role'?: string;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;
    'wallet_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "recipient_key",
            "baseName": "recipient_key",
            "type": "string"
        },
        {
            "name": "record_id",
            "baseName": "record_id",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "wallet_id",
            "baseName": "wallet_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RouteRecord.attributeTypeMap;
    }
}

export class Schema {
    /**
    * Schema attribute names
    */
    'attrNames'?: Array<string>;
    /**
    * Schema identifier
    */
    'id'?: string;
    /**
    * Schema name
    */
    'name'?: string;
    /**
    * Schema sequence number
    */
    'seqNo'?: number;
    /**
    * Node protocol version
    */
    'ver'?: string;
    /**
    * Schema version
    */
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attrNames",
            "baseName": "attrNames",
            "type": "Array<string>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "seqNo",
            "baseName": "seqNo",
            "type": "number"
        },
        {
            "name": "ver",
            "baseName": "ver",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Schema.attributeTypeMap;
    }
}

export class SchemaGetResult {
    'schema'?: Schema;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schema",
            "baseName": "schema",
            "type": "Schema"
        }    ];

    static getAttributeTypeMap() {
        return SchemaGetResult.attributeTypeMap;
    }
}

export class SchemaInputDescriptor {
    /**
    * Required
    */
    'required'?: boolean;
    /**
    * URI
    */
    'uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SchemaInputDescriptor.attributeTypeMap;
    }
}

export class SchemaSendRequest {
    /**
    * List of schema attributes
    */
    'attributes': Array<string>;
    /**
    * Schema name
    */
    'schema_name': string;
    /**
    * Schema version
    */
    'schema_version': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<string>"
        },
        {
            "name": "schema_name",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schema_version",
            "baseName": "schema_version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SchemaSendRequest.attributeTypeMap;
    }
}

export class SchemaSendResult {
    /**
    * Schema definition
    */
    'schema'?: any;
    /**
    * Schema identifier
    */
    'schema_id': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schema",
            "baseName": "schema",
            "type": "any"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SchemaSendResult.attributeTypeMap;
    }
}

export class SchemasCreatedResult {
    'schema_ids'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schema_ids",
            "baseName": "schema_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SchemasCreatedResult.attributeTypeMap;
    }
}

export class SchemasInputDescriptorFilter {
    /**
    * oneOf
    */
    'oneof_filter'?: boolean;
    'uri_groups'?: Array<Array<SchemaInputDescriptor>>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "oneof_filter",
            "baseName": "oneof_filter",
            "type": "boolean"
        },
        {
            "name": "uri_groups",
            "baseName": "uri_groups",
            "type": "Array<Array<SchemaInputDescriptor>>"
        }    ];

    static getAttributeTypeMap() {
        return SchemasInputDescriptorFilter.attributeTypeMap;
    }
}

export class SendMenu {
    /**
    * Menu to send to connection
    */
    'menu': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "menu",
            "baseName": "menu",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return SendMenu.attributeTypeMap;
    }
}

export class SendMessage {
    /**
    * Message content
    */
    'content'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendMessage.attributeTypeMap;
    }
}

export class SignRequest {
    'doc': Doc;
    /**
    * Verkey to use for signing
    */
    'verkey': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "doc",
            "baseName": "doc",
            "type": "Doc"
        },
        {
            "name": "verkey",
            "baseName": "verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SignRequest.attributeTypeMap;
    }
}

export class SignResponse {
    /**
    * Error text
    */
    'error'?: string;
    /**
    * Signed document
    */
    'signed_doc'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "signed_doc",
            "baseName": "signed_doc",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return SignResponse.attributeTypeMap;
    }
}

export class SignatureOptions {
    'challenge'?: string;
    'domain'?: string;
    'proofPurpose': string;
    'type'?: string;
    'verificationMethod': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenge",
            "baseName": "challenge",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "proofPurpose",
            "baseName": "proofPurpose",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "verificationMethod",
            "baseName": "verificationMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SignatureOptions.attributeTypeMap;
    }
}

export class SignedDoc {
    /**
    * Linked data proof
    */
    'proof': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "proof",
            "baseName": "proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return SignedDoc.attributeTypeMap;
    }
}

export class SubmissionRequirements {
    /**
    * Count Value
    */
    'count'?: number;
    /**
    * From
    */
    'from'?: string;
    'from_nested'?: Array<SubmissionRequirements>;
    /**
    * Max Value
    */
    'max'?: number;
    /**
    * Min Value
    */
    'min'?: number;
    /**
    * Name
    */
    'name'?: string;
    /**
    * Purpose
    */
    'purpose'?: string;
    /**
    * Selection
    */
    'rule'?: SubmissionRequirements.RuleEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "from_nested",
            "baseName": "from_nested",
            "type": "Array<SubmissionRequirements>"
        },
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "purpose",
            "baseName": "purpose",
            "type": "string"
        },
        {
            "name": "rule",
            "baseName": "rule",
            "type": "SubmissionRequirements.RuleEnum"
        }    ];

    static getAttributeTypeMap() {
        return SubmissionRequirements.attributeTypeMap;
    }
}

export namespace SubmissionRequirements {
    export enum RuleEnum {
        All = <any> 'all',
        Pick = <any> 'pick'
    }
}
export class TAAAccept {
    'mechanism'?: string;
    'text'?: string;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mechanism",
            "baseName": "mechanism",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TAAAccept.attributeTypeMap;
    }
}

export class TAAAcceptance {
    'mechanism'?: string;
    'time'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mechanism",
            "baseName": "mechanism",
            "type": "string"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TAAAcceptance.attributeTypeMap;
    }
}

export class TAAInfo {
    'aml_record'?: AMLRecord;
    'taa_accepted'?: TAAAcceptance;
    'taa_record'?: TAARecord;
    'taa_required'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aml_record",
            "baseName": "aml_record",
            "type": "AMLRecord"
        },
        {
            "name": "taa_accepted",
            "baseName": "taa_accepted",
            "type": "TAAAcceptance"
        },
        {
            "name": "taa_record",
            "baseName": "taa_record",
            "type": "TAARecord"
        },
        {
            "name": "taa_required",
            "baseName": "taa_required",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TAAInfo.attributeTypeMap;
    }
}

export class TAARecord {
    'digest'?: string;
    'text'?: string;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "digest",
            "baseName": "digest",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TAARecord.attributeTypeMap;
    }
}

export class TAAResult {
    'result'?: TAAInfo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "TAAInfo"
        }    ];

    static getAttributeTypeMap() {
        return TAAResult.attributeTypeMap;
    }
}

export class TransactionJobs {
    /**
    * My transaction related job
    */
    'transaction_my_job'?: TransactionJobs.TransactionMyJobEnum;
    /**
    * Their transaction related job
    */
    'transaction_their_job'?: TransactionJobs.TransactionTheirJobEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transaction_my_job",
            "baseName": "transaction_my_job",
            "type": "TransactionJobs.TransactionMyJobEnum"
        },
        {
            "name": "transaction_their_job",
            "baseName": "transaction_their_job",
            "type": "TransactionJobs.TransactionTheirJobEnum"
        }    ];

    static getAttributeTypeMap() {
        return TransactionJobs.attributeTypeMap;
    }
}

export namespace TransactionJobs {
    export enum TransactionMyJobEnum {
        TRANSACTIONAUTHOR = <any> 'TRANSACTION_AUTHOR',
        TRANSACTIONENDORSER = <any> 'TRANSACTION_ENDORSER',
        Reset = <any> 'reset'
    }
    export enum TransactionTheirJobEnum {
        TRANSACTIONAUTHOR = <any> 'TRANSACTION_AUTHOR',
        TRANSACTIONENDORSER = <any> 'TRANSACTION_ENDORSER',
        Reset = <any> 'reset'
    }
}
export class TransactionList {
    /**
    * List of transaction records
    */
    'results'?: Array<TransactionRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<TransactionRecord>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionList.attributeTypeMap;
    }
}

export class TransactionRecord {
    /**
    * Transaction type
    */
    '_type'?: string;
    /**
    * The connection identifier for thie particular transaction record
    */
    'connection_id'?: string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * If True, Endorser will write the transaction after endorsing it
    */
    'endorser_write_txn'?: boolean;
    'formats'?: Array<{ [key: string]: string; }>;
    'messages_attach'?: Array<any>;
    'meta_data'?: any;
    'signature_request'?: Array<any>;
    'signature_response'?: Array<any>;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Thread Identifier
    */
    'thread_id'?: string;
    'timing'?: any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Transaction identifier
    */
    'transaction_id'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_type",
            "baseName": "_type",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "endorser_write_txn",
            "baseName": "endorser_write_txn",
            "type": "boolean"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<{ [key: string]: string; }>"
        },
        {
            "name": "messages_attach",
            "baseName": "messages_attach",
            "type": "Array<any>"
        },
        {
            "name": "meta_data",
            "baseName": "meta_data",
            "type": "any"
        },
        {
            "name": "signature_request",
            "baseName": "signature_request",
            "type": "Array<any>"
        },
        {
            "name": "signature_response",
            "baseName": "signature_response",
            "type": "Array<any>"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "timing",
            "baseName": "timing",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "transaction_id",
            "baseName": "transaction_id",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TransactionRecord.attributeTypeMap;
    }
}

export class TxnOrCredentialDefinitionSendResult {
    'sent'?: CredentialDefinitionSendResult;
    /**
    * Credential definition transaction to endorse
    */
    'txn'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sent",
            "baseName": "sent",
            "type": "CredentialDefinitionSendResult"
        },
        {
            "name": "txn",
            "baseName": "txn",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return TxnOrCredentialDefinitionSendResult.attributeTypeMap;
    }
}

export class TxnOrPublishRevocationsResult {
    'sent'?: PublishRevocations;
    /**
    * Revocation registry revocations transaction to endorse
    */
    'txn'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sent",
            "baseName": "sent",
            "type": "PublishRevocations"
        },
        {
            "name": "txn",
            "baseName": "txn",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return TxnOrPublishRevocationsResult.attributeTypeMap;
    }
}

export class TxnOrRevRegResult {
    'sent'?: RevRegResult;
    /**
    * Revocation registry definition transaction to endorse
    */
    'txn'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sent",
            "baseName": "sent",
            "type": "RevRegResult"
        },
        {
            "name": "txn",
            "baseName": "txn",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return TxnOrRevRegResult.attributeTypeMap;
    }
}

export class TxnOrSchemaSendResult {
    /**
    * Content sent
    */
    'sent'?: any;
    /**
    * Schema transaction to endorse
    */
    'txn'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sent",
            "baseName": "sent",
            "type": "any"
        },
        {
            "name": "txn",
            "baseName": "txn",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return TxnOrSchemaSendResult.attributeTypeMap;
    }
}

export class UpdateWalletRequest {
    /**
    * Image url for this wallet. This image url is publicized            (self-attested) to other agents as part of forming a connection.
    */
    'image_url'?: string;
    /**
    * Label for this wallet. This label is publicized            (self-attested) to other agents as part of forming a connection.
    */
    'label'?: string;
    /**
    * Webhook target dispatch type for this wallet.             default - Dispatch only to webhooks associated with this wallet.             base - Dispatch only to webhooks associated with the base wallet.             both - Dispatch to both webhook targets.
    */
    'wallet_dispatch_type'?: UpdateWalletRequest.WalletDispatchTypeEnum;
    /**
    * List of Webhook URLs associated with this subwallet
    */
    'wallet_webhook_urls'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "image_url",
            "baseName": "image_url",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "wallet_dispatch_type",
            "baseName": "wallet_dispatch_type",
            "type": "UpdateWalletRequest.WalletDispatchTypeEnum"
        },
        {
            "name": "wallet_webhook_urls",
            "baseName": "wallet_webhook_urls",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWalletRequest.attributeTypeMap;
    }
}

export namespace UpdateWalletRequest {
    export enum WalletDispatchTypeEnum {
        Default = <any> 'default',
        Both = <any> 'both',
        Base = <any> 'base'
    }
}
export class V10CredentialBoundOfferRequest {
    /**
    * Optional counter-proposal
    */
    'counter_proposal'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "counter_proposal",
            "baseName": "counter_proposal",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialBoundOfferRequest.attributeTypeMap;
    }
}

export class V10CredentialConnFreeOfferRequest {
    /**
    * Whether to respond automatically to credential requests, creating and issuing requested credentials
    */
    'auto_issue'?: boolean;
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Credential definition identifier
    */
    'cred_def_id': string;
    'credential_preview': CredentialPreview;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_issue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credential_preview",
            "baseName": "credential_preview",
            "type": "CredentialPreview"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialConnFreeOfferRequest.attributeTypeMap;
    }
}

export class V10CredentialCreate {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Credential definition identifier
    */
    'cred_def_id'?: string;
    'credential_proposal': CredentialPreview;
    /**
    * Credential issuer DID
    */
    'issuer_did'?: string;
    /**
    * Schema identifier
    */
    'schema_id'?: string;
    /**
    * Schema issuer DID
    */
    'schema_issuer_did'?: string;
    /**
    * Schema name
    */
    'schema_name'?: string;
    /**
    * Schema version
    */
    'schema_version'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credential_proposal",
            "baseName": "credential_proposal",
            "type": "CredentialPreview"
        },
        {
            "name": "issuer_did",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schema_issuer_did",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schema_name",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schema_version",
            "baseName": "schema_version",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialCreate.attributeTypeMap;
    }
}

export class V10CredentialExchange {
    /**
    * Issuer choice to issue to request in this credential exchange
    */
    'auto_issue'?: boolean;
    /**
    * Holder choice to accept offer in this credential exchange
    */
    'auto_offer'?: boolean;
    /**
    * Issuer choice to remove this credential exchange record when complete
    */
    'auto_remove'?: boolean;
    /**
    * Connection identifier
    */
    'connection_id'?: string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Credential as stored
    */
    'credential'?: any;
    /**
    * Credential definition identifier
    */
    'credential_definition_id'?: string;
    /**
    * Credential exchange identifier
    */
    'credential_exchange_id'?: string;
    /**
    * Credential identifier
    */
    'credential_id'?: string;
    /**
    * (Indy) credential offer
    */
    'credential_offer'?: any;
    /**
    * Credential offer message
    */
    'credential_offer_dict'?: any;
    /**
    * Credential proposal message
    */
    'credential_proposal_dict'?: any;
    /**
    * (Indy) credential request
    */
    'credential_request'?: any;
    /**
    * (Indy) credential request metadata
    */
    'credential_request_metadata'?: any;
    /**
    * Error message
    */
    'error_msg'?: string;
    /**
    * Issue-credential exchange initiator: self or external
    */
    'initiator'?: V10CredentialExchange.InitiatorEnum;
    /**
    * Parent thread identifier
    */
    'parent_thread_id'?: string;
    /**
    * Credential as received, prior to storage in holder wallet
    */
    'raw_credential'?: any;
    /**
    * Revocation registry identifier
    */
    'revoc_reg_id'?: string;
    /**
    * Credential identifier within revocation registry
    */
    'revocation_id'?: string;
    /**
    * Issue-credential exchange role: holder or issuer
    */
    'role'?: V10CredentialExchange.RoleEnum;
    /**
    * Schema identifier
    */
    'schema_id'?: string;
    /**
    * Issue-credential exchange state
    */
    'state'?: string;
    /**
    * Thread identifier
    */
    'thread_id'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_issue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "auto_offer",
            "baseName": "auto_offer",
            "type": "boolean"
        },
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "credential",
            "baseName": "credential",
            "type": "any"
        },
        {
            "name": "credential_definition_id",
            "baseName": "credential_definition_id",
            "type": "string"
        },
        {
            "name": "credential_exchange_id",
            "baseName": "credential_exchange_id",
            "type": "string"
        },
        {
            "name": "credential_id",
            "baseName": "credential_id",
            "type": "string"
        },
        {
            "name": "credential_offer",
            "baseName": "credential_offer",
            "type": "any"
        },
        {
            "name": "credential_offer_dict",
            "baseName": "credential_offer_dict",
            "type": "any"
        },
        {
            "name": "credential_proposal_dict",
            "baseName": "credential_proposal_dict",
            "type": "any"
        },
        {
            "name": "credential_request",
            "baseName": "credential_request",
            "type": "any"
        },
        {
            "name": "credential_request_metadata",
            "baseName": "credential_request_metadata",
            "type": "any"
        },
        {
            "name": "error_msg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "V10CredentialExchange.InitiatorEnum"
        },
        {
            "name": "parent_thread_id",
            "baseName": "parent_thread_id",
            "type": "string"
        },
        {
            "name": "raw_credential",
            "baseName": "raw_credential",
            "type": "any"
        },
        {
            "name": "revoc_reg_id",
            "baseName": "revoc_reg_id",
            "type": "string"
        },
        {
            "name": "revocation_id",
            "baseName": "revocation_id",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V10CredentialExchange.RoleEnum"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialExchange.attributeTypeMap;
    }
}

export namespace V10CredentialExchange {
    export enum InitiatorEnum {
        Self = <any> 'self',
        External = <any> 'external'
    }
    export enum RoleEnum {
        Holder = <any> 'holder',
        Issuer = <any> 'issuer'
    }
}
export class V10CredentialExchangeListResult {
    /**
    * Aries#0036 v1.0 credential exchange records
    */
    'results'?: Array<V10CredentialExchange>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<V10CredentialExchange>"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialExchangeListResult.attributeTypeMap;
    }
}

export class V10CredentialFreeOfferRequest {
    /**
    * Whether to respond automatically to credential requests, creating and issuing requested credentials
    */
    'auto_issue'?: boolean;
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    /**
    * Credential definition identifier
    */
    'cred_def_id': string;
    'credential_preview': CredentialPreview;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_issue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credential_preview",
            "baseName": "credential_preview",
            "type": "CredentialPreview"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialFreeOfferRequest.attributeTypeMap;
    }
}

export class V10CredentialIssueRequest {
    /**
    * Human-readable comment
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialIssueRequest.attributeTypeMap;
    }
}

export class V10CredentialProblemReportRequest {
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialProblemReportRequest.attributeTypeMap;
    }
}

export class V10CredentialProposalRequestMand {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    /**
    * Credential definition identifier
    */
    'cred_def_id'?: string;
    'credential_proposal': CredentialPreview;
    /**
    * Credential issuer DID
    */
    'issuer_did'?: string;
    /**
    * Schema identifier
    */
    'schema_id'?: string;
    /**
    * Schema issuer DID
    */
    'schema_issuer_did'?: string;
    /**
    * Schema name
    */
    'schema_name'?: string;
    /**
    * Schema version
    */
    'schema_version'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credential_proposal",
            "baseName": "credential_proposal",
            "type": "CredentialPreview"
        },
        {
            "name": "issuer_did",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schema_issuer_did",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schema_name",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schema_version",
            "baseName": "schema_version",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialProposalRequestMand.attributeTypeMap;
    }
}

export class V10CredentialProposalRequestOpt {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    /**
    * Credential definition identifier
    */
    'cred_def_id'?: string;
    'credential_proposal'?: CredentialPreview;
    /**
    * Credential issuer DID
    */
    'issuer_did'?: string;
    /**
    * Schema identifier
    */
    'schema_id'?: string;
    /**
    * Schema issuer DID
    */
    'schema_issuer_did'?: string;
    /**
    * Schema name
    */
    'schema_name'?: string;
    /**
    * Schema version
    */
    'schema_version'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credential_proposal",
            "baseName": "credential_proposal",
            "type": "CredentialPreview"
        },
        {
            "name": "issuer_did",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schema_issuer_did",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schema_name",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schema_version",
            "baseName": "schema_version",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialProposalRequestOpt.attributeTypeMap;
    }
}

export class V10CredentialStoreRequest {
    'credential_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential_id",
            "baseName": "credential_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialStoreRequest.attributeTypeMap;
    }
}

export class V10DiscoveryExchangeListResult {
    'results'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return V10DiscoveryExchangeListResult.attributeTypeMap;
    }
}

export class V10DiscoveryExchangeResult {
    /**
    * Discover Features v1.0 exchange record
    */
    'results'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V10DiscoveryExchangeResult.attributeTypeMap;
    }
}

export class V10DiscoveryRecord {
    /**
    * Connection identifier
    */
    'connection_id'?: string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Disclose message
    */
    'disclose'?: any;
    /**
    * Credential exchange identifier
    */
    'discovery_exchange_id'?: string;
    /**
    * Query message
    */
    'query_msg'?: any;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Thread identifier
    */
    'thread_id'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "disclose",
            "baseName": "disclose",
            "type": "any"
        },
        {
            "name": "discovery_exchange_id",
            "baseName": "discovery_exchange_id",
            "type": "string"
        },
        {
            "name": "query_msg",
            "baseName": "query_msg",
            "type": "any"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10DiscoveryRecord.attributeTypeMap;
    }
}

export class V10PresentProofModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V10PresentProofModuleResponse.attributeTypeMap;
    }
}

export class V10PresentationCreateRequestRequest {
    'comment'?: string;
    'proof_request': IndyProofRequest;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "proof_request",
            "baseName": "proof_request",
            "type": "IndyProofRequest"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationCreateRequestRequest.attributeTypeMap;
    }
}

export class V10PresentationExchange {
    /**
    * Prover choice to auto-present proof as verifier requests
    */
    'auto_present'?: boolean;
    /**
    * Connection identifier
    */
    'connection_id'?: string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Error message
    */
    'error_msg'?: string;
    /**
    * Present-proof exchange initiator: self or external
    */
    'initiator'?: V10PresentationExchange.InitiatorEnum;
    /**
    * (Indy) presentation (also known as proof)
    */
    'presentation'?: any;
    /**
    * Presentation exchange identifier
    */
    'presentation_exchange_id'?: string;
    /**
    * Presentation proposal message
    */
    'presentation_proposal_dict'?: any;
    /**
    * (Indy) presentation request (also known as proof request)
    */
    'presentation_request'?: any;
    /**
    * Presentation request message
    */
    'presentation_request_dict'?: any;
    /**
    * Present-proof exchange role: prover or verifier
    */
    'role'?: V10PresentationExchange.RoleEnum;
    /**
    * Present-proof exchange state
    */
    'state'?: string;
    /**
    * Thread identifier
    */
    'thread_id'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updated_at'?: string;
    /**
    * Whether presentation is verified: true or false
    */
    'verified'?: V10PresentationExchange.VerifiedEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_present",
            "baseName": "auto_present",
            "type": "boolean"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "error_msg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "V10PresentationExchange.InitiatorEnum"
        },
        {
            "name": "presentation",
            "baseName": "presentation",
            "type": "any"
        },
        {
            "name": "presentation_exchange_id",
            "baseName": "presentation_exchange_id",
            "type": "string"
        },
        {
            "name": "presentation_proposal_dict",
            "baseName": "presentation_proposal_dict",
            "type": "any"
        },
        {
            "name": "presentation_request",
            "baseName": "presentation_request",
            "type": "any"
        },
        {
            "name": "presentation_request_dict",
            "baseName": "presentation_request_dict",
            "type": "any"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V10PresentationExchange.RoleEnum"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "V10PresentationExchange.VerifiedEnum"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationExchange.attributeTypeMap;
    }
}

export namespace V10PresentationExchange {
    export enum InitiatorEnum {
        Self = <any> 'self',
        External = <any> 'external'
    }
    export enum RoleEnum {
        Prover = <any> 'prover',
        Verifier = <any> 'verifier'
    }
    export enum VerifiedEnum {
        True = <any> 'true',
        False = <any> 'false'
    }
}
export class V10PresentationExchangeList {
    /**
    * Aries RFC 37 v1.0 presentation exchange records
    */
    'results'?: Array<V10PresentationExchange>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<V10PresentationExchange>"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationExchangeList.attributeTypeMap;
    }
}

export class V10PresentationProblemReportRequest {
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationProblemReportRequest.attributeTypeMap;
    }
}

export class V10PresentationProposalRequest {
    /**
    * Whether to respond automatically to presentation requests, building and presenting requested proof
    */
    'auto_present'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    'presentation_proposal': IndyPresPreview;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_present",
            "baseName": "auto_present",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "presentation_proposal",
            "baseName": "presentation_proposal",
            "type": "IndyPresPreview"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationProposalRequest.attributeTypeMap;
    }
}

export class V10PresentationSendRequestRequest {
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    'proof_request': IndyProofRequest;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "proof_request",
            "baseName": "proof_request",
            "type": "IndyProofRequest"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationSendRequestRequest.attributeTypeMap;
    }
}

export class V20CredAttrSpec {
    /**
    * MIME type: omit for (null) default
    */
    'mime_type'?: string;
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Attribute value: base64-encode if MIME type is present
    */
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mime_type",
            "baseName": "mime-type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredAttrSpec.attributeTypeMap;
    }
}

export class V20CredBoundOfferRequest {
    /**
    * Optional content for counter-proposal
    */
    'counter_preview'?: any;
    /**
    * Credential specification criteria by format
    */
    'filter'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "counter_preview",
            "baseName": "counter_preview",
            "type": "any"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20CredBoundOfferRequest.attributeTypeMap;
    }
}

export class V20CredExFree {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    'credential_preview'?: V20CredPreview;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "credential_preview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExFree.attributeTypeMap;
    }
}

export class V20CredExRecord {
    /**
    * Issuer choice to issue to request in this credential exchange
    */
    'auto_issue'?: boolean;
    /**
    * Holder choice to accept offer in this credential exchange
    */
    'auto_offer'?: boolean;
    /**
    * Issuer choice to remove this credential exchange record when complete
    */
    'auto_remove'?: boolean;
    /**
    * Attachment content by format for proposal, offer, request, and issue
    */
    'by_format'?: any;
    /**
    * Connection identifier
    */
    'connection_id'?: string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Credential exchange identifier
    */
    'cred_ex_id'?: string;
    /**
    * Serialized credential issue message
    */
    'cred_issue'?: any;
    /**
    * Credential offer message
    */
    'cred_offer'?: any;
    /**
    * Credential preview from credential proposal
    */
    'cred_preview'?: any;
    /**
    * Credential proposal message
    */
    'cred_proposal'?: any;
    /**
    * Serialized credential request message
    */
    'cred_request'?: any;
    /**
    * Error message
    */
    'error_msg'?: string;
    /**
    * Issue-credential exchange initiator: self or external
    */
    'initiator'?: V20CredExRecord.InitiatorEnum;
    /**
    * Parent thread identifier
    */
    'parent_thread_id'?: string;
    /**
    * Issue-credential exchange role: holder or issuer
    */
    'role'?: V20CredExRecord.RoleEnum;
    /**
    * Issue-credential exchange state
    */
    'state'?: V20CredExRecord.StateEnum;
    /**
    * Thread identifier
    */
    'thread_id'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_issue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "auto_offer",
            "baseName": "auto_offer",
            "type": "boolean"
        },
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "by_format",
            "baseName": "by_format",
            "type": "any"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "cred_ex_id",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "cred_issue",
            "baseName": "cred_issue",
            "type": "any"
        },
        {
            "name": "cred_offer",
            "baseName": "cred_offer",
            "type": "any"
        },
        {
            "name": "cred_preview",
            "baseName": "cred_preview",
            "type": "any"
        },
        {
            "name": "cred_proposal",
            "baseName": "cred_proposal",
            "type": "any"
        },
        {
            "name": "cred_request",
            "baseName": "cred_request",
            "type": "any"
        },
        {
            "name": "error_msg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "V20CredExRecord.InitiatorEnum"
        },
        {
            "name": "parent_thread_id",
            "baseName": "parent_thread_id",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V20CredExRecord.RoleEnum"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "V20CredExRecord.StateEnum"
        },
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecord.attributeTypeMap;
    }
}

export namespace V20CredExRecord {
    export enum InitiatorEnum {
        Self = <any> 'self',
        External = <any> 'external'
    }
    export enum RoleEnum {
        Issuer = <any> 'issuer',
        Holder = <any> 'holder'
    }
    export enum StateEnum {
        ProposalSent = <any> 'proposal-sent',
        ProposalReceived = <any> 'proposal-received',
        OfferSent = <any> 'offer-sent',
        OfferReceived = <any> 'offer-received',
        RequestSent = <any> 'request-sent',
        RequestReceived = <any> 'request-received',
        CredentialIssued = <any> 'credential-issued',
        CredentialReceived = <any> 'credential-received',
        Done = <any> 'done',
        CredentialRevoked = <any> 'credential-revoked'
    }
}
export class V20CredExRecordByFormat {
    'cred_issue'?: any;
    'cred_offer'?: any;
    'cred_proposal'?: any;
    'cred_request'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_issue",
            "baseName": "cred_issue",
            "type": "any"
        },
        {
            "name": "cred_offer",
            "baseName": "cred_offer",
            "type": "any"
        },
        {
            "name": "cred_proposal",
            "baseName": "cred_proposal",
            "type": "any"
        },
        {
            "name": "cred_request",
            "baseName": "cred_request",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordByFormat.attributeTypeMap;
    }
}

export class V20CredExRecordDetail {
    /**
    * Credential exchange record
    */
    'cred_ex_record'?: any;
    'indy'?: V20CredExRecordIndy;
    'ld_proof'?: V20CredExRecordLDProof;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_ex_record",
            "baseName": "cred_ex_record",
            "type": "any"
        },
        {
            "name": "indy",
            "baseName": "indy",
            "type": "V20CredExRecordIndy"
        },
        {
            "name": "ld_proof",
            "baseName": "ld_proof",
            "type": "V20CredExRecordLDProof"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordDetail.attributeTypeMap;
    }
}

export class V20CredExRecordIndy {
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Corresponding v2.0 credential exchange record identifier
    */
    'cred_ex_id'?: string;
    /**
    * Record identifier
    */
    'cred_ex_indy_id'?: string;
    /**
    * Credential identifier stored in wallet
    */
    'cred_id_stored'?: string;
    /**
    * Credential request metadata for indy holder
    */
    'cred_request_metadata'?: any;
    /**
    * Credential revocation identifier within revocation registry
    */
    'cred_rev_id'?: string;
    /**
    * Revocation registry identifier
    */
    'rev_reg_id'?: string;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "cred_ex_id",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "cred_ex_indy_id",
            "baseName": "cred_ex_indy_id",
            "type": "string"
        },
        {
            "name": "cred_id_stored",
            "baseName": "cred_id_stored",
            "type": "string"
        },
        {
            "name": "cred_request_metadata",
            "baseName": "cred_request_metadata",
            "type": "any"
        },
        {
            "name": "cred_rev_id",
            "baseName": "cred_rev_id",
            "type": "string"
        },
        {
            "name": "rev_reg_id",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordIndy.attributeTypeMap;
    }
}

export class V20CredExRecordLDProof {
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Corresponding v2.0 credential exchange record identifier
    */
    'cred_ex_id'?: string;
    /**
    * Record identifier
    */
    'cred_ex_ld_proof_id'?: string;
    /**
    * Credential identifier stored in wallet
    */
    'cred_id_stored'?: string;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "cred_ex_id",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "cred_ex_ld_proof_id",
            "baseName": "cred_ex_ld_proof_id",
            "type": "string"
        },
        {
            "name": "cred_id_stored",
            "baseName": "cred_id_stored",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordLDProof.attributeTypeMap;
    }
}

export class V20CredExRecordListResult {
    /**
    * Credential exchange records and corresponding detail records
    */
    'results'?: Array<V20CredExRecordDetail>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<V20CredExRecordDetail>"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordListResult.attributeTypeMap;
    }
}

export class V20CredFilter {
    /**
    * Credential filter for indy
    */
    'indy'?: any;
    /**
    * Credential filter for linked data proof
    */
    'ld_proof'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "indy",
            "baseName": "indy",
            "type": "any"
        },
        {
            "name": "ld_proof",
            "baseName": "ld_proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20CredFilter.attributeTypeMap;
    }
}

export class V20CredFilterIndy {
    /**
    * Credential definition identifier
    */
    'cred_def_id'?: string;
    /**
    * Credential issuer DID
    */
    'issuer_did'?: string;
    /**
    * Schema identifier
    */
    'schema_id'?: string;
    /**
    * Schema issuer DID
    */
    'schema_issuer_did'?: string;
    /**
    * Schema name
    */
    'schema_name'?: string;
    /**
    * Schema version
    */
    'schema_version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cred_def_id",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "issuer_did",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schema_id",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schema_issuer_did",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schema_name",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schema_version",
            "baseName": "schema_version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredFilterIndy.attributeTypeMap;
    }
}

export class V20CredFilterLDProof {
    /**
    * Credential filter for linked data proof
    */
    'ld_proof': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ld_proof",
            "baseName": "ld_proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20CredFilterLDProof.attributeTypeMap;
    }
}

export class V20CredFormat {
    /**
    * Attachment identifier
    */
    'attach_id': string;
    /**
    * Attachment format specifier
    */
    'format': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attach_id",
            "baseName": "attach_id",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredFormat.attributeTypeMap;
    }
}

export class V20CredIssue {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Credential attachments
    */
    'credentialsattach': Array<AttachDecorator>;
    /**
    * Acceptable attachment formats
    */
    'formats': Array<V20CredFormat>;
    /**
    * Issuer-unique identifier to coordinate credential replacement
    */
    'replacement_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credentialsattach",
            "baseName": "credentials~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20CredFormat>"
        },
        {
            "name": "replacement_id",
            "baseName": "replacement_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredIssue.attributeTypeMap;
    }
}

export class V20CredIssueProblemReportRequest {
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredIssueProblemReportRequest.attributeTypeMap;
    }
}

export class V20CredIssueRequest {
    /**
    * Human-readable comment
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredIssueRequest.attributeTypeMap;
    }
}

export class V20CredOffer {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'credential_preview'?: V20CredPreview;
    /**
    * Acceptable credential formats
    */
    'formats': Array<V20CredFormat>;
    /**
    * Offer attachments
    */
    'offersattach': Array<AttachDecorator>;
    /**
    * Issuer-unique identifier to coordinate credential replacement
    */
    'replacement_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credential_preview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20CredFormat>"
        },
        {
            "name": "offersattach",
            "baseName": "offers~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "replacement_id",
            "baseName": "replacement_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredOffer.attributeTypeMap;
    }
}

export class V20CredOfferConnFreeRequest {
    /**
    * Whether to respond automatically to credential requests, creating and issuing requested credentials
    */
    'auto_issue'?: boolean;
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'credential_preview'?: V20CredPreview;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_issue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credential_preview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20CredOfferConnFreeRequest.attributeTypeMap;
    }
}

export class V20CredOfferRequest {
    /**
    * Whether to respond automatically to credential requests, creating and issuing requested credentials
    */
    'auto_issue'?: boolean;
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    'credential_preview'?: V20CredPreview;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_issue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "credential_preview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20CredOfferRequest.attributeTypeMap;
    }
}

export class V20CredPreview {
    /**
    * Message type identifier
    */
    'type'?: string;
    'attributes': Array<V20CredAttrSpec>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<V20CredAttrSpec>"
        }    ];

    static getAttributeTypeMap() {
        return V20CredPreview.attributeTypeMap;
    }
}

export class V20CredProposal {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Credential preview
    */
    'credential_preview'?: any;
    /**
    * Credential filter per acceptable format on corresponding identifier
    */
    'filtersattach': Array<AttachDecorator>;
    /**
    * Attachment formats
    */
    'formats': Array<V20CredFormat>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credential_preview",
            "baseName": "credential_preview",
            "type": "any"
        },
        {
            "name": "filtersattach",
            "baseName": "filters~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20CredFormat>"
        }    ];

    static getAttributeTypeMap() {
        return V20CredProposal.attributeTypeMap;
    }
}

export class V20CredRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Acceptable attachment formats
    */
    'formats': Array<V20CredFormat>;
    /**
    * Request attachments
    */
    'requestsattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20CredFormat>"
        },
        {
            "name": "requestsattach",
            "baseName": "requests~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return V20CredRequest.attributeTypeMap;
    }
}

export class V20CredRequestFree {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Holder DID to substitute for the credentialSubject.id
    */
    'holder_did'?: string;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "holder_did",
            "baseName": "holder_did",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20CredRequestFree.attributeTypeMap;
    }
}

export class V20CredRequestRequest {
    /**
    * Holder DID to substitute for the credentialSubject.id
    */
    'holder_did'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "holder_did",
            "baseName": "holder_did",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredRequestRequest.attributeTypeMap;
    }
}

export class V20CredStoreRequest {
    'credential_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential_id",
            "baseName": "credential_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredStoreRequest.attributeTypeMap;
    }
}

export class V20DiscoveryExchangeListResult {
    'results'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return V20DiscoveryExchangeListResult.attributeTypeMap;
    }
}

export class V20DiscoveryExchangeResult {
    /**
    * Discover Features v2.0 exchange record
    */
    'results'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20DiscoveryExchangeResult.attributeTypeMap;
    }
}

export class V20DiscoveryRecord {
    /**
    * Connection identifier
    */
    'connection_id'?: string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Disclosures message
    */
    'disclosures'?: any;
    /**
    * Credential exchange identifier
    */
    'discovery_exchange_id'?: string;
    /**
    * Queries message
    */
    'queries_msg'?: any;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Thread identifier
    */
    'thread_id'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updated_at'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "disclosures",
            "baseName": "disclosures",
            "type": "any"
        },
        {
            "name": "discovery_exchange_id",
            "baseName": "discovery_exchange_id",
            "type": "string"
        },
        {
            "name": "queries_msg",
            "baseName": "queries_msg",
            "type": "any"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20DiscoveryRecord.attributeTypeMap;
    }
}

export class V20IssueCredSchemaCore {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'auto_remove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'credential_preview'?: V20CredPreview;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_remove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credential_preview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20IssueCredSchemaCore.attributeTypeMap;
    }
}

export class V20IssueCredentialModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V20IssueCredentialModuleResponse.attributeTypeMap;
    }
}

export class V20Pres {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Acceptable attachment formats
    */
    'formats': Array<V20PresFormat>;
    'presentationsattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20PresFormat>"
        },
        {
            "name": "presentationsattach",
            "baseName": "presentations~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return V20Pres.attributeTypeMap;
    }
}

export class V20PresCreateRequestRequest {
    'comment'?: string;
    'presentation_request': V20PresRequestByFormat;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "presentation_request",
            "baseName": "presentation_request",
            "type": "V20PresRequestByFormat"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresCreateRequestRequest.attributeTypeMap;
    }
}

export class V20PresExRecord {
    /**
    * Prover choice to auto-present proof as verifier requests
    */
    'auto_present'?: boolean;
    /**
    * Attachment content by format for proposal, request, and presentation
    */
    'by_format'?: any;
    /**
    * Connection identifier
    */
    'connection_id'?: string;
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Error message
    */
    'error_msg'?: string;
    /**
    * Present-proof exchange initiator: self or external
    */
    'initiator'?: V20PresExRecord.InitiatorEnum;
    /**
    * Presentation message
    */
    'pres'?: any;
    /**
    * Presentation exchange identifier
    */
    'pres_ex_id'?: string;
    /**
    * Presentation proposal message
    */
    'pres_proposal'?: any;
    /**
    * Presentation request message
    */
    'pres_request'?: any;
    /**
    * Present-proof exchange role: prover or verifier
    */
    'role'?: V20PresExRecord.RoleEnum;
    /**
    * Present-proof exchange state
    */
    'state'?: V20PresExRecord.StateEnum;
    /**
    * Thread identifier
    */
    'thread_id'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updated_at'?: string;
    /**
    * Whether presentation is verified: 'true' or 'false'
    */
    'verified'?: V20PresExRecord.VerifiedEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_present",
            "baseName": "auto_present",
            "type": "boolean"
        },
        {
            "name": "by_format",
            "baseName": "by_format",
            "type": "any"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "error_msg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "V20PresExRecord.InitiatorEnum"
        },
        {
            "name": "pres",
            "baseName": "pres",
            "type": "any"
        },
        {
            "name": "pres_ex_id",
            "baseName": "pres_ex_id",
            "type": "string"
        },
        {
            "name": "pres_proposal",
            "baseName": "pres_proposal",
            "type": "any"
        },
        {
            "name": "pres_request",
            "baseName": "pres_request",
            "type": "any"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V20PresExRecord.RoleEnum"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "V20PresExRecord.StateEnum"
        },
        {
            "name": "thread_id",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "V20PresExRecord.VerifiedEnum"
        }    ];

    static getAttributeTypeMap() {
        return V20PresExRecord.attributeTypeMap;
    }
}

export namespace V20PresExRecord {
    export enum InitiatorEnum {
        Self = <any> 'self',
        External = <any> 'external'
    }
    export enum RoleEnum {
        Prover = <any> 'prover',
        Verifier = <any> 'verifier'
    }
    export enum StateEnum {
        ProposalSent = <any> 'proposal-sent',
        ProposalReceived = <any> 'proposal-received',
        RequestSent = <any> 'request-sent',
        RequestReceived = <any> 'request-received',
        PresentationSent = <any> 'presentation-sent',
        PresentationReceived = <any> 'presentation-received',
        Done = <any> 'done',
        Abandoned = <any> 'abandoned'
    }
    export enum VerifiedEnum {
        True = <any> 'true',
        False = <any> 'false'
    }
}
export class V20PresExRecordByFormat {
    'pres'?: any;
    'pres_proposal'?: any;
    'pres_request'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pres",
            "baseName": "pres",
            "type": "any"
        },
        {
            "name": "pres_proposal",
            "baseName": "pres_proposal",
            "type": "any"
        },
        {
            "name": "pres_request",
            "baseName": "pres_request",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20PresExRecordByFormat.attributeTypeMap;
    }
}

export class V20PresExRecordList {
    /**
    * Presentation exchange records
    */
    'results'?: Array<V20PresExRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<V20PresExRecord>"
        }    ];

    static getAttributeTypeMap() {
        return V20PresExRecordList.attributeTypeMap;
    }
}

export class V20PresFormat {
    /**
    * Attachment identifier
    */
    'attach_id': string;
    /**
    * Attachment format specifier
    */
    'format': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attach_id",
            "baseName": "attach_id",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20PresFormat.attributeTypeMap;
    }
}

export class V20PresProblemReportRequest {
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20PresProblemReportRequest.attributeTypeMap;
    }
}

export class V20PresProposal {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'formats': Array<V20PresFormat>;
    /**
    * Attachment per acceptable format on corresponding identifier
    */
    'proposalsattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20PresFormat>"
        },
        {
            "name": "proposalsattach",
            "baseName": "proposals~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return V20PresProposal.attributeTypeMap;
    }
}

export class V20PresProposalByFormat {
    /**
    * Presentation proposal for DIF
    */
    'dif'?: any;
    /**
    * Presentation proposal for indy
    */
    'indy'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dif",
            "baseName": "dif",
            "type": "any"
        },
        {
            "name": "indy",
            "baseName": "indy",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20PresProposalByFormat.attributeTypeMap;
    }
}

export class V20PresProposalRequest {
    /**
    * Whether to respond automatically to presentation requests, building and presenting requested proof
    */
    'auto_present'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    'presentation_proposal': V20PresProposalByFormat;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auto_present",
            "baseName": "auto_present",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "presentation_proposal",
            "baseName": "presentation_proposal",
            "type": "V20PresProposalByFormat"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresProposalRequest.attributeTypeMap;
    }
}

export class V20PresRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'formats': Array<V20PresFormat>;
    /**
    * Attachment per acceptable format on corresponding identifier
    */
    'request_presentationsattach': Array<AttachDecorator>;
    /**
    * Whether verifier will send confirmation ack
    */
    'will_confirm'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20PresFormat>"
        },
        {
            "name": "request_presentationsattach",
            "baseName": "request_presentations~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "will_confirm",
            "baseName": "will_confirm",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresRequest.attributeTypeMap;
    }
}

export class V20PresRequestByFormat {
    /**
    * Presentation request for DIF
    */
    'dif'?: any;
    /**
    * Presentation request for indy
    */
    'indy'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dif",
            "baseName": "dif",
            "type": "any"
        },
        {
            "name": "indy",
            "baseName": "indy",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20PresRequestByFormat.attributeTypeMap;
    }
}

export class V20PresSendRequestRequest {
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connection_id': string;
    'presentation_request': V20PresRequestByFormat;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connection_id",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "presentation_request",
            "baseName": "presentation_request",
            "type": "V20PresRequestByFormat"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresSendRequestRequest.attributeTypeMap;
    }
}

export class V20PresSpecByFormatRequest {
    /**
    * Optional Presentation specification for DIF, overrides the PresentionExchange record's PresRequest
    */
    'dif'?: any;
    /**
    * Presentation specification for indy
    */
    'indy'?: any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dif",
            "baseName": "dif",
            "type": "any"
        },
        {
            "name": "indy",
            "baseName": "indy",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresSpecByFormatRequest.attributeTypeMap;
    }
}

export class V20PresentProofModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V20PresentProofModuleResponse.attributeTypeMap;
    }
}

export class VCRecord {
    'contexts'?: Array<string>;
    'cred_tags'?: { [key: string]: string; };
    /**
    * (JSON-serializable) credential value
    */
    'cred_value'?: any;
    'expanded_types'?: Array<string>;
    /**
    * Credential identifier
    */
    'given_id'?: string;
    /**
    * Issuer identifier
    */
    'issuer_id'?: string;
    'proof_types'?: Array<string>;
    /**
    * Record identifier
    */
    'record_id'?: string;
    'schema_ids'?: Array<string>;
    'subject_ids'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contexts",
            "baseName": "contexts",
            "type": "Array<string>"
        },
        {
            "name": "cred_tags",
            "baseName": "cred_tags",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "cred_value",
            "baseName": "cred_value",
            "type": "any"
        },
        {
            "name": "expanded_types",
            "baseName": "expanded_types",
            "type": "Array<string>"
        },
        {
            "name": "given_id",
            "baseName": "given_id",
            "type": "string"
        },
        {
            "name": "issuer_id",
            "baseName": "issuer_id",
            "type": "string"
        },
        {
            "name": "proof_types",
            "baseName": "proof_types",
            "type": "Array<string>"
        },
        {
            "name": "record_id",
            "baseName": "record_id",
            "type": "string"
        },
        {
            "name": "schema_ids",
            "baseName": "schema_ids",
            "type": "Array<string>"
        },
        {
            "name": "subject_ids",
            "baseName": "subject_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return VCRecord.attributeTypeMap;
    }
}

export class VCRecordList {
    'results'?: Array<VCRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<VCRecord>"
        }    ];

    static getAttributeTypeMap() {
        return VCRecordList.attributeTypeMap;
    }
}

export class VerifyRequest {
    /**
    * Signed document
    */
    'doc': any;
    /**
    * Verkey to use for doc verification
    */
    'verkey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "doc",
            "baseName": "doc",
            "type": "any"
        },
        {
            "name": "verkey",
            "baseName": "verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VerifyRequest.attributeTypeMap;
    }
}

export class VerifyResponse {
    /**
    * Error text
    */
    'error'?: string;
    'valid': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "valid",
            "baseName": "valid",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VerifyResponse.attributeTypeMap;
    }
}

export class W3CCredentialsListRequest {
    'contexts'?: Array<string>;
    /**
    * Given credential id to match
    */
    'given_id'?: string;
    /**
    * Credential issuer identifier to match
    */
    'issuer_id'?: string;
    /**
    * Maximum number of results to return
    */
    'max_results'?: number;
    'proof_types'?: Array<string>;
    /**
    * Schema identifiers, all of which to match
    */
    'schema_ids'?: Array<string>;
    /**
    * Subject identifiers, all of which to match
    */
    'subject_ids'?: Array<string>;
    /**
    * Tag filter
    */
    'tag_query'?: { [key: string]: string; };
    'types'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contexts",
            "baseName": "contexts",
            "type": "Array<string>"
        },
        {
            "name": "given_id",
            "baseName": "given_id",
            "type": "string"
        },
        {
            "name": "issuer_id",
            "baseName": "issuer_id",
            "type": "string"
        },
        {
            "name": "max_results",
            "baseName": "max_results",
            "type": "number"
        },
        {
            "name": "proof_types",
            "baseName": "proof_types",
            "type": "Array<string>"
        },
        {
            "name": "schema_ids",
            "baseName": "schema_ids",
            "type": "Array<string>"
        },
        {
            "name": "subject_ids",
            "baseName": "subject_ids",
            "type": "Array<string>"
        },
        {
            "name": "tag_query",
            "baseName": "tag_query",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "types",
            "baseName": "types",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return W3CCredentialsListRequest.attributeTypeMap;
    }
}

export class WalletList {
    /**
    * List of wallet records
    */
    'results'?: Array<WalletRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<WalletRecord>"
        }    ];

    static getAttributeTypeMap() {
        return WalletList.attributeTypeMap;
    }
}

export class WalletModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return WalletModuleResponse.attributeTypeMap;
    }
}

export class WalletRecord {
    /**
    * Time of record creation
    */
    'created_at'?: string;
    /**
    * Mode regarding management of wallet key
    */
    'key_management_mode': WalletRecord.KeyManagementModeEnum;
    /**
    * Settings for this wallet.
    */
    'settings'?: any;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updated_at'?: string;
    /**
    * Wallet record ID
    */
    'wallet_id': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created_at",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "key_management_mode",
            "baseName": "key_management_mode",
            "type": "WalletRecord.KeyManagementModeEnum"
        },
        {
            "name": "settings",
            "baseName": "settings",
            "type": "any"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updated_at",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "wallet_id",
            "baseName": "wallet_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WalletRecord.attributeTypeMap;
    }
}

export namespace WalletRecord {
    export enum KeyManagementModeEnum {
        Managed = <any> 'managed',
        Unmanaged = <any> 'unmanaged'
    }
}
export class WriteLedgerRequest {
    'ledger_id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ledger_id",
            "baseName": "ledger_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WriteLedgerRequest.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AttachmentDef.TypeEnum": AttachmentDef.TypeEnum,
        "ConnRecord.AcceptEnum": ConnRecord.AcceptEnum,
        "ConnRecord.ConnectionProtocolEnum": ConnRecord.ConnectionProtocolEnum,
        "ConnRecord.InvitationModeEnum": ConnRecord.InvitationModeEnum,
        "ConnRecord.RoutingStateEnum": ConnRecord.RoutingStateEnum,
        "ConnRecord.TheirRoleEnum": ConnRecord.TheirRoleEnum,
        "Constraints.StatusActiveEnum": Constraints.StatusActiveEnum,
        "Constraints.StatusRevokedEnum": Constraints.StatusRevokedEnum,
        "Constraints.StatusSuspendedEnum": Constraints.StatusSuspendedEnum,
        "Constraints.SubjectIsIssuerEnum": Constraints.SubjectIsIssuerEnum,
        "CreateWalletRequest.KeyManagementModeEnum": CreateWalletRequest.KeyManagementModeEnum,
        "CreateWalletRequest.WalletDispatchTypeEnum": CreateWalletRequest.WalletDispatchTypeEnum,
        "CreateWalletRequest.WalletTypeEnum": CreateWalletRequest.WalletTypeEnum,
        "CreateWalletResponse.KeyManagementModeEnum": CreateWalletResponse.KeyManagementModeEnum,
        "DID.KeyTypeEnum": DID.KeyTypeEnum,
        "DID.MethodEnum": DID.MethodEnum,
        "DID.PostureEnum": DID.PostureEnum,
        "DIDCreate.MethodEnum": DIDCreate.MethodEnum,
        "DIDCreateOptions.KeyTypeEnum": DIDCreateOptions.KeyTypeEnum,
        "DIDEndpointWithType.EndpointTypeEnum": DIDEndpointWithType.EndpointTypeEnum,
        "DIFField.PredicateEnum": DIFField.PredicateEnum,
        "DIFHolder.DirectiveEnum": DIFHolder.DirectiveEnum,
        "GetNymRoleResponse.RoleEnum": GetNymRoleResponse.RoleEnum,
        "IndyGEProofPred.PTypeEnum": IndyGEProofPred.PTypeEnum,
        "IndyPresPredSpec.PredicateEnum": IndyPresPredSpec.PredicateEnum,
        "IndyProofReqPredSpec.PTypeEnum": IndyProofReqPredSpec.PTypeEnum,
        "IndyRevRegDef.RevocDefTypeEnum": IndyRevRegDef.RevocDefTypeEnum,
        "IndyRevRegDefValue.IssuanceTypeEnum": IndyRevRegDefValue.IssuanceTypeEnum,
        "IssuerRevRegRecord.RevocDefTypeEnum": IssuerRevRegRecord.RevocDefTypeEnum,
        "KeylistUpdateRule.ActionEnum": KeylistUpdateRule.ActionEnum,
        "QueryItem.FeatureTypeEnum": QueryItem.FeatureTypeEnum,
        "SubmissionRequirements.RuleEnum": SubmissionRequirements.RuleEnum,
        "TransactionJobs.TransactionMyJobEnum": TransactionJobs.TransactionMyJobEnum,
        "TransactionJobs.TransactionTheirJobEnum": TransactionJobs.TransactionTheirJobEnum,
        "UpdateWalletRequest.WalletDispatchTypeEnum": UpdateWalletRequest.WalletDispatchTypeEnum,
        "V10CredentialExchange.InitiatorEnum": V10CredentialExchange.InitiatorEnum,
        "V10CredentialExchange.RoleEnum": V10CredentialExchange.RoleEnum,
        "V10PresentationExchange.InitiatorEnum": V10PresentationExchange.InitiatorEnum,
        "V10PresentationExchange.RoleEnum": V10PresentationExchange.RoleEnum,
        "V10PresentationExchange.VerifiedEnum": V10PresentationExchange.VerifiedEnum,
        "V20CredExRecord.InitiatorEnum": V20CredExRecord.InitiatorEnum,
        "V20CredExRecord.RoleEnum": V20CredExRecord.RoleEnum,
        "V20CredExRecord.StateEnum": V20CredExRecord.StateEnum,
        "V20PresExRecord.InitiatorEnum": V20PresExRecord.InitiatorEnum,
        "V20PresExRecord.RoleEnum": V20PresExRecord.RoleEnum,
        "V20PresExRecord.StateEnum": V20PresExRecord.StateEnum,
        "V20PresExRecord.VerifiedEnum": V20PresExRecord.VerifiedEnum,
        "WalletRecord.KeyManagementModeEnum": WalletRecord.KeyManagementModeEnum,
}

let typeMap: {[index: string]: any} = {
    "AMLRecord": AMLRecord,
    "ActionMenuFetchResult": ActionMenuFetchResult,
    "ActionMenuModulesResult": ActionMenuModulesResult,
    "AdminAPIMessageTracing": AdminAPIMessageTracing,
    "AdminConfig": AdminConfig,
    "AdminMediationDeny": AdminMediationDeny,
    "AdminModules": AdminModules,
    "AdminReset": AdminReset,
    "AdminShutdown": AdminShutdown,
    "AdminStatus": AdminStatus,
    "AdminStatusLiveliness": AdminStatusLiveliness,
    "AdminStatusReadiness": AdminStatusReadiness,
    "AttachDecorator": AttachDecorator,
    "AttachDecoratorData": AttachDecoratorData,
    "AttachDecoratorData1JWS": AttachDecoratorData1JWS,
    "AttachDecoratorDataJWS": AttachDecoratorDataJWS,
    "AttachDecoratorDataJWSHeader": AttachDecoratorDataJWSHeader,
    "AttachmentDef": AttachmentDef,
    "AttributeMimeTypesResult": AttributeMimeTypesResult,
    "BasicMessageModuleResponse": BasicMessageModuleResponse,
    "ClaimFormat": ClaimFormat,
    "ClearPendingRevocationsRequest": ClearPendingRevocationsRequest,
    "ConnRecord": ConnRecord,
    "ConnectionInvitation": ConnectionInvitation,
    "ConnectionList": ConnectionList,
    "ConnectionMetadata": ConnectionMetadata,
    "ConnectionMetadataSetRequest": ConnectionMetadataSetRequest,
    "ConnectionModuleResponse": ConnectionModuleResponse,
    "ConnectionStaticRequest": ConnectionStaticRequest,
    "ConnectionStaticResult": ConnectionStaticResult,
    "Constraints": Constraints,
    "CreateInvitationRequest": CreateInvitationRequest,
    "CreateWalletRequest": CreateWalletRequest,
    "CreateWalletResponse": CreateWalletResponse,
    "CreateWalletTokenRequest": CreateWalletTokenRequest,
    "CreateWalletTokenResponse": CreateWalletTokenResponse,
    "CredAttrSpec": CredAttrSpec,
    "CredDefValue": CredDefValue,
    "CredDefValuePrimary": CredDefValuePrimary,
    "CredDefValueRevocation": CredDefValueRevocation,
    "CredInfoList": CredInfoList,
    "CredRevRecordResult": CredRevRecordResult,
    "CredRevokedResult": CredRevokedResult,
    "Credential": Credential,
    "CredentialDefinition": CredentialDefinition,
    "CredentialDefinitionGetResult": CredentialDefinitionGetResult,
    "CredentialDefinitionSendRequest": CredentialDefinitionSendRequest,
    "CredentialDefinitionSendResult": CredentialDefinitionSendResult,
    "CredentialDefinitionsCreatedResult": CredentialDefinitionsCreatedResult,
    "CredentialOffer": CredentialOffer,
    "CredentialPreview": CredentialPreview,
    "CredentialProposal": CredentialProposal,
    "CredentialStatusOptions": CredentialStatusOptions,
    "DID": DID,
    "DIDCreate": DIDCreate,
    "DIDCreateOptions": DIDCreateOptions,
    "DIDEndpoint": DIDEndpoint,
    "DIDEndpointWithType": DIDEndpointWithType,
    "DIDList": DIDList,
    "DIDResult": DIDResult,
    "DIDXRequest": DIDXRequest,
    "DIFField": DIFField,
    "DIFHolder": DIFHolder,
    "DIFOptions": DIFOptions,
    "DIFPresSpec": DIFPresSpec,
    "DIFProofProposal": DIFProofProposal,
    "DIFProofRequest": DIFProofRequest,
    "Disclose": Disclose,
    "Disclosures": Disclosures,
    "Doc": Doc,
    "EndorserInfo": EndorserInfo,
    "EndpointsResult": EndpointsResult,
    "Filter": Filter,
    "Generated": Generated,
    "GetDIDEndpointResponse": GetDIDEndpointResponse,
    "GetDIDVerkeyResponse": GetDIDVerkeyResponse,
    "GetNymRoleResponse": GetNymRoleResponse,
    "HolderModuleResponse": HolderModuleResponse,
    "IndyAttrValue": IndyAttrValue,
    "IndyCredAbstract": IndyCredAbstract,
    "IndyCredInfo": IndyCredInfo,
    "IndyCredPrecis": IndyCredPrecis,
    "IndyCredRequest": IndyCredRequest,
    "IndyCredential": IndyCredential,
    "IndyEQProof": IndyEQProof,
    "IndyGEProof": IndyGEProof,
    "IndyGEProofPred": IndyGEProofPred,
    "IndyKeyCorrectnessProof": IndyKeyCorrectnessProof,
    "IndyNonRevocProof": IndyNonRevocProof,
    "IndyNonRevocationInterval": IndyNonRevocationInterval,
    "IndyPresAttrSpec": IndyPresAttrSpec,
    "IndyPresPredSpec": IndyPresPredSpec,
    "IndyPresPreview": IndyPresPreview,
    "IndyPresSpec": IndyPresSpec,
    "IndyPrimaryProof": IndyPrimaryProof,
    "IndyProof": IndyProof,
    "IndyProofIdentifier": IndyProofIdentifier,
    "IndyProofProof": IndyProofProof,
    "IndyProofProofAggregatedProof": IndyProofProofAggregatedProof,
    "IndyProofProofProofsProof": IndyProofProofProofsProof,
    "IndyProofReqAttrSpec": IndyProofReqAttrSpec,
    "IndyProofReqAttrSpecNonRevoked": IndyProofReqAttrSpecNonRevoked,
    "IndyProofReqPredSpec": IndyProofReqPredSpec,
    "IndyProofReqPredSpecNonRevoked": IndyProofReqPredSpecNonRevoked,
    "IndyProofRequest": IndyProofRequest,
    "IndyProofRequestNonRevoked": IndyProofRequestNonRevoked,
    "IndyProofRequestedProof": IndyProofRequestedProof,
    "IndyProofRequestedProofPredicate": IndyProofRequestedProofPredicate,
    "IndyProofRequestedProofRevealedAttr": IndyProofRequestedProofRevealedAttr,
    "IndyProofRequestedProofRevealedAttrGroup": IndyProofRequestedProofRevealedAttrGroup,
    "IndyRequestedCredsRequestedAttr": IndyRequestedCredsRequestedAttr,
    "IndyRequestedCredsRequestedPred": IndyRequestedCredsRequestedPred,
    "IndyRevRegDef": IndyRevRegDef,
    "IndyRevRegDefValue": IndyRevRegDefValue,
    "IndyRevRegDefValuePublicKeys": IndyRevRegDefValuePublicKeys,
    "IndyRevRegDefValuePublicKeysAccumKey": IndyRevRegDefValuePublicKeysAccumKey,
    "IndyRevRegEntry": IndyRevRegEntry,
    "IndyRevRegEntryValue": IndyRevRegEntryValue,
    "InputDescriptors": InputDescriptors,
    "IntroModuleResponse": IntroModuleResponse,
    "InvitationCreateRequest": InvitationCreateRequest,
    "InvitationMessage": InvitationMessage,
    "InvitationRecord": InvitationRecord,
    "InvitationResult": InvitationResult,
    "IssueCredentialModuleResponse": IssueCredentialModuleResponse,
    "IssuerCredRevRecord": IssuerCredRevRecord,
    "IssuerRevRegRecord": IssuerRevRegRecord,
    "Keylist": Keylist,
    "KeylistQuery": KeylistQuery,
    "KeylistQueryFilterRequest": KeylistQueryFilterRequest,
    "KeylistQueryPaginate": KeylistQueryPaginate,
    "KeylistUpdate": KeylistUpdate,
    "KeylistUpdateRequest": KeylistUpdateRequest,
    "KeylistUpdateRule": KeylistUpdateRule,
    "LDProofVCDetail": LDProofVCDetail,
    "LDProofVCDetailOptions": LDProofVCDetailOptions,
    "LedgerConfigInstance": LedgerConfigInstance,
    "LedgerConfigList": LedgerConfigList,
    "LedgerModulesResult": LedgerModulesResult,
    "LinkedDataProof": LinkedDataProof,
    "MediationCreateRequest": MediationCreateRequest,
    "MediationDeny": MediationDeny,
    "MediationGrant": MediationGrant,
    "MediationList": MediationList,
    "MediationRecord": MediationRecord,
    "Menu": Menu,
    "MenuForm": MenuForm,
    "MenuFormParam": MenuFormParam,
    "MenuJson": MenuJson,
    "MenuOption": MenuOption,
    "ModelDate": ModelDate,
    "MultitenantModuleResponse": MultitenantModuleResponse,
    "PerformRequest": PerformRequest,
    "PingRequest": PingRequest,
    "PingRequestResponse": PingRequestResponse,
    "PresentationDefinition": PresentationDefinition,
    "PresentationProposal": PresentationProposal,
    "PresentationRequest": PresentationRequest,
    "ProtocolDescriptor": ProtocolDescriptor,
    "PublishRevocations": PublishRevocations,
    "Queries": Queries,
    "Query": Query,
    "QueryItem": QueryItem,
    "QuestionRequest": QuestionRequest,
    "QuestionRequestResponse": QuestionRequestResponse,
    "RawEncoded": RawEncoded,
    "ReceiveInvitationRequest": ReceiveInvitationRequest,
    "RegisterLedgerNymResponse": RegisterLedgerNymResponse,
    "RemoveWalletRequest": RemoveWalletRequest,
    "ResolutionResult": ResolutionResult,
    "RevRegCreateRequest": RevRegCreateRequest,
    "RevRegIssuedResult": RevRegIssuedResult,
    "RevRegResult": RevRegResult,
    "RevRegUpdateTailsFileUri": RevRegUpdateTailsFileUri,
    "RevRegsCreated": RevRegsCreated,
    "RevocationModuleResponse": RevocationModuleResponse,
    "RevokeRequest": RevokeRequest,
    "RouteRecord": RouteRecord,
    "Schema": Schema,
    "SchemaGetResult": SchemaGetResult,
    "SchemaInputDescriptor": SchemaInputDescriptor,
    "SchemaSendRequest": SchemaSendRequest,
    "SchemaSendResult": SchemaSendResult,
    "SchemasCreatedResult": SchemasCreatedResult,
    "SchemasInputDescriptorFilter": SchemasInputDescriptorFilter,
    "SendMenu": SendMenu,
    "SendMessage": SendMessage,
    "SignRequest": SignRequest,
    "SignResponse": SignResponse,
    "SignatureOptions": SignatureOptions,
    "SignedDoc": SignedDoc,
    "SubmissionRequirements": SubmissionRequirements,
    "TAAAccept": TAAAccept,
    "TAAAcceptance": TAAAcceptance,
    "TAAInfo": TAAInfo,
    "TAARecord": TAARecord,
    "TAAResult": TAAResult,
    "TransactionJobs": TransactionJobs,
    "TransactionList": TransactionList,
    "TransactionRecord": TransactionRecord,
    "TxnOrCredentialDefinitionSendResult": TxnOrCredentialDefinitionSendResult,
    "TxnOrPublishRevocationsResult": TxnOrPublishRevocationsResult,
    "TxnOrRevRegResult": TxnOrRevRegResult,
    "TxnOrSchemaSendResult": TxnOrSchemaSendResult,
    "UpdateWalletRequest": UpdateWalletRequest,
    "V10CredentialBoundOfferRequest": V10CredentialBoundOfferRequest,
    "V10CredentialConnFreeOfferRequest": V10CredentialConnFreeOfferRequest,
    "V10CredentialCreate": V10CredentialCreate,
    "V10CredentialExchange": V10CredentialExchange,
    "V10CredentialExchangeListResult": V10CredentialExchangeListResult,
    "V10CredentialFreeOfferRequest": V10CredentialFreeOfferRequest,
    "V10CredentialIssueRequest": V10CredentialIssueRequest,
    "V10CredentialProblemReportRequest": V10CredentialProblemReportRequest,
    "V10CredentialProposalRequestMand": V10CredentialProposalRequestMand,
    "V10CredentialProposalRequestOpt": V10CredentialProposalRequestOpt,
    "V10CredentialStoreRequest": V10CredentialStoreRequest,
    "V10DiscoveryExchangeListResult": V10DiscoveryExchangeListResult,
    "V10DiscoveryExchangeResult": V10DiscoveryExchangeResult,
    "V10DiscoveryRecord": V10DiscoveryRecord,
    "V10PresentProofModuleResponse": V10PresentProofModuleResponse,
    "V10PresentationCreateRequestRequest": V10PresentationCreateRequestRequest,
    "V10PresentationExchange": V10PresentationExchange,
    "V10PresentationExchangeList": V10PresentationExchangeList,
    "V10PresentationProblemReportRequest": V10PresentationProblemReportRequest,
    "V10PresentationProposalRequest": V10PresentationProposalRequest,
    "V10PresentationSendRequestRequest": V10PresentationSendRequestRequest,
    "V20CredAttrSpec": V20CredAttrSpec,
    "V20CredBoundOfferRequest": V20CredBoundOfferRequest,
    "V20CredExFree": V20CredExFree,
    "V20CredExRecord": V20CredExRecord,
    "V20CredExRecordByFormat": V20CredExRecordByFormat,
    "V20CredExRecordDetail": V20CredExRecordDetail,
    "V20CredExRecordIndy": V20CredExRecordIndy,
    "V20CredExRecordLDProof": V20CredExRecordLDProof,
    "V20CredExRecordListResult": V20CredExRecordListResult,
    "V20CredFilter": V20CredFilter,
    "V20CredFilterIndy": V20CredFilterIndy,
    "V20CredFilterLDProof": V20CredFilterLDProof,
    "V20CredFormat": V20CredFormat,
    "V20CredIssue": V20CredIssue,
    "V20CredIssueProblemReportRequest": V20CredIssueProblemReportRequest,
    "V20CredIssueRequest": V20CredIssueRequest,
    "V20CredOffer": V20CredOffer,
    "V20CredOfferConnFreeRequest": V20CredOfferConnFreeRequest,
    "V20CredOfferRequest": V20CredOfferRequest,
    "V20CredPreview": V20CredPreview,
    "V20CredProposal": V20CredProposal,
    "V20CredRequest": V20CredRequest,
    "V20CredRequestFree": V20CredRequestFree,
    "V20CredRequestRequest": V20CredRequestRequest,
    "V20CredStoreRequest": V20CredStoreRequest,
    "V20DiscoveryExchangeListResult": V20DiscoveryExchangeListResult,
    "V20DiscoveryExchangeResult": V20DiscoveryExchangeResult,
    "V20DiscoveryRecord": V20DiscoveryRecord,
    "V20IssueCredSchemaCore": V20IssueCredSchemaCore,
    "V20IssueCredentialModuleResponse": V20IssueCredentialModuleResponse,
    "V20Pres": V20Pres,
    "V20PresCreateRequestRequest": V20PresCreateRequestRequest,
    "V20PresExRecord": V20PresExRecord,
    "V20PresExRecordByFormat": V20PresExRecordByFormat,
    "V20PresExRecordList": V20PresExRecordList,
    "V20PresFormat": V20PresFormat,
    "V20PresProblemReportRequest": V20PresProblemReportRequest,
    "V20PresProposal": V20PresProposal,
    "V20PresProposalByFormat": V20PresProposalByFormat,
    "V20PresProposalRequest": V20PresProposalRequest,
    "V20PresRequest": V20PresRequest,
    "V20PresRequestByFormat": V20PresRequestByFormat,
    "V20PresSendRequestRequest": V20PresSendRequestRequest,
    "V20PresSpecByFormatRequest": V20PresSpecByFormatRequest,
    "V20PresentProofModuleResponse": V20PresentProofModuleResponse,
    "VCRecord": VCRecord,
    "VCRecordList": VCRecordList,
    "VerifyRequest": VerifyRequest,
    "VerifyResponse": VerifyResponse,
    "W3CCredentialsListRequest": W3CCredentialsListRequest,
    "WalletList": WalletList,
    "WalletModuleResponse": WalletModuleResponse,
    "WalletRecord": WalletRecord,
    "WriteLedgerRequest": WriteLedgerRequest,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ActionMenuApiApiKeys {
    AuthorizationHeader,
}

export class ActionMenuApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ActionMenuApiApiKeys, value: string) {
        (this.authentications as any)[ActionMenuApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Close the active menu associated with a connection
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    public actionMenuConnIdClosePost (conn_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ActionMenuModulesResult;  }> {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/close'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdClosePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ActionMenuModulesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch the active menu
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    public actionMenuConnIdFetchPost (conn_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ActionMenuFetchResult;  }> {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/fetch'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdFetchPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ActionMenuFetchResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuFetchResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform an action associated with the active menu
     * @param conn_id Connection identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public actionMenuConnIdPerformPost (conn_id: string, body?: PerformRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ActionMenuModulesResult;  }> {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/perform'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdPerformPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PerformRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ActionMenuModulesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request the active menu
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    public actionMenuConnIdRequestPost (conn_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ActionMenuModulesResult;  }> {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/request'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdRequestPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ActionMenuModulesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send an action menu to a connection
     * @param conn_id Connection identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public actionMenuConnIdSendMenuPost (conn_id: string, body?: SendMenu, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ActionMenuModulesResult;  }> {
        const localVarPath = this.basePath + '/action-menu/{conn_id}/send-menu'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling actionMenuConnIdSendMenuPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SendMenu")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ActionMenuModulesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActionMenuModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BasicmessageApiApiKeys {
    AuthorizationHeader,
}

export class BasicmessageApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BasicmessageApiApiKeys, value: string) {
        (this.authentications as any)[BasicmessageApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Send a basic message to a connection
     * @param conn_id Connection identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdSendMessagePost (conn_id: string, body?: SendMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BasicMessageModuleResponse;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}/send-message'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdSendMessagePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SendMessage")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BasicMessageModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BasicMessageModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConnectionApiApiKeys {
    AuthorizationHeader,
}

export class ConnectionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConnectionApiApiKeys, value: string) {
        (this.authentications as any)[ConnectionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Accept a stored connection invitation
     * @param conn_id Connection identifier
     * @param mediation_id Identifier for active mediation record to be used
     * @param my_endpoint My URL endpoint
     * @param my_label Label for connection
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdAcceptInvitationPost (conn_id: string, mediation_id?: string, my_endpoint?: string, my_label?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnRecord;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}/accept-invitation'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdAcceptInvitationPost.');
        }

        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }

        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }

        if (my_label !== undefined) {
            localVarQueryParameters['my_label'] = ObjectSerializer.serialize(my_label, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Accept a stored connection request
     * @param conn_id Connection identifier
     * @param my_endpoint My URL endpoint
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdAcceptRequestPost (conn_id: string, my_endpoint?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnRecord;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}/accept-request'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdAcceptRequestPost.');
        }

        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove an existing connection record
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdDelete (conn_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnectionModuleResponse;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnectionModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnectionModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch connection remote endpoint
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdEndpointsGet (conn_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EndpointsResult;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}/endpoints'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdEndpointsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EndpointsResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EndpointsResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign another connection as the inbound connection
     * @param conn_id Connection identifier
     * @param ref_id Inbound connection identifier
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdEstablishInboundRefIdPost (conn_id: string, ref_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnectionModuleResponse;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}/establish-inbound/{ref_id}'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)))
            .replace('{' + 'ref_id' + '}', encodeURIComponent(String(ref_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdEstablishInboundRefIdPost.');
        }

        // verify required parameter 'ref_id' is not null or undefined
        if (ref_id === null || ref_id === undefined) {
            throw new Error('Required parameter ref_id was null or undefined when calling connectionsConnIdEstablishInboundRefIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnectionModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnectionModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single connection record
     * @param conn_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdGet (conn_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnRecord;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch connection metadata
     * @param conn_id Connection identifier
     * @param key Key to retrieve.
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdMetadataGet (conn_id: string, key?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnectionMetadata;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}/metadata'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdMetadataGet.');
        }

        if (key !== undefined) {
            localVarQueryParameters['key'] = ObjectSerializer.serialize(key, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnectionMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnectionMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set connection metadata
     * @param conn_id Connection identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdMetadataPost (conn_id: string, body?: ConnectionMetadataSetRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnectionMetadata;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}/metadata'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdMetadataPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ConnectionMetadataSetRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnectionMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnectionMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new connection invitation
     * @param body 
     * @param alias Alias
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param multi_use Create invitation for multiple use (default false)
     * @param _public Create invitation from public DID (default false)
     * @param {*} [options] Override http request options.
     */
    public connectionsCreateInvitationPost (body?: CreateInvitationRequest, alias?: string, auto_accept?: boolean, multi_use?: boolean, _public?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InvitationResult;  }> {
        const localVarPath = this.basePath + '/connections/create-invitation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }

        if (multi_use !== undefined) {
            localVarQueryParameters['multi_use'] = ObjectSerializer.serialize(multi_use, "boolean");
        }

        if (_public !== undefined) {
            localVarQueryParameters['public'] = ObjectSerializer.serialize(_public, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateInvitationRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InvitationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvitationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new static connection
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public connectionsCreateStaticPost (body?: ConnectionStaticRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnectionStaticResult;  }> {
        const localVarPath = this.basePath + '/connections/create-static';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ConnectionStaticRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnectionStaticResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnectionStaticResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Query agent-to-agent connections
     * @param alias Alias
     * @param connection_protocol Connection protocol used
     * @param invitation_key invitation key
     * @param my_did My DID
     * @param state Connection state
     * @param their_did Their DID
     * @param their_role Their role in the connection protocol
     * @param {*} [options] Override http request options.
     */
    public connectionsGet (alias?: string, connection_protocol?: 'connections/1.0' | 'didexchange/1.0', invitation_key?: string, my_did?: string, state?: 'request' | 'start' | 'invitation' | 'abandoned' | 'completed' | 'response' | 'error' | 'active' | 'init', their_did?: string, their_role?: 'invitee' | 'requester' | 'inviter' | 'responder', options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnectionList;  }> {
        const localVarPath = this.basePath + '/connections';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (connection_protocol !== undefined) {
            localVarQueryParameters['connection_protocol'] = ObjectSerializer.serialize(connection_protocol, "'connections/1.0' | 'didexchange/1.0'");
        }

        if (invitation_key !== undefined) {
            localVarQueryParameters['invitation_key'] = ObjectSerializer.serialize(invitation_key, "string");
        }

        if (my_did !== undefined) {
            localVarQueryParameters['my_did'] = ObjectSerializer.serialize(my_did, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'request' | 'start' | 'invitation' | 'abandoned' | 'completed' | 'response' | 'error' | 'active' | 'init'");
        }

        if (their_did !== undefined) {
            localVarQueryParameters['their_did'] = ObjectSerializer.serialize(their_did, "string");
        }

        if (their_role !== undefined) {
            localVarQueryParameters['their_role'] = ObjectSerializer.serialize(their_role, "'invitee' | 'requester' | 'inviter' | 'responder'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnectionList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnectionList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Receive a new connection invitation
     * @param body 
     * @param alias Alias
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param mediation_id Identifier for active mediation record to be used
     * @param {*} [options] Override http request options.
     */
    public connectionsReceiveInvitationPost (body?: ReceiveInvitationRequest, alias?: string, auto_accept?: boolean, mediation_id?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnRecord;  }> {
        const localVarPath = this.basePath + '/connections/receive-invitation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }

        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ReceiveInvitationRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CredentialDefinitionApiApiKeys {
    AuthorizationHeader,
}

export class CredentialDefinitionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CredentialDefinitionApiApiKeys, value: string) {
        (this.authentications as any)[CredentialDefinitionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Search for matching credential definitions that agent originated
     * @param cred_def_id Credential definition id
     * @param issuer_did Issuer DID
     * @param schema_id Schema identifier
     * @param schema_issuer_did Schema issuer DID
     * @param schema_name Schema name
     * @param schema_version Schema version
     * @param {*} [options] Override http request options.
     */
    public credentialDefinitionsCreatedGet (cred_def_id?: string, issuer_did?: string, schema_id?: string, schema_issuer_did?: string, schema_name?: string, schema_version?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CredentialDefinitionsCreatedResult;  }> {
        const localVarPath = this.basePath + '/credential-definitions/created';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cred_def_id !== undefined) {
            localVarQueryParameters['cred_def_id'] = ObjectSerializer.serialize(cred_def_id, "string");
        }

        if (issuer_did !== undefined) {
            localVarQueryParameters['issuer_did'] = ObjectSerializer.serialize(issuer_did, "string");
        }

        if (schema_id !== undefined) {
            localVarQueryParameters['schema_id'] = ObjectSerializer.serialize(schema_id, "string");
        }

        if (schema_issuer_did !== undefined) {
            localVarQueryParameters['schema_issuer_did'] = ObjectSerializer.serialize(schema_issuer_did, "string");
        }

        if (schema_name !== undefined) {
            localVarQueryParameters['schema_name'] = ObjectSerializer.serialize(schema_name, "string");
        }

        if (schema_version !== undefined) {
            localVarQueryParameters['schema_version'] = ObjectSerializer.serialize(schema_version, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CredentialDefinitionsCreatedResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CredentialDefinitionsCreatedResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a credential definition from the ledger
     * @param cred_def_id Credential definition identifier
     * @param {*} [options] Override http request options.
     */
    public credentialDefinitionsCredDefIdGet (cred_def_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CredentialDefinitionGetResult;  }> {
        const localVarPath = this.basePath + '/credential-definitions/{cred_def_id}'
            .replace('{' + 'cred_def_id' + '}', encodeURIComponent(String(cred_def_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_def_id' is not null or undefined
        if (cred_def_id === null || cred_def_id === undefined) {
            throw new Error('Required parameter cred_def_id was null or undefined when calling credentialDefinitionsCredDefIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CredentialDefinitionGetResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CredentialDefinitionGetResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Writes a credential definition non-secret record to the wallet
     * @param cred_def_id Credential definition identifier
     * @param {*} [options] Override http request options.
     */
    public credentialDefinitionsCredDefIdWriteRecordPost (cred_def_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CredentialDefinitionGetResult;  }> {
        const localVarPath = this.basePath + '/credential-definitions/{cred_def_id}/write_record'
            .replace('{' + 'cred_def_id' + '}', encodeURIComponent(String(cred_def_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_def_id' is not null or undefined
        if (cred_def_id === null || cred_def_id === undefined) {
            throw new Error('Required parameter cred_def_id was null or undefined when calling credentialDefinitionsCredDefIdWriteRecordPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CredentialDefinitionGetResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CredentialDefinitionGetResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a credential definition to the ledger
     * @param body 
     * @param conn_id Connection identifier
     * @param create_transaction_for_endorser Create Transaction For Endorser&#39;s signature
     * @param {*} [options] Override http request options.
     */
    public credentialDefinitionsPost (body?: CredentialDefinitionSendRequest, conn_id?: string, create_transaction_for_endorser?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TxnOrCredentialDefinitionSendResult;  }> {
        const localVarPath = this.basePath + '/credential-definitions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }

        if (create_transaction_for_endorser !== undefined) {
            localVarQueryParameters['create_transaction_for_endorser'] = ObjectSerializer.serialize(create_transaction_for_endorser, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CredentialDefinitionSendRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TxnOrCredentialDefinitionSendResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TxnOrCredentialDefinitionSendResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CredentialsApiApiKeys {
    AuthorizationHeader,
}

export class CredentialsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CredentialsApiApiKeys, value: string) {
        (this.authentications as any)[CredentialsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Remove credential from wallet by id
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    public credentialCredentialIdDelete (credential_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HolderModuleResponse;  }> {
        const localVarPath = this.basePath + '/credential/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialCredentialIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HolderModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HolderModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch credential from wallet by id
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    public credentialCredentialIdGet (credential_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IndyCredInfo;  }> {
        const localVarPath = this.basePath + '/credential/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialCredentialIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IndyCredInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IndyCredInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get attribute MIME types from wallet
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    public credentialMimeTypesCredentialIdGet (credential_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AttributeMimeTypesResult;  }> {
        const localVarPath = this.basePath + '/credential/mime-types/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialMimeTypesCredentialIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AttributeMimeTypesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AttributeMimeTypesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Query credential revocation status by id
     * @param credential_id Credential identifier
     * @param from Earliest epoch of revocation status interval of interest
     * @param to Latest epoch of revocation status interval of interest
     * @param {*} [options] Override http request options.
     */
    public credentialRevokedCredentialIdGet (credential_id: string, from?: string, to?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CredRevokedResult;  }> {
        const localVarPath = this.basePath + '/credential/revoked/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialRevokedCredentialIdGet.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "string");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CredRevokedResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CredRevokedResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove W3C credential from wallet by id
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    public credentialW3cCredentialIdDelete (credential_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HolderModuleResponse;  }> {
        const localVarPath = this.basePath + '/credential/w3c/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialW3cCredentialIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HolderModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HolderModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch W3C credential from wallet by id
     * @param credential_id Credential identifier
     * @param {*} [options] Override http request options.
     */
    public credentialW3cCredentialIdGet (credential_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: VCRecord;  }> {
        const localVarPath = this.basePath + '/credential/w3c/{credential_id}'
            .replace('{' + 'credential_id' + '}', encodeURIComponent(String(credential_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'credential_id' is not null or undefined
        if (credential_id === null || credential_id === undefined) {
            throw new Error('Required parameter credential_id was null or undefined when calling credentialW3cCredentialIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: VCRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VCRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch credentials from wallet
     * @param count Maximum number to retrieve
     * @param start Start index
     * @param wql (JSON) WQL query
     * @param {*} [options] Override http request options.
     */
    public credentialsGet (count?: string, start?: string, wql?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CredInfoList;  }> {
        const localVarPath = this.basePath + '/credentials';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "string");
        }

        if (wql !== undefined) {
            localVarQueryParameters['wql'] = ObjectSerializer.serialize(wql, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CredInfoList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CredInfoList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch W3C credentials from wallet
     * @param body 
     * @param count Maximum number to retrieve
     * @param start Start index
     * @param wql (JSON) WQL query
     * @param {*} [options] Override http request options.
     */
    public credentialsW3cPost (body?: W3CCredentialsListRequest, count?: string, start?: string, wql?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: VCRecordList;  }> {
        const localVarPath = this.basePath + '/credentials/w3c';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "string");
        }

        if (wql !== undefined) {
            localVarQueryParameters['wql'] = ObjectSerializer.serialize(wql, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "W3CCredentialsListRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: VCRecordList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VCRecordList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DidExchangeApiApiKeys {
    AuthorizationHeader,
}

export class DidExchangeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DidExchangeApiApiKeys, value: string) {
        (this.authentications as any)[DidExchangeApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Accept a stored connection invitation
     * @param conn_id Connection identifier
     * @param my_endpoint My URL endpoint
     * @param my_label Label for connection request
     * @param {*} [options] Override http request options.
     */
    public didexchangeConnIdAcceptInvitationPost (conn_id: string, my_endpoint?: string, my_label?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnRecord;  }> {
        const localVarPath = this.basePath + '/didexchange/{conn_id}/accept-invitation'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling didexchangeConnIdAcceptInvitationPost.');
        }

        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }

        if (my_label !== undefined) {
            localVarQueryParameters['my_label'] = ObjectSerializer.serialize(my_label, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Accept a stored connection request
     * @param conn_id Connection identifier
     * @param mediation_id Identifier for active mediation record to be used
     * @param my_endpoint My URL endpoint
     * @param {*} [options] Override http request options.
     */
    public didexchangeConnIdAcceptRequestPost (conn_id: string, mediation_id?: string, my_endpoint?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnRecord;  }> {
        const localVarPath = this.basePath + '/didexchange/{conn_id}/accept-request'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling didexchangeConnIdAcceptRequestPost.');
        }

        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }

        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create and send a request against public DID's implicit invitation
     * @param their_public_did Qualified public DID to which to request connection
     * @param alias Alias for connection
     * @param mediation_id Identifier for active mediation record to be used
     * @param my_endpoint My URL endpoint
     * @param my_label Label for connection request
     * @param use_public_did Use public DID for this connection
     * @param {*} [options] Override http request options.
     */
    public didexchangeCreateRequestPost (their_public_did: string, alias?: string, mediation_id?: string, my_endpoint?: string, my_label?: string, use_public_did?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnRecord;  }> {
        const localVarPath = this.basePath + '/didexchange/create-request';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'their_public_did' is not null or undefined
        if (their_public_did === null || their_public_did === undefined) {
            throw new Error('Required parameter their_public_did was null or undefined when calling didexchangeCreateRequestPost.');
        }

        if (their_public_did !== undefined) {
            localVarQueryParameters['their_public_did'] = ObjectSerializer.serialize(their_public_did, "string");
        }

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }

        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }

        if (my_label !== undefined) {
            localVarQueryParameters['my_label'] = ObjectSerializer.serialize(my_label, "string");
        }

        if (use_public_did !== undefined) {
            localVarQueryParameters['use_public_did'] = ObjectSerializer.serialize(use_public_did, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Receive request against public DID's implicit invitation
     * @param body 
     * @param alias Alias for connection
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param mediation_id Identifier for active mediation record to be used
     * @param my_endpoint My URL endpoint
     * @param {*} [options] Override http request options.
     */
    public didexchangeReceiveRequestPost (body?: DIDXRequest, alias?: string, auto_accept?: boolean, mediation_id?: string, my_endpoint?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnRecord;  }> {
        const localVarPath = this.basePath + '/didexchange/receive-request';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }

        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }

        if (my_endpoint !== undefined) {
            localVarQueryParameters['my_endpoint'] = ObjectSerializer.serialize(my_endpoint, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DIDXRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DiscoverFeaturesApiApiKeys {
    AuthorizationHeader,
}

export class DiscoverFeaturesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DiscoverFeaturesApiApiKeys, value: string) {
        (this.authentications as any)[DiscoverFeaturesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Query supported features
     * @param comment Comment
     * @param connection_id Connection identifier, if none specified, then the query will provide features for this agent.
     * @param query Protocol feature query
     * @param {*} [options] Override http request options.
     */
    public discoverFeaturesQueryGet (comment?: string, connection_id?: string, query?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10DiscoveryExchangeResult;  }> {
        const localVarPath = this.basePath + '/discover-features/query';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (comment !== undefined) {
            localVarQueryParameters['comment'] = ObjectSerializer.serialize(comment, "string");
        }

        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10DiscoveryExchangeResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10DiscoveryExchangeResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Discover Features records
     * @param connection_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    public discoverFeaturesRecordsGet (connection_id?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10DiscoveryExchangeListResult;  }> {
        const localVarPath = this.basePath + '/discover-features/records';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10DiscoveryExchangeListResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10DiscoveryExchangeListResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DiscoverFeaturesV20ApiApiKeys {
    AuthorizationHeader,
}

export class DiscoverFeaturesV20Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DiscoverFeaturesV20ApiApiKeys, value: string) {
        (this.authentications as any)[DiscoverFeaturesV20ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Query supported features
     * @param connection_id Connection identifier, if none specified, then the query will provide features for this agent.
     * @param query_goal_code Goal-code feature-type query
     * @param query_protocol Protocol feature-type query
     * @param {*} [options] Override http request options.
     */
    public discoverFeatures20QueriesGet (connection_id?: string, query_goal_code?: string, query_protocol?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20DiscoveryExchangeResult;  }> {
        const localVarPath = this.basePath + '/discover-features-2.0/queries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }

        if (query_goal_code !== undefined) {
            localVarQueryParameters['query_goal_code'] = ObjectSerializer.serialize(query_goal_code, "string");
        }

        if (query_protocol !== undefined) {
            localVarQueryParameters['query_protocol'] = ObjectSerializer.serialize(query_protocol, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20DiscoveryExchangeResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20DiscoveryExchangeResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Discover Features v2.0 records
     * @param connection_id Connection identifier
     * @param {*} [options] Override http request options.
     */
    public discoverFeatures20RecordsGet (connection_id?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20DiscoveryExchangeListResult;  }> {
        const localVarPath = this.basePath + '/discover-features-2.0/records';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20DiscoveryExchangeListResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20DiscoveryExchangeListResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EndorseTransactionApiApiKeys {
    AuthorizationHeader,
}

export class EndorseTransactionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EndorseTransactionApiApiKeys, value: string) {
        (this.authentications as any)[EndorseTransactionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary For Author to resend a particular transaction request
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    public transactionTranIdResendPost (tran_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }> {
        const localVarPath = this.basePath + '/transaction/{tran_id}/resend'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionTranIdResendPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Endorser Info
     * @param conn_id Connection identifier
     * @param endorser_did Endorser DID
     * @param endorser_name Endorser Name
     * @param {*} [options] Override http request options.
     */
    public transactionsConnIdSetEndorserInfoPost (conn_id: string, endorser_did: string, endorser_name?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EndorserInfo;  }> {
        const localVarPath = this.basePath + '/transactions/{conn_id}/set-endorser-info'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling transactionsConnIdSetEndorserInfoPost.');
        }

        // verify required parameter 'endorser_did' is not null or undefined
        if (endorser_did === null || endorser_did === undefined) {
            throw new Error('Required parameter endorser_did was null or undefined when calling transactionsConnIdSetEndorserInfoPost.');
        }

        if (endorser_did !== undefined) {
            localVarQueryParameters['endorser_did'] = ObjectSerializer.serialize(endorser_did, "string");
        }

        if (endorser_name !== undefined) {
            localVarQueryParameters['endorser_name'] = ObjectSerializer.serialize(endorser_name, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EndorserInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EndorserInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set transaction jobs
     * @param conn_id Connection identifier
     * @param transaction_my_job Transaction related jobs
     * @param {*} [options] Override http request options.
     */
    public transactionsConnIdSetEndorserRolePost (conn_id: string, transaction_my_job?: 'TRANSACTION_AUTHOR' | 'TRANSACTION_ENDORSER' | 'reset', options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionJobs;  }> {
        const localVarPath = this.basePath + '/transactions/{conn_id}/set-endorser-role'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling transactionsConnIdSetEndorserRolePost.');
        }

        if (transaction_my_job !== undefined) {
            localVarQueryParameters['transaction_my_job'] = ObjectSerializer.serialize(transaction_my_job, "'TRANSACTION_AUTHOR' | 'TRANSACTION_ENDORSER' | 'reset'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionJobs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionJobs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary For author to send a transaction request
     * @param tran_id Transaction identifier
     * @param body 
     * @param endorser_write_txn Endorser will write the transaction after endorsing it
     * @param {*} [options] Override http request options.
     */
    public transactionsCreateRequestPost (tran_id: string, body?: ModelDate, endorser_write_txn?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }> {
        const localVarPath = this.basePath + '/transactions/create-request';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsCreateRequestPost.');
        }

        if (tran_id !== undefined) {
            localVarQueryParameters['tran_id'] = ObjectSerializer.serialize(tran_id, "string");
        }

        if (endorser_write_txn !== undefined) {
            localVarQueryParameters['endorser_write_txn'] = ObjectSerializer.serialize(endorser_write_txn, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ModelDate")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Query transactions
     * @param {*} [options] Override http request options.
     */
    public transactionsGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionList;  }> {
        const localVarPath = this.basePath + '/transactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary For Author to cancel a particular transaction request
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    public transactionsTranIdCancelPost (tran_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }> {
        const localVarPath = this.basePath + '/transactions/{tran_id}/cancel'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdCancelPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary For Endorser to endorse a particular transaction record
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    public transactionsTranIdEndorsePost (tran_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }> {
        const localVarPath = this.basePath + '/transactions/{tran_id}/endorse'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdEndorsePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single transaction record
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    public transactionsTranIdGet (tran_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }> {
        const localVarPath = this.basePath + '/transactions/{tran_id}'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary For Endorser to refuse a particular transaction record
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    public transactionsTranIdRefusePost (tran_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }> {
        const localVarPath = this.basePath + '/transactions/{tran_id}/refuse'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdRefusePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary For Author / Endorser to write an endorsed transaction to the ledger
     * @param tran_id Transaction identifier
     * @param {*} [options] Override http request options.
     */
    public transactionsTranIdWritePost (tran_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }> {
        const localVarPath = this.basePath + '/transactions/{tran_id}/write'
            .replace('{' + 'tran_id' + '}', encodeURIComponent(String(tran_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tran_id' is not null or undefined
        if (tran_id === null || tran_id === undefined) {
            throw new Error('Required parameter tran_id was null or undefined when calling transactionsTranIdWritePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IntroductionApiApiKeys {
    AuthorizationHeader,
}

export class IntroductionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IntroductionApiApiKeys, value: string) {
        (this.authentications as any)[IntroductionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Start an introduction between two connections
     * @param conn_id Connection identifier
     * @param target_connection_id Target connection identifier
     * @param message Message
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdStartIntroductionPost (conn_id: string, target_connection_id: string, message?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IntroModuleResponse;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}/start-introduction'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdStartIntroductionPost.');
        }

        // verify required parameter 'target_connection_id' is not null or undefined
        if (target_connection_id === null || target_connection_id === undefined) {
            throw new Error('Required parameter target_connection_id was null or undefined when calling connectionsConnIdStartIntroductionPost.');
        }

        if (target_connection_id !== undefined) {
            localVarQueryParameters['target_connection_id'] = ObjectSerializer.serialize(target_connection_id, "string");
        }

        if (message !== undefined) {
            localVarQueryParameters['message'] = ObjectSerializer.serialize(message, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IntroModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IntroModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IssueCredentialV10ApiApiKeys {
    AuthorizationHeader,
}

export class IssueCredentialV10Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IssueCredentialV10ApiApiKeys, value: string) {
        (this.authentications as any)[IssueCredentialV10ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a credential offer, independent of any proposal or connection
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredentialCreateOfferPost (body?: V10CredentialConnFreeOfferRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/create-offer';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialConnFreeOfferRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send holder a credential, automating entire flow
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredentialCreatePost (body?: V10CredentialCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialCreate")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove an existing credential exchange record
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    public issueCredentialRecordsCredExIdDelete (cred_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssueCredentialModuleResponse;  }> {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssueCredentialModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssueCredentialModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single credential exchange record
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    public issueCredentialRecordsCredExIdGet (cred_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send holder a credential
     * @param cred_ex_id Credential exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredentialRecordsCredExIdIssuePost (cred_ex_id: string, body?: V10CredentialIssueRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/issue'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdIssuePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialIssueRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send a problem report for credential exchange
     * @param cred_ex_id Credential exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredentialRecordsCredExIdProblemReportPost (cred_ex_id: string, body?: V10CredentialProblemReportRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssueCredentialModuleResponse;  }> {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/problem-report'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdProblemReportPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialProblemReportRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssueCredentialModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssueCredentialModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send holder a credential offer in reference to a proposal with preview
     * @param cred_ex_id Credential exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredentialRecordsCredExIdSendOfferPost (cred_ex_id: string, body?: V10CredentialBoundOfferRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/send-offer'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdSendOfferPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialBoundOfferRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send issuer a credential request
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    public issueCredentialRecordsCredExIdSendRequestPost (cred_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/send-request'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdSendRequestPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Store a received credential
     * @param cred_ex_id Credential exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredentialRecordsCredExIdStorePost (cred_ex_id: string, body?: V10CredentialStoreRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/records/{cred_ex_id}/store'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredentialRecordsCredExIdStorePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialStoreRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all credential exchange records
     * @param connection_id Connection identifier
     * @param role Role assigned in credential exchange
     * @param state Credential exchange state
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    public issueCredentialRecordsGet (connection_id?: string, role?: 'issuer' | 'holder', state?: 'proposal_sent' | 'proposal_received' | 'offer_sent' | 'offer_received' | 'request_sent' | 'request_received' | 'credential_issued' | 'credential_received' | 'credential_acked' | 'credential_revoked', thread_id?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchangeListResult;  }> {
        const localVarPath = this.basePath + '/issue-credential/records';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'issuer' | 'holder'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'proposal_sent' | 'proposal_received' | 'offer_sent' | 'offer_received' | 'request_sent' | 'request_received' | 'credential_issued' | 'credential_received' | 'credential_acked' | 'credential_revoked'");
        }

        if (thread_id !== undefined) {
            localVarQueryParameters['thread_id'] = ObjectSerializer.serialize(thread_id, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchangeListResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchangeListResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send holder a credential offer, independent of any proposal
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredentialSendOfferPost (body?: V10CredentialFreeOfferRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/send-offer';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialFreeOfferRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send holder a credential, automating entire flow
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredentialSendPost (body?: V10CredentialProposalRequestMand, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/send';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialProposalRequestMand")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send issuer a credential proposal
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredentialSendProposalPost (body?: V10CredentialProposalRequestOpt, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }> {
        const localVarPath = this.basePath + '/issue-credential/send-proposal';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10CredentialProposalRequestOpt")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10CredentialExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10CredentialExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IssueCredentialV20ApiApiKeys {
    AuthorizationHeader,
}

export class IssueCredentialV20Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IssueCredentialV20ApiApiKeys, value: string) {
        (this.authentications as any)[IssueCredentialV20ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a credential offer, independent of any proposal or connection
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20CreateOfferPost (body?: V20CredOfferConnFreeRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/create-offer';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredOfferConnFreeRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create credential from attribute values
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20CreatePost (body?: V20IssueCredSchemaCore, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20IssueCredSchemaCore")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove an existing credential exchange record
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    public issueCredential20RecordsCredExIdDelete (cred_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20IssueCredentialModuleResponse;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20IssueCredentialModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20IssueCredentialModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single credential exchange record
     * @param cred_ex_id Credential exchange identifier
     * @param {*} [options] Override http request options.
     */
    public issueCredential20RecordsCredExIdGet (cred_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecordDetail;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecordDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecordDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send holder a credential
     * @param cred_ex_id Credential exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20RecordsCredExIdIssuePost (cred_ex_id: string, body?: V20CredIssueRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecordDetail;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/issue'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdIssuePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredIssueRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecordDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecordDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send a problem report for credential exchange
     * @param cred_ex_id Credential exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20RecordsCredExIdProblemReportPost (cred_ex_id: string, body?: V20CredIssueProblemReportRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20IssueCredentialModuleResponse;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/problem-report'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdProblemReportPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredIssueProblemReportRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20IssueCredentialModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20IssueCredentialModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send holder a credential offer in reference to a proposal with preview
     * @param cred_ex_id Credential exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20RecordsCredExIdSendOfferPost (cred_ex_id: string, body?: V20CredBoundOfferRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/send-offer'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdSendOfferPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredBoundOfferRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send issuer a credential request
     * @param cred_ex_id Credential exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20RecordsCredExIdSendRequestPost (cred_ex_id: string, body?: V20CredRequestRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/send-request'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdSendRequestPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredRequestRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Store a received credential
     * @param cred_ex_id Credential exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20RecordsCredExIdStorePost (cred_ex_id: string, body?: V20CredStoreRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecordDetail;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/records/{cred_ex_id}/store'
            .replace('{' + 'cred_ex_id' + '}', encodeURIComponent(String(cred_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_ex_id' is not null or undefined
        if (cred_ex_id === null || cred_ex_id === undefined) {
            throw new Error('Required parameter cred_ex_id was null or undefined when calling issueCredential20RecordsCredExIdStorePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredStoreRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecordDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecordDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all credential exchange records
     * @param connection_id Connection identifier
     * @param role Role assigned in credential exchange
     * @param state Credential exchange state
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    public issueCredential20RecordsGet (connection_id?: string, role?: 'issuer' | 'holder', state?: 'proposal-sent' | 'proposal-received' | 'offer-sent' | 'offer-received' | 'request-sent' | 'request-received' | 'credential-issued' | 'credential-received' | 'done' | 'credential-revoked', thread_id?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecordListResult;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/records';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'issuer' | 'holder'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'proposal-sent' | 'proposal-received' | 'offer-sent' | 'offer-received' | 'request-sent' | 'request-received' | 'credential-issued' | 'credential-received' | 'done' | 'credential-revoked'");
        }

        if (thread_id !== undefined) {
            localVarQueryParameters['thread_id'] = ObjectSerializer.serialize(thread_id, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecordListResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecordListResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send holder a credential offer, independent of any proposal
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20SendOfferPost (body?: V20CredOfferRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/send-offer';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredOfferRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send holder a credential, automating entire flow
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20SendPost (body?: V20CredExFree, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/send';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredExFree")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send issuer a credential proposal
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20SendProposalPost (body?: V20CredExFree, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/send-proposal';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredExFree")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send issuer a credential request not bound to an existing thread. Indy credentials cannot start at a request
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCredential20SendRequestPost (body?: V20CredRequestFree, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }> {
        const localVarPath = this.basePath + '/issue-credential-2.0/send-request';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20CredRequestFree")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20CredExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20CredExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum JsonldApiApiKeys {
    AuthorizationHeader,
}

export class JsonldApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: JsonldApiApiKeys, value: string) {
        (this.authentications as any)[JsonldApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Sign a JSON-LD structure and return it
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public jsonldSignPost (body?: SignRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SignResponse;  }> {
        const localVarPath = this.basePath + '/jsonld/sign';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SignRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SignResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SignResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Verify a JSON-LD structure.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public jsonldVerifyPost (body?: VerifyRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: VerifyResponse;  }> {
        const localVarPath = this.basePath + '/jsonld/verify';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "VerifyRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: VerifyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VerifyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LedgerApiApiKeys {
    AuthorizationHeader,
}

export class LedgerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LedgerApiApiKeys, value: string) {
        (this.authentications as any)[LedgerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the endpoint for a DID from the ledger.
     * @param did DID of interest
     * @param endpoint_type Endpoint type of interest (default &#39;Endpoint&#39;)
     * @param {*} [options] Override http request options.
     */
    public ledgerDidEndpointGet (did: string, endpoint_type?: 'Endpoint' | 'Profile' | 'LinkedDomains', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetDIDEndpointResponse;  }> {
        const localVarPath = this.basePath + '/ledger/did-endpoint';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling ledgerDidEndpointGet.');
        }

        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }

        if (endpoint_type !== undefined) {
            localVarQueryParameters['endpoint_type'] = ObjectSerializer.serialize(endpoint_type, "'Endpoint' | 'Profile' | 'LinkedDomains'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetDIDEndpointResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetDIDEndpointResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the verkey for a DID from the ledger.
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    public ledgerDidVerkeyGet (did: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetDIDVerkeyResponse;  }> {
        const localVarPath = this.basePath + '/ledger/did-verkey';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling ledgerDidVerkeyGet.');
        }

        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetDIDVerkeyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetDIDVerkeyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the role from the NYM registration of a public DID.
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    public ledgerGetNymRoleGet (did: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetNymRoleResponse;  }> {
        const localVarPath = this.basePath + '/ledger/get-nym-role';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling ledgerGetNymRoleGet.');
        }

        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetNymRoleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetNymRoleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch the multiple ledger configuration currently in use
     * @param {*} [options] Override http request options.
     */
    public ledgerMultipleConfigGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: LedgerConfigList;  }> {
        const localVarPath = this.basePath + '/ledger/multiple/config';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LedgerConfigList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LedgerConfigList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch the current write ledger
     * @param {*} [options] Override http request options.
     */
    public ledgerMultipleGetWriteLedgerGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: WriteLedgerRequest;  }> {
        const localVarPath = this.basePath + '/ledger/multiple/get-write-ledger';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WriteLedgerRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WriteLedgerRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send a NYM registration to the ledger.
     * @param did DID to register
     * @param verkey Verification key
     * @param alias Alias
     * @param role Role
     * @param {*} [options] Override http request options.
     */
    public ledgerRegisterNymPost (did: string, verkey: string, alias?: string, role?: 'STEWARD' | 'TRUSTEE' | 'ENDORSER' | 'NETWORK_MONITOR' | 'reset', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RegisterLedgerNymResponse;  }> {
        const localVarPath = this.basePath + '/ledger/register-nym';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling ledgerRegisterNymPost.');
        }

        // verify required parameter 'verkey' is not null or undefined
        if (verkey === null || verkey === undefined) {
            throw new Error('Required parameter verkey was null or undefined when calling ledgerRegisterNymPost.');
        }

        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }

        if (verkey !== undefined) {
            localVarQueryParameters['verkey'] = ObjectSerializer.serialize(verkey, "string");
        }

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'STEWARD' | 'TRUSTEE' | 'ENDORSER' | 'NETWORK_MONITOR' | 'reset'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RegisterLedgerNymResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RegisterLedgerNymResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Rotate key pair for public DID.
     * @param {*} [options] Override http request options.
     */
    public ledgerRotatePublicDidKeypairPatch (options: any = {}) : Promise<{ response: http.IncomingMessage; body: LedgerModulesResult;  }> {
        const localVarPath = this.basePath + '/ledger/rotate-public-did-keypair';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LedgerModulesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LedgerModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Accept the transaction author agreement
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public ledgerTaaAcceptPost (body?: TAAAccept, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LedgerModulesResult;  }> {
        const localVarPath = this.basePath + '/ledger/taa/accept';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TAAAccept")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LedgerModulesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LedgerModulesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch the current transaction author agreement, if any
     * @param {*} [options] Override http request options.
     */
    public ledgerTaaGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: TAAResult;  }> {
        const localVarPath = this.basePath + '/ledger/taa';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TAAResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TAAResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediationApiApiKeys {
    AuthorizationHeader,
}

export class MediationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MediationApiApiKeys, value: string) {
        (this.authentications as any)[MediationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Clear default mediator
     * @param {*} [options] Override http request options.
     */
    public mediationDefaultMediatorDelete (options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediationRecord;  }> {
        const localVarPath = this.basePath + '/mediation/default-mediator';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediationRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get default mediator
     * @param {*} [options] Override http request options.
     */
    public mediationDefaultMediatorGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediationRecord;  }> {
        const localVarPath = this.basePath + '/mediation/default-mediator';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediationRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve keylists by connection or role
     * @param conn_id Connection identifier (optional)
     * @param role Filer on role, &#39;client&#39; for keys         mediated by other agents, &#39;server&#39; for keys         mediated by this agent
     * @param {*} [options] Override http request options.
     */
    public mediationKeylistsGet (conn_id?: string, role?: 'client' | 'server', options: any = {}) : Promise<{ response: http.IncomingMessage; body: Keylist;  }> {
        const localVarPath = this.basePath + '/mediation/keylists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'client' | 'server'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Keylist;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Keylist");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send keylist query to mediator
     * @param mediation_id Mediation record identifier
     * @param body 
     * @param paginate_limit limit number of results
     * @param paginate_offset offset to use in pagination
     * @param {*} [options] Override http request options.
     */
    public mediationKeylistsMediationIdSendKeylistQueryPost (mediation_id: string, body?: KeylistQueryFilterRequest, paginate_limit?: number, paginate_offset?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: KeylistQuery;  }> {
        const localVarPath = this.basePath + '/mediation/keylists/{mediation_id}/send-keylist-query'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationKeylistsMediationIdSendKeylistQueryPost.');
        }

        if (paginate_limit !== undefined) {
            localVarQueryParameters['paginate_limit'] = ObjectSerializer.serialize(paginate_limit, "number");
        }

        if (paginate_offset !== undefined) {
            localVarQueryParameters['paginate_offset'] = ObjectSerializer.serialize(paginate_offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "KeylistQueryFilterRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: KeylistQuery;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "KeylistQuery");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send keylist update to mediator
     * @param mediation_id Mediation record identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public mediationKeylistsMediationIdSendKeylistUpdatePost (mediation_id: string, body?: KeylistUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: KeylistUpdate;  }> {
        const localVarPath = this.basePath + '/mediation/keylists/{mediation_id}/send-keylist-update'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationKeylistsMediationIdSendKeylistUpdatePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "KeylistUpdateRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: KeylistUpdate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "KeylistUpdate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set default mediator
     * @param mediation_id Mediation record identifier
     * @param {*} [options] Override http request options.
     */
    public mediationMediationIdDefaultMediatorPut (mediation_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediationRecord;  }> {
        const localVarPath = this.basePath + '/mediation/{mediation_id}/default-mediator'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationMediationIdDefaultMediatorPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediationRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request mediation from connection
     * @param conn_id Connection identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public mediationRequestConnIdPost (conn_id: string, body?: MediationCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediationRecord;  }> {
        const localVarPath = this.basePath + '/mediation/request/{conn_id}'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling mediationRequestConnIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MediationCreateRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediationRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Query mediation requests, returns list of all mediation records
     * @param conn_id Connection identifier (optional)
     * @param mediator_terms List of mediator rules for recipient
     * @param recipient_terms List of recipient rules for mediation
     * @param state Mediation state (optional)
     * @param {*} [options] Override http request options.
     */
    public mediationRequestsGet (conn_id?: string, mediator_terms?: Array<string>, recipient_terms?: Array<string>, state?: 'request' | 'granted' | 'denied', options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediationList;  }> {
        const localVarPath = this.basePath + '/mediation/requests';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }

        if (mediator_terms !== undefined) {
            localVarQueryParameters['mediator_terms'] = ObjectSerializer.serialize(mediator_terms, "Array<string>");
        }

        if (recipient_terms !== undefined) {
            localVarQueryParameters['recipient_terms'] = ObjectSerializer.serialize(recipient_terms, "Array<string>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'request' | 'granted' | 'denied'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediationList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediationList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete mediation request by ID
     * @param mediation_id Mediation record identifier
     * @param {*} [options] Override http request options.
     */
    public mediationRequestsMediationIdDelete (mediation_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediationRecord;  }> {
        const localVarPath = this.basePath + '/mediation/requests/{mediation_id}'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationRequestsMediationIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediationRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deny a stored mediation request
     * @param mediation_id Mediation record identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public mediationRequestsMediationIdDenyPost (mediation_id: string, body?: AdminMediationDeny, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediationDeny;  }> {
        const localVarPath = this.basePath + '/mediation/requests/{mediation_id}/deny'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationRequestsMediationIdDenyPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminMediationDeny")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediationDeny;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediationDeny");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve mediation request record
     * @param mediation_id Mediation record identifier
     * @param {*} [options] Override http request options.
     */
    public mediationRequestsMediationIdGet (mediation_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediationRecord;  }> {
        const localVarPath = this.basePath + '/mediation/requests/{mediation_id}'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationRequestsMediationIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediationRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Grant received mediation
     * @param mediation_id Mediation record identifier
     * @param {*} [options] Override http request options.
     */
    public mediationRequestsMediationIdGrantPost (mediation_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediationGrant;  }> {
        const localVarPath = this.basePath + '/mediation/requests/{mediation_id}/grant'
            .replace('{' + 'mediation_id' + '}', encodeURIComponent(String(mediation_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediation_id' is not null or undefined
        if (mediation_id === null || mediation_id === undefined) {
            throw new Error('Required parameter mediation_id was null or undefined when calling mediationRequestsMediationIdGrantPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediationGrant;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediationGrant");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MultitenancyApiApiKeys {
    AuthorizationHeader,
}

export class MultitenancyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MultitenancyApiApiKeys, value: string) {
        (this.authentications as any)[MultitenancyApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a subwallet
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public multitenancyWalletPost (body?: CreateWalletRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateWalletResponse;  }> {
        const localVarPath = this.basePath + '/multitenancy/wallet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateWalletRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateWalletResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateWalletResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single subwallet
     * @param wallet_id Subwallet identifier
     * @param {*} [options] Override http request options.
     */
    public multitenancyWalletWalletIdGet (wallet_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WalletRecord;  }> {
        const localVarPath = this.basePath + '/multitenancy/wallet/{wallet_id}'
            .replace('{' + 'wallet_id' + '}', encodeURIComponent(String(wallet_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'wallet_id' is not null or undefined
        if (wallet_id === null || wallet_id === undefined) {
            throw new Error('Required parameter wallet_id was null or undefined when calling multitenancyWalletWalletIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WalletRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WalletRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a subwallet
     * @param wallet_id Subwallet identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public multitenancyWalletWalletIdPut (wallet_id: string, body?: UpdateWalletRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WalletRecord;  }> {
        const localVarPath = this.basePath + '/multitenancy/wallet/{wallet_id}'
            .replace('{' + 'wallet_id' + '}', encodeURIComponent(String(wallet_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'wallet_id' is not null or undefined
        if (wallet_id === null || wallet_id === undefined) {
            throw new Error('Required parameter wallet_id was null or undefined when calling multitenancyWalletWalletIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateWalletRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WalletRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WalletRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a subwallet
     * @param wallet_id Subwallet identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public multitenancyWalletWalletIdRemovePost (wallet_id: string, body?: RemoveWalletRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MultitenantModuleResponse;  }> {
        const localVarPath = this.basePath + '/multitenancy/wallet/{wallet_id}/remove'
            .replace('{' + 'wallet_id' + '}', encodeURIComponent(String(wallet_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'wallet_id' is not null or undefined
        if (wallet_id === null || wallet_id === undefined) {
            throw new Error('Required parameter wallet_id was null or undefined when calling multitenancyWalletWalletIdRemovePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RemoveWalletRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MultitenantModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MultitenantModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get auth token for a subwallet
     * @param wallet_id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public multitenancyWalletWalletIdTokenPost (wallet_id: string, body?: CreateWalletTokenRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateWalletTokenResponse;  }> {
        const localVarPath = this.basePath + '/multitenancy/wallet/{wallet_id}/token'
            .replace('{' + 'wallet_id' + '}', encodeURIComponent(String(wallet_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'wallet_id' is not null or undefined
        if (wallet_id === null || wallet_id === undefined) {
            throw new Error('Required parameter wallet_id was null or undefined when calling multitenancyWalletWalletIdTokenPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateWalletTokenRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateWalletTokenResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateWalletTokenResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Query subwallets
     * @param wallet_name Wallet name
     * @param {*} [options] Override http request options.
     */
    public multitenancyWalletsGet (wallet_name?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WalletList;  }> {
        const localVarPath = this.basePath + '/multitenancy/wallets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (wallet_name !== undefined) {
            localVarQueryParameters['wallet_name'] = ObjectSerializer.serialize(wallet_name, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WalletList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WalletList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OutOfBandApiApiKeys {
    AuthorizationHeader,
}

export class OutOfBandApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OutOfBandApiApiKeys, value: string) {
        (this.authentications as any)[OutOfBandApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new connection invitation
     * @param body 
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param multi_use Create invitation for multiple use (default false)
     * @param {*} [options] Override http request options.
     */
    public outOfBandCreateInvitationPost (body?: InvitationCreateRequest, auto_accept?: boolean, multi_use?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InvitationRecord;  }> {
        const localVarPath = this.basePath + '/out-of-band/create-invitation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }

        if (multi_use !== undefined) {
            localVarQueryParameters['multi_use'] = ObjectSerializer.serialize(multi_use, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "InvitationCreateRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InvitationRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvitationRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Receive a new connection invitation
     * @param body 
     * @param alias Alias for connection
     * @param auto_accept Auto-accept connection (defaults to configuration)
     * @param mediation_id Identifier for active mediation record to be used
     * @param use_existing_connection Use an existing connection, if possible
     * @param {*} [options] Override http request options.
     */
    public outOfBandReceiveInvitationPost (body?: InvitationMessage, alias?: string, auto_accept?: boolean, mediation_id?: string, use_existing_connection?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConnRecord;  }> {
        const localVarPath = this.basePath + '/out-of-band/receive-invitation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (auto_accept !== undefined) {
            localVarQueryParameters['auto_accept'] = ObjectSerializer.serialize(auto_accept, "boolean");
        }

        if (mediation_id !== undefined) {
            localVarQueryParameters['mediation_id'] = ObjectSerializer.serialize(mediation_id, "string");
        }

        if (use_existing_connection !== undefined) {
            localVarQueryParameters['use_existing_connection'] = ObjectSerializer.serialize(use_existing_connection, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "InvitationMessage")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PresentProofV10ApiApiKeys {
    AuthorizationHeader,
}

export class PresentProofV10Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PresentProofV10ApiApiKeys, value: string) {
        (this.authentications as any)[PresentProofV10ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a presentation request not bound to any proposal or connection
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProofCreateRequestPost (body?: V10PresentationCreateRequestRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }> {
        const localVarPath = this.basePath + '/present-proof/create-request';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10PresentationCreateRequestRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all present-proof exchange records
     * @param connection_id Connection identifier
     * @param role Role assigned in presentation exchange
     * @param state Presentation exchange state
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    public presentProofRecordsGet (connection_id?: string, role?: 'prover' | 'verifier', state?: 'proposal_sent' | 'proposal_received' | 'request_sent' | 'request_received' | 'presentation_sent' | 'presentation_received' | 'verified' | 'presentation_acked', thread_id?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentationExchangeList;  }> {
        const localVarPath = this.basePath + '/present-proof/records';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'prover' | 'verifier'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'proposal_sent' | 'proposal_received' | 'request_sent' | 'request_received' | 'presentation_sent' | 'presentation_received' | 'verified' | 'presentation_acked'");
        }

        if (thread_id !== undefined) {
            localVarQueryParameters['thread_id'] = ObjectSerializer.serialize(thread_id, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentationExchangeList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchangeList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch credentials for a presentation request from wallet
     * @param pres_ex_id Presentation exchange identifier
     * @param count Maximum number to retrieve
     * @param extra_query (JSON) object mapping referents to extra WQL queries
     * @param referent Proof request referents of interest, comma-separated
     * @param start Start index
     * @param {*} [options] Override http request options.
     */
    public presentProofRecordsPresExIdCredentialsGet (pres_ex_id: string, count?: string, extra_query?: string, referent?: string, start?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<IndyCredPrecis>;  }> {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/credentials'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdCredentialsGet.');
        }

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "string");
        }

        if (extra_query !== undefined) {
            localVarQueryParameters['extra_query'] = ObjectSerializer.serialize(extra_query, "string");
        }

        if (referent !== undefined) {
            localVarQueryParameters['referent'] = ObjectSerializer.serialize(referent, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<IndyCredPrecis>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<IndyCredPrecis>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove an existing presentation exchange record
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    public presentProofRecordsPresExIdDelete (pres_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentProofModuleResponse;  }> {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentProofModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentProofModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single presentation exchange record
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    public presentProofRecordsPresExIdGet (pres_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }> {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send a problem report for presentation exchange
     * @param pres_ex_id Presentation exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProofRecordsPresExIdProblemReportPost (pres_ex_id: string, body?: V10PresentationProblemReportRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentProofModuleResponse;  }> {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/problem-report'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdProblemReportPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10PresentationProblemReportRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentProofModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentProofModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a proof presentation
     * @param pres_ex_id Presentation exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProofRecordsPresExIdSendPresentationPost (pres_ex_id: string, body?: IndyPresSpec, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }> {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/send-presentation'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdSendPresentationPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "IndyPresSpec")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a presentation request in reference to a proposal
     * @param pres_ex_id Presentation exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProofRecordsPresExIdSendRequestPost (pres_ex_id: string, body?: AdminAPIMessageTracing, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }> {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/send-request'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdSendRequestPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminAPIMessageTracing")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Verify a received presentation
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    public presentProofRecordsPresExIdVerifyPresentationPost (pres_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }> {
        const localVarPath = this.basePath + '/present-proof/records/{pres_ex_id}/verify-presentation'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProofRecordsPresExIdVerifyPresentationPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a presentation proposal
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProofSendProposalPost (body?: V10PresentationProposalRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }> {
        const localVarPath = this.basePath + '/present-proof/send-proposal';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10PresentationProposalRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a free presentation request not bound to any proposal
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProofSendRequestPost (body?: V10PresentationSendRequestRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }> {
        const localVarPath = this.basePath + '/present-proof/send-request';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V10PresentationSendRequestRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V10PresentationExchange;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V10PresentationExchange");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PresentProofV20ApiApiKeys {
    AuthorizationHeader,
}

export class PresentProofV20Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PresentProofV20ApiApiKeys, value: string) {
        (this.authentications as any)[PresentProofV20ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a presentation request not bound to any proposal or connection
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProof20CreateRequestPost (body?: V20PresCreateRequestRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/create-request';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresCreateRequestRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all present-proof exchange records
     * @param connection_id Connection identifier
     * @param role Role assigned in presentation exchange
     * @param state Presentation exchange state
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    public presentProof20RecordsGet (connection_id?: string, role?: 'prover' | 'verifier', state?: 'proposal-sent' | 'proposal-received' | 'request-sent' | 'request-received' | 'presentation-sent' | 'presentation-received' | 'done' | 'abandoned', thread_id?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresExRecordList;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/records';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (connection_id !== undefined) {
            localVarQueryParameters['connection_id'] = ObjectSerializer.serialize(connection_id, "string");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "'prover' | 'verifier'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'proposal-sent' | 'proposal-received' | 'request-sent' | 'request-received' | 'presentation-sent' | 'presentation-received' | 'done' | 'abandoned'");
        }

        if (thread_id !== undefined) {
            localVarQueryParameters['thread_id'] = ObjectSerializer.serialize(thread_id, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresExRecordList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecordList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch credentials from wallet for presentation request
     * @param pres_ex_id Presentation exchange identifier
     * @param count Maximum number to retrieve
     * @param extra_query (JSON) object mapping referents to extra WQL queries
     * @param referent Proof request referents of interest, comma-separated
     * @param start Start index
     * @param {*} [options] Override http request options.
     */
    public presentProof20RecordsPresExIdCredentialsGet (pres_ex_id: string, count?: string, extra_query?: string, referent?: string, start?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<IndyCredPrecis>;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/credentials'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdCredentialsGet.');
        }

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "string");
        }

        if (extra_query !== undefined) {
            localVarQueryParameters['extra_query'] = ObjectSerializer.serialize(extra_query, "string");
        }

        if (referent !== undefined) {
            localVarQueryParameters['referent'] = ObjectSerializer.serialize(referent, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<IndyCredPrecis>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<IndyCredPrecis>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove an existing presentation exchange record
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    public presentProof20RecordsPresExIdDelete (pres_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresentProofModuleResponse;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresentProofModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresentProofModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single presentation exchange record
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    public presentProof20RecordsPresExIdGet (pres_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send a problem report for presentation exchange
     * @param pres_ex_id Presentation exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProof20RecordsPresExIdProblemReportPost (pres_ex_id: string, body?: V20PresProblemReportRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresentProofModuleResponse;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/problem-report'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdProblemReportPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresProblemReportRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresentProofModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresentProofModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a proof presentation
     * @param pres_ex_id Presentation exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProof20RecordsPresExIdSendPresentationPost (pres_ex_id: string, body?: V20PresSpecByFormatRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/send-presentation'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdSendPresentationPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresSpecByFormatRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a presentation request in reference to a proposal
     * @param pres_ex_id Presentation exchange identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProof20RecordsPresExIdSendRequestPost (pres_ex_id: string, body?: AdminAPIMessageTracing, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/send-request'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdSendRequestPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminAPIMessageTracing")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Verify a received presentation
     * @param pres_ex_id Presentation exchange identifier
     * @param {*} [options] Override http request options.
     */
    public presentProof20RecordsPresExIdVerifyPresentationPost (pres_ex_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/records/{pres_ex_id}/verify-presentation'
            .replace('{' + 'pres_ex_id' + '}', encodeURIComponent(String(pres_ex_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'pres_ex_id' is not null or undefined
        if (pres_ex_id === null || pres_ex_id === undefined) {
            throw new Error('Required parameter pres_ex_id was null or undefined when calling presentProof20RecordsPresExIdVerifyPresentationPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a presentation proposal
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProof20SendProposalPost (body?: V20PresProposalRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/send-proposal';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresProposalRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a free presentation request not bound to any proposal
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public presentProof20SendRequestPost (body?: V20PresSendRequestRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }> {
        const localVarPath = this.basePath + '/present-proof-2.0/send-request';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V20PresSendRequestRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: V20PresExRecord;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V20PresExRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum QAProtocolApiApiKeys {
    AuthorizationHeader,
}

export class QAProtocolApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: QAProtocolApiApiKeys, value: string) {
        (this.authentications as any)[QAProtocolApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Question & Answer Protocol
     * @param conn_id Connection identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public qaConnIdSendQuestionPost (conn_id: string, body?: QuestionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionRequestResponse;  }> {
        const localVarPath = this.basePath + '/qa/{conn_id}/send-question'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling qaConnIdSendQuestionPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QuestionRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionRequestResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionRequestResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Question & Answer Protocol
     * @param {*} [options] Override http request options.
     */
    public qaGetQuestionsGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/qa/get-questions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Question & Answer Protocol
     * @param {*} [options] Override http request options.
     */
    public qaGetQuestionsHead (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/qa/get-questions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Question & Answer Protocol
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    public qaThreadIdDelete (thread_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/qa/{thread_id}'
            .replace('{' + 'thread_id' + '}', encodeURIComponent(String(thread_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thread_id' is not null or undefined
        if (thread_id === null || thread_id === undefined) {
            throw new Error('Required parameter thread_id was null or undefined when calling qaThreadIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Question & Answer Protocol
     * @param thread_id Thread identifier
     * @param {*} [options] Override http request options.
     */
    public qaThreadIdSendAnswerPost (thread_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/qa/{thread_id}/send-answer'
            .replace('{' + 'thread_id' + '}', encodeURIComponent(String(thread_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thread_id' is not null or undefined
        if (thread_id === null || thread_id === undefined) {
            throw new Error('Required parameter thread_id was null or undefined when calling qaThreadIdSendAnswerPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ResolverApiApiKeys {
    AuthorizationHeader,
}

export class ResolverApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ResolverApiApiKeys, value: string) {
        (this.authentications as any)[ResolverApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve doc for requested did
     * @param did DID
     * @param {*} [options] Override http request options.
     */
    public resolverResolveDidGet (did: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ResolutionResult;  }> {
        const localVarPath = this.basePath + '/resolver/resolve/{did}'
            .replace('{' + 'did' + '}', encodeURIComponent(String(did)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling resolverResolveDidGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResolutionResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResolutionResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RevocationApiApiKeys {
    AuthorizationHeader,
}

export class RevocationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RevocationApiApiKeys, value: string) {
        (this.authentications as any)[RevocationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get current active revocation registry by credential definition id
     * @param cred_def_id Credential definition identifier
     * @param {*} [options] Override http request options.
     */
    public revocationActiveRegistryCredDefIdGet (cred_def_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevRegResult;  }> {
        const localVarPath = this.basePath + '/revocation/active-registry/{cred_def_id}'
            .replace('{' + 'cred_def_id' + '}', encodeURIComponent(String(cred_def_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cred_def_id' is not null or undefined
        if (cred_def_id === null || cred_def_id === undefined) {
            throw new Error('Required parameter cred_def_id was null or undefined when calling revocationActiveRegistryCredDefIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevRegResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Clear pending revocations
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public revocationClearPendingRevocationsPost (body?: ClearPendingRevocationsRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PublishRevocations;  }> {
        const localVarPath = this.basePath + '/revocation/clear-pending-revocations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ClearPendingRevocationsRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PublishRevocations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PublishRevocations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new revocation registry
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public revocationCreateRegistryPost (body?: RevRegCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevRegResult;  }> {
        const localVarPath = this.basePath + '/revocation/create-registry';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RevRegCreateRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevRegResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get credential revocation status
     * @param cred_ex_id Credential exchange identifier
     * @param cred_rev_id Credential revocation identifier
     * @param rev_reg_id Revocation registry identifier
     * @param {*} [options] Override http request options.
     */
    public revocationCredentialRecordGet (cred_ex_id?: string, cred_rev_id?: string, rev_reg_id?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CredRevRecordResult;  }> {
        const localVarPath = this.basePath + '/revocation/credential-record';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cred_ex_id !== undefined) {
            localVarQueryParameters['cred_ex_id'] = ObjectSerializer.serialize(cred_ex_id, "string");
        }

        if (cred_rev_id !== undefined) {
            localVarQueryParameters['cred_rev_id'] = ObjectSerializer.serialize(cred_rev_id, "string");
        }

        if (rev_reg_id !== undefined) {
            localVarQueryParameters['rev_reg_id'] = ObjectSerializer.serialize(rev_reg_id, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CredRevRecordResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CredRevRecordResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Publish pending revocations to ledger
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public revocationPublishRevocationsPost (body?: PublishRevocations, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TxnOrPublishRevocationsResult;  }> {
        const localVarPath = this.basePath + '/revocation/publish-revocations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PublishRevocations")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TxnOrPublishRevocationsResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TxnOrPublishRevocationsResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search for matching revocation registries that current agent created
     * @param cred_def_id Credential definition identifier
     * @param state Revocation registry state
     * @param {*} [options] Override http request options.
     */
    public revocationRegistriesCreatedGet (cred_def_id?: string, state?: 'init' | 'generated' | 'posted' | 'active' | 'full', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevRegsCreated;  }> {
        const localVarPath = this.basePath + '/revocation/registries/created';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cred_def_id !== undefined) {
            localVarQueryParameters['cred_def_id'] = ObjectSerializer.serialize(cred_def_id, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'init' | 'generated' | 'posted' | 'active' | 'full'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevRegsCreated;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevRegsCreated");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send revocation registry definition to ledger
     * @param rev_reg_id Revocation Registry identifier
     * @param conn_id Connection identifier
     * @param create_transaction_for_endorser Create Transaction For Endorser&#39;s signature
     * @param {*} [options] Override http request options.
     */
    public revocationRegistryRevRegIdDefinitionPost (rev_reg_id: string, conn_id?: string, create_transaction_for_endorser?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TxnOrRevRegResult;  }> {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/definition'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdDefinitionPost.');
        }

        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }

        if (create_transaction_for_endorser !== undefined) {
            localVarQueryParameters['create_transaction_for_endorser'] = ObjectSerializer.serialize(create_transaction_for_endorser, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TxnOrRevRegResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TxnOrRevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send revocation registry entry to ledger
     * @param rev_reg_id Revocation Registry identifier
     * @param conn_id Connection identifier
     * @param create_transaction_for_endorser Create Transaction For Endorser&#39;s signature
     * @param {*} [options] Override http request options.
     */
    public revocationRegistryRevRegIdEntryPost (rev_reg_id: string, conn_id?: string, create_transaction_for_endorser?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevRegResult;  }> {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/entry'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdEntryPost.');
        }

        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }

        if (create_transaction_for_endorser !== undefined) {
            localVarQueryParameters['create_transaction_for_endorser'] = ObjectSerializer.serialize(create_transaction_for_endorser, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevRegResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get revocation registry by revocation registry id
     * @param rev_reg_id Revocation Registry identifier
     * @param {*} [options] Override http request options.
     */
    public revocationRegistryRevRegIdGet (rev_reg_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevRegResult;  }> {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevRegResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get number of credentials issued against revocation registry
     * @param rev_reg_id Revocation Registry identifier
     * @param {*} [options] Override http request options.
     */
    public revocationRegistryRevRegIdIssuedGet (rev_reg_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevRegIssuedResult;  }> {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/issued'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdIssuedGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevRegIssuedResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevRegIssuedResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update revocation registry with new public URI to its tails file
     * @param rev_reg_id Revocation Registry identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public revocationRegistryRevRegIdPatch (rev_reg_id: string, body?: RevRegUpdateTailsFileUri, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevRegResult;  }> {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdPatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RevRegUpdateTailsFileUri")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevRegResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set revocation registry state manually
     * @param rev_reg_id Revocation Registry identifier
     * @param state Revocation registry state to set
     * @param {*} [options] Override http request options.
     */
    public revocationRegistryRevRegIdSetStatePatch (rev_reg_id: string, state: 'init' | 'generated' | 'posted' | 'active' | 'full', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevRegResult;  }> {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/set-state'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdSetStatePatch.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling revocationRegistryRevRegIdSetStatePatch.');
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'init' | 'generated' | 'posted' | 'active' | 'full'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevRegResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevRegResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Download tails file
     * @param rev_reg_id Revocation Registry identifier
     * @param {*} [options] Override http request options.
     */
    public revocationRegistryRevRegIdTailsFileGet (rev_reg_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/tails-file'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdTailsFileGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload local tails file to server
     * @param rev_reg_id Revocation Registry identifier
     * @param {*} [options] Override http request options.
     */
    public revocationRegistryRevRegIdTailsFilePut (rev_reg_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevocationModuleResponse;  }> {
        const localVarPath = this.basePath + '/revocation/registry/{rev_reg_id}/tails-file'
            .replace('{' + 'rev_reg_id' + '}', encodeURIComponent(String(rev_reg_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rev_reg_id' is not null or undefined
        if (rev_reg_id === null || rev_reg_id === undefined) {
            throw new Error('Required parameter rev_reg_id was null or undefined when calling revocationRegistryRevRegIdTailsFilePut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevocationModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevocationModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Revoke an issued credential
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public revocationRevokePost (body?: RevokeRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RevocationModuleResponse;  }> {
        const localVarPath = this.basePath + '/revocation/revoke';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RevokeRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RevocationModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevocationModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SchemaApiApiKeys {
    AuthorizationHeader,
}

export class SchemaApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SchemaApiApiKeys, value: string) {
        (this.authentications as any)[SchemaApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Search for matching schema that agent originated
     * @param schema_id Schema identifier
     * @param schema_issuer_did Schema issuer DID
     * @param schema_name Schema name
     * @param schema_version Schema version
     * @param {*} [options] Override http request options.
     */
    public schemasCreatedGet (schema_id?: string, schema_issuer_did?: string, schema_name?: string, schema_version?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SchemasCreatedResult;  }> {
        const localVarPath = this.basePath + '/schemas/created';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (schema_id !== undefined) {
            localVarQueryParameters['schema_id'] = ObjectSerializer.serialize(schema_id, "string");
        }

        if (schema_issuer_did !== undefined) {
            localVarQueryParameters['schema_issuer_did'] = ObjectSerializer.serialize(schema_issuer_did, "string");
        }

        if (schema_name !== undefined) {
            localVarQueryParameters['schema_name'] = ObjectSerializer.serialize(schema_name, "string");
        }

        if (schema_version !== undefined) {
            localVarQueryParameters['schema_version'] = ObjectSerializer.serialize(schema_version, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SchemasCreatedResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SchemasCreatedResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a schema to the ledger
     * @param body 
     * @param conn_id Connection identifier
     * @param create_transaction_for_endorser Create Transaction For Endorser&#39;s signature
     * @param {*} [options] Override http request options.
     */
    public schemasPost (body?: SchemaSendRequest, conn_id?: string, create_transaction_for_endorser?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TxnOrSchemaSendResult;  }> {
        const localVarPath = this.basePath + '/schemas';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (conn_id !== undefined) {
            localVarQueryParameters['conn_id'] = ObjectSerializer.serialize(conn_id, "string");
        }

        if (create_transaction_for_endorser !== undefined) {
            localVarQueryParameters['create_transaction_for_endorser'] = ObjectSerializer.serialize(create_transaction_for_endorser, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SchemaSendRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TxnOrSchemaSendResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TxnOrSchemaSendResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a schema from the ledger
     * @param schema_id Schema identifier
     * @param {*} [options] Override http request options.
     */
    public schemasSchemaIdGet (schema_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SchemaGetResult;  }> {
        const localVarPath = this.basePath + '/schemas/{schema_id}'
            .replace('{' + 'schema_id' + '}', encodeURIComponent(String(schema_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'schema_id' is not null or undefined
        if (schema_id === null || schema_id === undefined) {
            throw new Error('Required parameter schema_id was null or undefined when calling schemasSchemaIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SchemaGetResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SchemaGetResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Writes a schema non-secret record to the wallet
     * @param schema_id Schema identifier
     * @param {*} [options] Override http request options.
     */
    public schemasSchemaIdWriteRecordPost (schema_id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SchemaGetResult;  }> {
        const localVarPath = this.basePath + '/schemas/{schema_id}/write_record'
            .replace('{' + 'schema_id' + '}', encodeURIComponent(String(schema_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'schema_id' is not null or undefined
        if (schema_id === null || schema_id === undefined) {
            throw new Error('Required parameter schema_id was null or undefined when calling schemasSchemaIdWriteRecordPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SchemaGetResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SchemaGetResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServerApiApiKeys {
    AuthorizationHeader,
}

export class ServerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ServerApiApiKeys, value: string) {
        (this.authentications as any)[ServerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Fetch the list of loaded plugins
     * @param {*} [options] Override http request options.
     */
    public pluginsGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: AdminModules;  }> {
        const localVarPath = this.basePath + '/plugins';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AdminModules;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminModules");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Shut down server
     * @param {*} [options] Override http request options.
     */
    public shutdownGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: AdminShutdown;  }> {
        const localVarPath = this.basePath + '/shutdown';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AdminShutdown;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminShutdown");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch the server configuration
     * @param {*} [options] Override http request options.
     */
    public statusConfigGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: AdminConfig;  }> {
        const localVarPath = this.basePath + '/status/config';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AdminConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch the server status
     * @param {*} [options] Override http request options.
     */
    public statusGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: AdminStatus;  }> {
        const localVarPath = this.basePath + '/status';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AdminStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Liveliness check
     * @param {*} [options] Override http request options.
     */
    public statusLiveGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: AdminStatusLiveliness;  }> {
        const localVarPath = this.basePath + '/status/live';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AdminStatusLiveliness;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminStatusLiveliness");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Readiness check
     * @param {*} [options] Override http request options.
     */
    public statusReadyGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: AdminStatusReadiness;  }> {
        const localVarPath = this.basePath + '/status/ready';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AdminStatusReadiness;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminStatusReadiness");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset statistics
     * @param {*} [options] Override http request options.
     */
    public statusResetPost (options: any = {}) : Promise<{ response: http.IncomingMessage; body: AdminReset;  }> {
        const localVarPath = this.basePath + '/status/reset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AdminReset;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminReset");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TrustpingApiApiKeys {
    AuthorizationHeader,
}

export class TrustpingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TrustpingApiApiKeys, value: string) {
        (this.authentications as any)[TrustpingApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Send a trust ping to a connection
     * @param conn_id Connection identifier
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public connectionsConnIdSendPingPost (conn_id: string, body?: PingRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PingRequestResponse;  }> {
        const localVarPath = this.basePath + '/connections/{conn_id}/send-ping'
            .replace('{' + 'conn_id' + '}', encodeURIComponent(String(conn_id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conn_id' is not null or undefined
        if (conn_id === null || conn_id === undefined) {
            throw new Error('Required parameter conn_id was null or undefined when calling connectionsConnIdSendPingPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PingRequest")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PingRequestResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PingRequestResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WalletApiApiKeys {
    AuthorizationHeader,
}

export class WalletApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AuthorizationHeader': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WalletApiApiKeys, value: string) {
        (this.authentications as any)[WalletApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a local DID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public walletDidCreatePost (body?: DIDCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DIDResult;  }> {
        const localVarPath = this.basePath + '/wallet/did/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DIDCreate")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DIDResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DIDResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List wallet DIDs
     * @param did DID of interest
     * @param key_type Key type to query for.
     * @param method DID method to query for. e.g. sov to only fetch indy/sov DIDs
     * @param posture Whether DID is current public DID, posted to ledger but current public DID, or local to the wallet
     * @param verkey Verification key of interest
     * @param {*} [options] Override http request options.
     */
    public walletDidGet (did?: string, key_type?: 'ed25519' | 'bls12381g2', method?: 'key' | 'sov', posture?: 'public' | 'posted' | 'wallet_only', verkey?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DIDList;  }> {
        const localVarPath = this.basePath + '/wallet/did';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }

        if (key_type !== undefined) {
            localVarQueryParameters['key_type'] = ObjectSerializer.serialize(key_type, "'ed25519' | 'bls12381g2'");
        }

        if (method !== undefined) {
            localVarQueryParameters['method'] = ObjectSerializer.serialize(method, "'key' | 'sov'");
        }

        if (posture !== undefined) {
            localVarQueryParameters['posture'] = ObjectSerializer.serialize(posture, "'public' | 'posted' | 'wallet_only'");
        }

        if (verkey !== undefined) {
            localVarQueryParameters['verkey'] = ObjectSerializer.serialize(verkey, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DIDList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DIDList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Rotate keypair for a DID not posted to the ledger
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    public walletDidLocalRotateKeypairPatch (did: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WalletModuleResponse;  }> {
        const localVarPath = this.basePath + '/wallet/did/local/rotate-keypair';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling walletDidLocalRotateKeypairPatch.');
        }

        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WalletModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WalletModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch the current public DID
     * @param {*} [options] Override http request options.
     */
    public walletDidPublicGet (options: any = {}) : Promise<{ response: http.IncomingMessage; body: DIDResult;  }> {
        const localVarPath = this.basePath + '/wallet/did/public';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DIDResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DIDResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign the current public DID
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    public walletDidPublicPost (did: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DIDResult;  }> {
        const localVarPath = this.basePath + '/wallet/did/public';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling walletDidPublicPost.');
        }

        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DIDResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DIDResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Query DID endpoint in wallet
     * @param did DID of interest
     * @param {*} [options] Override http request options.
     */
    public walletGetDidEndpointGet (did: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DIDEndpoint;  }> {
        const localVarPath = this.basePath + '/wallet/get-did-endpoint';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'did' is not null or undefined
        if (did === null || did === undefined) {
            throw new Error('Required parameter did was null or undefined when calling walletGetDidEndpointGet.');
        }

        if (did !== undefined) {
            localVarQueryParameters['did'] = ObjectSerializer.serialize(did, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DIDEndpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DIDEndpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update endpoint in wallet and on ledger if posted to it
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public walletSetDidEndpointPost (body?: DIDEndpointWithType, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WalletModuleResponse;  }> {
        const localVarPath = this.basePath + '/wallet/set-did-endpoint';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DIDEndpointWithType")
        };

        this.authentications.AuthorizationHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WalletModuleResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WalletModuleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
